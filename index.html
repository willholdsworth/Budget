<!DOCTYPE html>
<html lang="en"><head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Budget Tracker</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&amp;display=swap">
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Space Grotesk', monospace;
  min-height: 100vh;
  padding: 20px;
  color: #000000;
  transition: all 0.3s ease;
  background: #ffffff;
}

body.dark-mode {
  background: #0a0a0a;
  color: #ffffff;
}

.fixed-header {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  background: #ffffff;
  padding: 20px;
  z-index: 1000;
  transition: all 0.3s ease;
  box-shadow: 0 3px 15px rgba(0, 0, 0, 0.08);
}

body.dark-mode .fixed-header {
  background: #000000;
  box-shadow: 0 3px 15px rgba(0, 0, 0, 0.3);
}

.header-content {
  max-width: 1000px;
  margin: 0 auto;
  display: flex;
  align-items: center;
  position: relative;
}

.header-left {
  position: absolute;
  left: 0;
}

.header-right {
  position: absolute;
  right: 0;
}

.greeting {
  font-size: 24px;
  font-weight: 300;
  letter-spacing: -0.02em;
  margin: 0 auto;
  text-align: center;
  flex-grow: 1;
}

.hamburger-btn {
  background: transparent;
  color: #000000;
  border: none;
  width: 50px;
  height: 50px;
  cursor: pointer;
  font-size: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
  font-family: inherit;
  position: relative;
  z-index: 1100;
  text-align: center;
}

body.dark-mode .hamburger-btn {
  color: #ffffff;
  background: #000000;
}

.hamburger-btn:focus {
  outline: none;
}

.hamburger-btn.menu-open {
  transform: rotate(90deg);
}

button {
  background: #000000;
  color: #ffffff;
  border: none;
  padding: 12px 24px;
  border-radius: 10px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
  transition: all 0.2s ease;
  font-family: inherit;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  transform: translateY(0);
  position: relative;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
}

body.dark-mode button {
  background: #ffffff;
  color: #000000;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
}

button::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
  transition: left 0.6s ease;
}

button:hover::before {
  left: 100%;
}

button:hover {
  transform: translateY(-2px);
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
}

body.dark-mode button:hover {
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
}

.btn-danger {
  background: #8e1600;
  color: #ffffff;
}

.btn-danger:hover {
  background: #721100;
  box-shadow: 0 6px 16px rgba(142, 22, 0, 0.3);
}

.btn-small {
  padding: 6px 12px;
  font-size: 12px;
  border-radius: 30px;
}

.save-btn {
  background: #8e1600;
  color: #ffffff;
  border: none;
  padding: 8px 16px;
  border-radius: 30px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
  transition: all 0.2s ease;
  font-family: inherit;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
}

.save-btn:hover:not(:disabled) {
  transform: translateY(-2px);
  opacity: 0.8;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
}

.save-btn.changed {
  background: #8e1600;
  border-radius: 30px;
}

.save-btn:disabled {
  cursor: not-allowed;
  opacity: 0.6;
  border-radius: 30px;
}

.sidebar {
  position: fixed;
  top: 0;
  left: -250px;
  width: 250px;
  height: 100%;
  background: #ffffff;
  border-right: 2px solid rgba(0, 0, 0, 0.08);
  padding: 80px 20px 20px;
  z-index: 1001;
  transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  box-shadow: 0 0 15px rgba(0, 0, 0, 0.05);
}

body.dark-mode .sidebar {
  background: #1a1a1a;
  border-right-color: rgba(255, 255, 255, 0.08);
  box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
}

.sidebar.open {
  left: 0;
  box-shadow: 4px 0 20px rgba(0, 0, 0, 0.1);
}

body.dark-mode .sidebar.open {
  box-shadow: 4px 0 20px rgba(0, 0, 0, 0.3);
}

.sidebar-menu {
  list-style: none;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.sidebar-menu li {
  width: 100%;
}

.sidebar-menu button, .sidebar-menu .currency-selector {
  width: 100%;
  padding: 12px 16px;
  border: 2px solid rgba(0, 0, 0, 0.08);
  border-radius: 10px;
  font-size: 14px;
  background: #ffffff;
  font-family: inherit;
  transition: all 0.2s ease;
  color: #000000;
  cursor: pointer;
  text-align: center;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
}

body.dark-mode .sidebar-menu button, body.dark-mode .sidebar-menu .currency-selector {
  border-color: rgba(255, 255, 255, 0.08);
  background: #1a1a1a;
  color: #ffffff;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

.sidebar-menu button:hover, .sidebar-menu .currency-selector:hover {
  background: #e8e8e8;
  color: #000000;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
}

body.dark-mode .sidebar-menu button:hover, body.dark-mode .sidebar-menu .currency-selector:hover {
  background: #333333;
  color: #ffffff;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

.sidebar-menu .checkbox-group {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 16px;
  border: 2px solid rgba(0, 0, 0, 0.08);
  border-radius: 10px;
  background: #ffffff;
  color: #000000;
  transition: all 0.2s ease;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
}

body.dark-mode .sidebar-menu .checkbox-group {
  border-color: rgba(255, 255, 255, 0.08);
  background: #1a1a1a;
  color: #ffffff;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

.sidebar-menu .checkbox-group:hover {
  background: #e8e8e8;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
}

body.dark-mode .sidebar-menu .checkbox-group:hover {
  background: #333333;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

.sidebar-menu .checkbox-group input[type="checkbox"] {
  width: auto;
  margin: 0;
}

.sidebar-menu .checkbox-group label {
  color: #000000;
  font-size: 14px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  cursor: pointer;
}

body.dark-mode .sidebar-menu .checkbox-group label {
  color: #ffffff;
}

.container {
  max-width: 1000px;
  margin: 70px auto 0;
  background: transparent;
}

.tabs {
  display: flex;
  background: transparent;
  padding: 8px 0;
  margin-bottom: 32px;
  gap: 8px;
  justify-content: center;
}

body.dark-mode .tabs {
  background: transparent;
}

.tab {
  flex: 0 0 auto;
  padding: 12px 24px;
  text-align: center;
  cursor: pointer;
  background: #ffffff;
  border-radius: 30px;
  font-weight: 600;
  font-size: 14px;
  color: #000000;
  transition: all 0.2s ease;
  font-family: inherit;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
  border: 1px solid rgba(0, 0, 0, 0.08);
}

body.dark-mode .tab {
  background: #1a1a1a;
  color: #ffffff;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
  border: 1px solid rgba(255, 255, 255, 0.08);
}

.tab.active {
  background: #000000;
  color: #ffffff;
  transform: translateY(-2px);
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
}

body.dark-mode .tab.active {
  background: #ffffff;
  color: #000000;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
}

.tab-content {
  display: none;
  opacity: 0;
  transform: translateY(20px);
  transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
}

.tab-content.active {
  display: block;
  opacity: 1;
  transform: translateY(0);
  animation: slideInUp 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}

.card {
  background: #ffffff;
  border-radius: 16px;
  padding: 32px;
  margin-bottom: 24px;
  border: 2px solid rgba(0, 0, 0, 0.08);
  transition: all 0.2s ease;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
}

body.dark-mode .card {
  background: #010101;
  border-color: rgba(255, 255, 255, 0.08);
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
}

.card:hover {
  transform: translateY(-3px);
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.08);
}

body.dark-mode .card:hover {
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
}

.card h3, .card h4 {
  margin-bottom: 20px;
  color: #000000;
  font-size: 18px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 1px;
}

body.dark-mode .card h3, body.dark-mode .card h4 {
  color: #ffffff;
}

.stat-card {
  background: #ffffff;
  border-radius: 30px;
  padding: 20px;
  text-align: center;
  border: 2px solid rgba(0, 0, 0, 0.08);
  transition: all 0.2s ease;
  box-shadow: 0 5px 5px rgba(0, 0, 0, 0.05);
}

body.dark-mode .stat-card {
  background: #1a1a1a;
  border-color: rgba(255, 255, 255, 0.08);
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
}

.stat-card:hover {
  transform: translateY(-10px);
  box-shadow: 0 8px px rgba(0, 0, 0, 0.08);
}

body.dark-mode .stat-card:hover {
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
}

.person-card {
  padding: 24px;
  border-radius: 16px;
  background: #ffffff;
  border: 2px solid rgba(0, 0, 0, 0.08);
  transition: all 0.2s ease;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
}

body.dark-mode .person-card {
  background: #1a1a1a;
  border-color: rgba(255, 255, 255, 0.08);
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
}

.person-card:hover {
  transform: translateY(-3px);
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.08);
}

body.dark-mode .person-card:hover {
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
}

.person-card h3 {
  color: #000000;
  margin-bottom: 16px;
  font-size: 16px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

body.dark-mode .person-card h3 {
  color: #ffffff;
}

.bill-item {
  background: #ffffff;
  border-radius: 16px;
  padding: 16px;
  margin-bottom: 12px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  border: 2px solid rgba(0, 0, 0, 0.08);
  transition: all 0.2s ease;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
}

body.dark-mode .bill-item {
  background: #1a1a1a;
  border-color: rgba(255, 255, 255, 0.08);
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
}

.bill-info {
  flex: 1;
}

.bill-info strong {
  font-size: 14px;
  color: #000000;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

body.dark-mode .bill-info strong {
  color: #ffffff;
}

.bill-info small {
  color: #666;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

body.dark-mode .bill-info small {
  color: #999;
}

.bill-actions {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.overview-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 16px;
  margin-bottom: 32px;
}

.stat-value {
  font-size: 22px;
  font-weight: 600;
  margin-bottom: 8px;
  color: #000000;
  transition: all 0.3s ease;
}

body.dark-mode .stat-value {
  color: #ffffff;
}

.stat-label {
  color: #666;
  font-size: 14px;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

body.dark-mode .stat-label {
  color: #999;
}

.person-overview {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: 20px;
  margin-bottom: 24px;
}

.person-info {
  display: grid;
  gap: 12px;
}

.info-item {
  display: flex;
  justify-content: space-between;
  padding: 8px 0;
  transition: all 0.2s ease;
}

.person-card .info-item:hover {
  background: transparent;
}

.debt-overview .info-item:hover {
  background: transparent;
}

.info-label {
  font-weight: 500;
  color: #666;
  font-size: 14px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

body.dark-mode .info-label {
  color: #999;
}

.info-value {
  font-weight: 600;
  color: #000000;
  font-size: 14px;
  text-align: right;
}

body.dark-mode .info-value {
  color: #ffffff;
}

.form-group {
  margin-bottom: 20px;
}

label {
  display: block;
  margin-bottom: 6px;
  font-weight: 500;
  color: #666;
  font-size: 14px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

body.dark-mode label {
  color: #999;
}

input, select, textarea {
  width: 100%;
  padding: 12px 16px;
  border: 2px solid rgba(0, 0, 0, 0.08);
  border-radius: 10px;
  font-size: 14px;
  background: #ffffff;
  font-family: inherit;
  transition: all 0.2s ease;
  color: #000000;
  transform: translateY(0);
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.03);
}

body.dark-mode input, body.dark-mode select, body.dark-mode textarea {
  border-color: rgba(255, 255, 255, 0.08);
  background: #1a1a1a;
  color: #ffffff;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
}

input:focus, select:focus, textarea:focus {
  outline: none;
  border-color: #666;
  transform: translateY(-2px);
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.06);
}

body.dark-mode input:focus, body.dark-mode select:focus, body.dark-mode textarea:focus {
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
}

body.dark-mode input[type="date"]::-webkit-calendar-picker-indicator {
  filter: invert(100%);
}

.checkbox-group {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 20px;
}

.checkbox-group input[type="checkbox"] {
  width: auto;
  margin: 0;
}

.payment-transfers {
  background: #f5f5f5;
  border-radius: 16px;
  padding: 20px;
  margin-bottom: 24px;
  border: 2px solid rgba(0, 0, 0, 0.08);
  animation: slideInUp 0.5s cubic-bezier(0.4, 0, 0.2, 1);
  box-shadow: 0 5px 20px rgba(0, 0, 0, 0.05);
}

body.dark-mode .payment-transfers {
  background: #2a2a2a;
  border-color: rgba(255, 255, 255, 0.08);
  box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
}

.transfer-item {
  display: flex;
  justify-content: space-between;
  padding: 8px 0;
  border-bottom: 1px solid rgba(0, 0, 0, 0.08);
}

body.dark-mode .transfer-item {
  border-bottom-color: rgba(255, 255, 255, 0.08);
}

.transfer-item:last-child {
  border-bottom: none;
}

.transfer-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: 20px;
  margin-bottom: 24px;
}

.debt-overview {
  background: #f5f5f5;
  border-radius: 16px;
  padding: 16px;
  margin-top: 16px;
  border: 2px solid rgba(0, 0, 0, 0.08);
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
}

body.dark-mode .debt-overview {
  background: #2a2a2a;
  border-color: rgba(255, 255, 255, 0.08);
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
}

.debt-item {
  margin-bottom: 20px;
}

.debt-item:last-child {
  margin-bottom: 0;
}

#debtsList .debt-item .info-item:first-child .info-label {
  font-weight: 1500;
  font-size: 1.1em;
}

.bills-section {
  margin-bottom: 24px;
}

.bills-group {
  margin-bottom: 20px;
  border: 2px solid rgba(0, 0, 0, 0.08);
  border-radius: 16px;
  padding: 15px;
  background: #ffffff;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
}

body.dark-mode .bills-group {
  border-color: rgba(255, 255, 255, 0.08);
  background: #1a1a1a;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
}

.bills-group-header {
  font-size: 16px;
  font-weight: 600;
  color: #000000;
  margin-bottom: 12px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

body.dark-mode .bills-group-header {
  color: #ffffff;
}

.history-table-wrapper {
  width: 100%;
  max-width: 100%;
  overflow: hidden;
  box-sizing: border-box;
}

.history-table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 20px;
  background: #ffffff;
  border-radius: 16px;
  overflow: hidden;
  border: 2px solid rgba(0, 0, 0, 0.08);
  table-layout: fixed;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
}

body.dark-mode .history-table {
  background: #1a1a1a;
  border-color: rgba(255, 255, 255, 0.08);
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
}

.history-table th, .history-table td {
  padding: 12px 16px;
  text-align: left;
  border-bottom: 1px solid rgba(0, 0, 0, 0.08);
  font-size: 14px;
  color: #000000;
  word-wrap: break-word;
  overflow-wrap: break-word;
}

body.dark-mode .history-table th, body.dark-mode .history-table td {
  border-color: rgba(255, 255, 255, 0.08);
  color: #ffffff;
}

.history-table th {
  background: #000000;
  font-weight: 600;
  color: #ffffff;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

body.dark-mode .history-table th {
  background: #ffffff;
  color: #000000;
}

.calendar-container {
  background: #f5f5f5;
  border-radius: 16px;
  padding: 20px;
  margin-bottom: 24px;
  border: 2px solid rgba(0, 0, 0, 0.08);
  overflow: hidden;
  animation: fadeInScale 0.6s cubic-bezier(0.4, 0, 0.2, 1);
  box-shadow: 0 5px 20px rgba(0, 0, 0, 0.05);
}

body.dark-mode .calendar-container {
  background: #2a2a2a;
  border-color: rgba(255, 255, 255, 0.08);
  box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
}

.calendar-container h4 {
  color: #000000;
  margin-bottom: 16px;
  font-size: 18px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  text-align: center;
}

body.dark-mode .calendar-container h4 {
  color: #ffffff;
}

.calendar-header-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.calendar-btn {
  background: #888 !important;
  color: white !important;
  border: none !important;
  width: 32px !important;
  height: 32px !important;
  border-radius: 50% !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  font-weight: bold !important;
  padding: 0 !important;
  cursor: pointer !important;
  text-align: center !important;
}

body.dark-mode .calendar-btn {
  color: #ffffff;
  background: #333333;
}

.calendar-grid {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  gap: 2px;
  position: relative;
}

.calendar-header {
  background: #000000;
  color: #ffffff;
  padding: 8px;
  text-align: center;
  font-weight: 600;
  font-size: 12px;
  text-transform: uppercase;
}

body.dark-mode .calendar-header {
  background: #ffffff;
  color: #000000;
}

.calendar-day {
    background: #ffffff;
    border: 1px solid rgba(0, 0, 0, 0.08);
    min-height: 80px;
    padding: 4px;
    position: relative;
    overflow: hidden;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    flex: 1;
}

body.dark-mode .calendar-day {
  background: #1a1a1a;
  border-color: rgba(255, 255, 255, 0.08);
}

.calendar-day.has-events {
  cursor: pointer;
}

.calendar-grid.has-expanded-day .calendar-day:not(.expanded) {
    min-width: 0;
    flex: 0.5;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

.calendar-day.expanded {
    flex: 10;
    min-height: 30px;
    overflow-y: auto;
    z-index: 2;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

.calendar-grid-row {
  display: flex;
  width: 100%;
}

body.dark-mode .calendar-day.expanded {
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
}

.calendar-day.empty {
  background: transparent !important;
  opacity: 0.4 !important;
  border: 1px solid rgba(0, 0, 0, 0.08) !important;
}

body.dark-mode .calendar-day.empty {
  border: 1px solid rgba(255, 255, 255, 0.08) !important;
}

.calendar-day.today {
  background: #ffffff;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
}

body.dark-mode .calendar-day.today {
  background: #1a1a1a;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
}

.calendar-day.today .day-number {
  color: #ffffff;
  background: #000000;
  border-radius: 50%;
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 4px;
}

body.dark-mode .calendar-day.today .day-number {
  color: #000000;
  background: #ffffff;
}

.day-number {
  font-weight: 600;
  font-size: 14px;
  margin-bottom: 2px;
  color: #000000;
}

body.dark-mode .day-number {
  color: #ffffff;
}

.day-events {
  display: flex;
  flex-direction: column;
  gap: 2px;
  transition: opacity 0.1s ease;
}

.bill-name, .payday-name, .bonus-name, .oneoff-name {
  display: block;
  font-size: 10px;
  padding: 2px 4px;
  margin: 2px 0;
  border-radius: 3px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.expanded .bill-name, .expanded .payday-name, .expanded .bonus-name, .expanded .oneoff-name {
  white-space: normal;
}

.bill-name {
  color: #000000;
  background: #e8e8e8;
}

body.dark-mode .bill-name {
  color: #ffffff;
  background: #333;
}

.payday-name {
  color: #000000;
  background: #4CAF50;
  font-weight: 600;
  font-style: uppercase;
  transition: opacity 0.1s ease;
}

.bonus-name {
  color: #000000;
  background: #9C27B0;
  font-weight: 600;
  font-style: uppercase;
  transition: opacity 0.1s ease;
}

.oneoff-name {
  color: #ffffff;
  background: #8e1600;
  font-weight: 600;
  transition: opacity 0.1s ease;
}

.day-close-btn {
  position: absolute;
  top: 0px;
  right: 0px;
  width: 0px;
  height: 0px;
  background: #fff;
  color: #fff;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0px;
  cursor: pointer;
  z-index: -1;
  display: none;
}

.expanded .day-close-btn {
  display: flex;
}

.event-dots {
  display: flex;
  gap: 4px;
  justify-content: center;
  margin-top: 4px;
}

.event-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  display: inline-block;
}

.bill-dot {
  background-color: #e8e8e8;
}

.payday-dot {
  background-color: #4CAF50;
}

.bonus-dot {
  background-color: #9C27B0;
}

.oneoff-dot {
  background-color: #8e1600;
}

.day-events-container {
  max-height: 60vh;
  overflow-y: auto;
}

.day-events-section {
  margin-bottom: 16px;
}

.day-events-section h4 {
  margin-bottom: 10px;
}

.day-event-item {
  padding: 10px;
  margin-bottom: 8px;
  border-radius: 4px;
  transition: opacity 0.1s ease;
}

.historical-income-container {
  background: #f5f5f5;
  border-radius: 16px;
  padding: 20px;
  margin-bottom: 24px;
  border: 2px solid rgba(0, 0, 0, 0.08);
  animation: slideInUp 0.6s cubic-bezier(0.4, 0, 0.2, 1);
  box-shadow: 0 5px 20px rgba(0, 0, 0, 0.05);
}

body.dark-mode .historical-income-container {
  background: #2a2a2a;
  border-color: rgba(255, 255, 255, 0.08);
  box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
}

.historical-income-container h4 {
  color: #000000;
  font-size: 18px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  text-align: center;
  margin-bottom: 20px;
}

body.dark-mode .historical-income-container h4 {
  color: #ffffff;
}

.year-group {
  margin-bottom: 20px;
  border: 2px solid rgba(0, 0, 0, 0.08);
  border-radius: 16px;
  padding: 15px;
  background: #ffffff;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
}

body.dark-mode .year-group {
  border-color: rgba(255, 255, 255, 0.08);
  background: #1a1a1a;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
}

.year-header {
  text-align: center;
  font-size: 16px;
  font-weight: 600;
  color: #000000;
  margin-bottom: 12px;
}

body.dark-mode .year-header {
  color: #ffffff;
}

.year-totals {
  text-align: center;
  font-size: 14px;
  color: #666;
  margin-bottom: 15px;
}

body.dark-mode .year-totals {
  color: #999;
}

.months-list {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.month-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 6px 12px;
  border-bottom: 1px solid rgba(0, 0, 0, 0.08);
  font-size: 14px;
}

body.dark-mode .month-item {
  border-bottom-color: rgba(255, 255, 255, 0.08);
}

.month-item:last-child {
  border-bottom: none;
}

.month-name {
  font-weight: 500;
  color: #000000;
}

body.dark-mode .month-name {
  color: #ffffff;
}

.month-total {
  font-weight: 600;
  color: #000000;
}

body.dark-mode .month-total {
  color: #ffffff;
}

.color-palette {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  gap: 8px;
  margin-top: 8px;
}

.color-option {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  cursor: pointer;
  border: 3px solid transparent;
  transition: all 0.3s ease;
}

.color-option.selected {
  border-color: #000000;
  transform: scale(1.1);
}

body.dark-mode .color-option.selected {
  border-color: #ffffff;
}

.color-swatch {
  display: inline-block;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  margin-right: 8px;
  border: 1px solid #ccc;
  vertical-align: middle;
}

.color-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  display: none;
  z-index: 10000;
  justify-content: center;
  align-items: center;
}

.color-modal-content {
  background: #ffffff;
  border: 2px solid rgba(0, 0, 0, 0.08);
  border-radius: 16px;
  padding: 32px;
  max-width: 400px;
  width: 90%;
  color: #000000;
  box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
}

body.dark-mode .color-modal-content {
  background: #1a1a1a;
  border-color: rgba(255, 255, 255, 0.08);
  color: #1a1a1a;
  box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
}

.color-option-item {
  display: flex;
  align-items: center;
  padding: 8px 12px;
  cursor: pointer;
  border-radius: 4px;
  margin: 4px 0;
  transition: background 0.2s ease;
}

.color-option-item:hover {
  background: rgba(0, 0, 0, 0.05);
}

body.dark-mode .color-option-item:hover {
  background: rgba(255, 255, 255, 0.05);
}

.person-color-dot {
  display: inline-block;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  margin-right: 8px;
  border: 1px solid rgba(0, 0, 0, 0.2);
  vertical-align: middle;
}

body.dark-mode .person-color-dot {
  border-color: rgba(255, 255, 255, 0.3);
}

@keyframes slideInUp {
  from {
    opacity: 0;
    transform: translateY(30px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes fadeInScale {
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

@keyframes cascadeIn {
  from {
    opacity: 0;
    transform: translateY(20px) scale(0.95);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

.cascade-item {
  animation: cascadeIn 0.5s cubic-bezier(0.4, 0, 0.2, 1) both;
}

.cascade-item:nth-child(1) {
  animation-delay: 0.05s;
}

.cascade-item:nth-child(2) {
  animation-delay: 0.1s;
}

.cascade-item:nth-child(3) {
  animation-delay: 0.15s;
}

.cascade-item:nth-child(4) {
  animation-delay: 0.2s;
}

.cascade-item:nth-child(5) {
  animation-delay: 0.25s;
}

.cascade-item:nth-child(6) {
  animation-delay: 0.3s;
}

.cascade-item:nth-child(7) {
  animation-delay: 0.35s;
}

.cascade-item:nth-child(8) {
  animation-delay: 0.4s;
}

.cascade-item:nth-child(9) {
  animation-delay: 0.45s;
}

.cascade-item:nth-child(10) {
  animation-delay: 0.5s;
}

@media (max-width: 1200px) {
  .overview-grid {
    grid-template-columns: repeat(4, 1fr);
    gap: 16px;
  }
  .stat-card {
    padding: 16px;
  }
  .stat-value {
    font-size: 20px;
  }
  
  #importExportBtn {
    width: 95px;
    height: 30px;
    font-size: 11px;
    line-height: 1;
    white-space: normal;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 4px;
  }
}

@media (max-width: 768px) {
  .tabs {
    flex-wrap: wrap;
    justify-content: center;
  }
  .overview-grid {
    grid-template-columns: repeat(2, 1fr);
    gap: 12px;
  }
  .person-overview, .transfer-grid {
    grid-template-columns: 1fr;
  }
  .greeting {
    font-size: 16px;
  }
  .hamburger-btn {
    width: 45px;
    height: 45px;
    font-size: 20px;
  }
  .tab {
    padding: 10px 16px;
    font-size: 12px;
  }
  .stat-card {
    padding: 12px;
  }
  .stat-value {
    font-size: 18px;
  }
  .calendar-day {
    min-height: 80px;
  }
  .bill-name, .payday-name, .bonus-name, .oneoff-name {
    font-size: 8px;
    padding: 1px 2px;
transition: opacity 0.1s ease;
  }
  .calendar-day.expanded {
    min-height: 120px;
transition: opacity 0.1s ease;
  }
  .header-right {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 8px;
  }
  #saveBtn, #importExportBtn {
    margin: 0;
    padding: 6px 12px;
    font-size: 12px;
  }
  .event-dot {
    width: 6px;
    height: 6px;
  }
  .event-dots {
    margin-top: 2px;
  }
  .history-table {
    table-layout: auto;
    min-width: 600px;
  }
  .history-table th, .history-table td {
    white-space: nowrap;
  }
  .history-table-wrapper {
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
  }
  @media (max-width: 360px) {
  #importExportBtn {
    width: 70px;
    height: 25px;
    font-size: 8px;
    line-height: 1.2;
    white-space: normal;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 4px;
  }
}

@media (max-width: 480px) {
  .overview-grid {
    grid-template-columns: repeat(2, 1fr);
    gap: 8px;
  }
  .greeting {
    font-size: 14px;
  }
  .hamburger-btn {
    width: 40px;
    height: 40px;
    font-size: 18px;
  }
  .tab {
    padding: 8px 10px;
    font-size: 10px;
  }
  .stat-card {
    padding: 8px;
  }
 
  .stat-value {
    font-size: 14px;
  }
  .container {
    padding: 0 10px;
  }
  body {
    padding: 10px;
  }
  .calendar-container {
    padding: 15px;
  }
  .calendar-day {
    min-height: 50px;
  }
  .day-number {
    font-size: 12px;
  }
  .calendar-day.expanded {
    min-height: auto;
    min-width: 60px;
    transition: all 0.3s ease;
  }
  .history-table {
    min-width: 550px;
    font-size: 12px;
  }
  .history-table th, .history-table td {
    padding: 8px 12px;
  }
}

@media (max-width: 360px) {
  #importExportBtn {
    width: 70px;
    height: 25px;
    font-size: 8px;
    line-height: 1.2;
    white-space: normal;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 4px;
  }
}

</style>
<link rel="manifest" href="./manifest.json"><meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#000000" media="(prefers-color-scheme: dark)"><link rel="apple-touch-icon" href="./icon-192.png"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="default"><link rel="manifest" href="./manifest.json"><meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#000000" media="(prefers-color-scheme: dark)"><link rel="apple-touch-icon" href="./icon-192.png"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="default"></head><body>
<div class="fixed-header">
 <div class="header-content">
   <div class="header-left"><button id="hamburgerBtn" class="hamburger-btn">☰</button></div>
   <div class="greeting" id="greeting">Hello, Welcome!</div>
   <div class="header-right" style="padding-top: 8px;">
     <button id="importExportBtn" class="save-btn" onclick="showImportExportModal()">SAVE/IMPORT</button>
   </div>
 </div>
 <div id="sidebar" class="sidebar">
<ul class="sidebar-menu">
<li><button id="addNewPersonBtn">Add New User</button></li>
<li class="checkbox-group"><input type="checkbox" id="weightedBillsSidebar"><label for="weightedBillsSidebar">Weight Bills By Income</label></li>
<li><select id="currencySelect" class="currency-selector"><option value="USD">$USD</option><option value="EUR">€EUR</option><option value="GBP">£GBP</option><option value="JPY">¥JPY</option><option value="CAD">$CAD</option></select></li>
<li><button id="toggleDarkModeBtn">Dark Mode</button></li>
</ul>
</div>
</div>
<div class="container">
<div class="tabs" id="tabsContainer">
<button class="tab active" data-tab="overview">Overview</button>
<button class="tab" data-tab="bills">Bills</button>
<button class="tab" id="addPersonTab" data-tab="add-person" style="display: block;">+ Add User</button>
<button class="tab" data-tab="history">History</button>
</div>
<div id="overview" class="tab-content active">
<div id="transfersOverview" class="transfer-grid" style="display:none;"></div>
<div class="overview-grid">
<div class="stat-card cascade-item"><div class="stat-value" id="totalIncome">£0.00</div><div class="stat-label">Total Income</div></div>
<div class="stat-card cascade-item"><div class="stat-value" id="totalBills">£0.00</div><div class="stat-value" id="billsPercentage" style="font-size:16px;margin-top:4px;">0%</div><div class="stat-label">Total Bills</div></div>
<div class="stat-card cascade-item"><div class="stat-value" id="totalSavings">£0.00</div><div class="stat-value" id="savingsPercentage" style="font-size:16px;margin-top:4px;">0%</div><div class="stat-label">Total Savings</div></div>
<div class="stat-card cascade-item"><div class="stat-value" id="totalLeftover">£0.00</div><div class="stat-value" id="leftoverPercentage" style="font-size:16px;margin-top:4px;">0%</div><div class="stat-label">Leftover</div></div>
</div>
<div id="billCalendar" class="cascade-item">
       <div class="calendar-container">
           <h4>June 2025</h4>
           <div class="calendar-grid">
               <div class="calendar-header">Sun</div>
               <div class="calendar-header">Mon</div>
               <div class="calendar-header">Tue</div>
               <div class="calendar-header">Wed</div>
               <div class="calendar-header">Thu</div>
               <div class="calendar-header">Fri</div>
               <div class="calendar-header">Sat</div>
   
           <div class="calendar-day ">
               <div class="day-number">1</div>
               
               
           </div>
       
           <div class="calendar-day ">
               <div class="day-number">2</div>
               
               
           </div>
       
           <div class="calendar-day ">
               <div class="day-number">3</div>
               
               
           </div>
       
           <div class="calendar-day ">
               <div class="day-number">4</div>
               
               
           </div>
       
           <div class="calendar-day ">
               <div class="day-number">5</div>
               
               
           </div>
       
           <div class="calendar-day ">
               <div class="day-number">6</div>
               
               
           </div>
       
           <div class="calendar-day ">
               <div class="day-number">7</div>
               
               
           </div>
       
           <div class="calendar-day ">
               <div class="day-number">8</div>
               
               
           </div>
       
           <div class="calendar-day ">
               <div class="day-number">9</div>
               
               
           </div>
       
           <div class="calendar-day ">
               <div class="day-number">10</div>
               
               
           </div>
       
           <div class="calendar-day ">
               <div class="day-number">11</div>
               
               
           </div>
       
           <div class="calendar-day ">
               <div class="day-number">12</div>
               
               
           </div>
       
           <div class="calendar-day ">
               <div class="day-number">13</div>
               
               
           </div>
       
           <div class="calendar-day ">
               <div class="day-number">14</div>
               
               
           </div>
       
           <div class="calendar-day ">
               <div class="day-number">15</div>
               
               
           </div>
       
           <div class="calendar-day ">
               <div class="day-number">16</div>
               
               
           </div>
       
           <div class="calendar-day ">
               <div class="day-number">17</div>
               
               
           </div>
       
           <div class="calendar-day ">
               <div class="day-number">18</div>
               
               
           </div>
       
           <div class="calendar-day ">
               <div class="day-number">19</div>
               
               
           </div>
       
           <div class="calendar-day ">
               <div class="day-number">20</div>
               
               
           </div>
       
           <div class="calendar-day ">
               <div class="day-number">21</div>
               
               
           </div>
       
           <div class="calendar-day ">
               <div class="day-number">22</div>
               
               
           </div>
       
           <div class="calendar-day ">
               <div class="day-number">23</div>
               
               
           </div>
       
           <div class="calendar-day ">
               <div class="day-number">24</div>
               
               
           </div>
       
           <div class="calendar-day today">
               <div class="day-number">25</div>
               
               
           </div>
       
           <div class="calendar-day ">
               <div class="day-number">26</div>
               
               
           </div>
       
           <div class="calendar-day ">
               <div class="day-number">27</div>
               
               
           </div>
       
           <div class="calendar-day ">
               <div class="day-number">28</div>
               
               
           </div>
       
           <div class="calendar-day ">
               <div class="day-number">29</div>
               
               
           </div>
       
           <div class="calendar-day ">
               <div class="day-number">30</div>
               
               
           </div>
       </div></div></div>
<div id="peopleOverview" class="person-overview"></div>
<div id="oneOffOverview" class="card cascade-item" style="display:none;"><h3>One-off Expenses This Month</h3><div id="oneOffList"></div></div>
<div id="debtOverview" class="card cascade-item" style="display:none;"><h3>Debt Overview</h3><div id="debtsList"></div></div>
</div>
<div id="bills" class="tab-content">
<div class="card cascade-item">
<h3>Add New Bill</h3>
<div class="form-group"><label for="billName">Bill Name</label><input type="text" id="billName" placeholder="Enter bill name"></div>
<div class="form-group"><label for="billAmount">Amount</label><input type="number" id="billAmount" placeholder="0.00" step="0.01"></div>
<div class="form-group"><label for="billFrequency">Frequency</label><select id="billFrequency"><option value="monthly" selected="">Monthly</option><option value="quarterly">Quarterly</option><option value="yearly">Yearly</option></select></div>
<div class="form-group"><label for="billDate">Due Day of Month</label><select id="billDate"><option value="">Select day...</option><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option><option value="6">6</option><option value="7">7</option><option value="8">8</option><option value="9">9</option><option value="10">10</option><option value="11">11</option><option value="12">12</option><option value="13">13</option><option value="14">14</option><option value="15">15</option><option value="16">16</option><option value="17">17</option><option value="18">18</option><option value="19">19</option><option value="20">20</option><option value="21">21</option><option value="22">22</option><option value="23">23</option><option value="24">24</option><option value="25">25</option><option value="26">26</option><option value="27">27</option><option value="28">28</option><option value="29">29</option><option value="30">30</option><option value="31">31</option></select></div>
<div class="form-group" id="billMonthGroup" style="display:none;"><label for="billMonth">Month</label><select id="billMonth"><option value="1">January</option><option value="2">February</option><option value="3">March</option><option value="4">April</option><option value="5">May</option><option value="6">June</option><option value="7">July</option><option value="8">August</option><option value="9">September</option><option value="10">October</option><option value="11">November</option><option value="12">December</option></select></div>
<div class="form-group" id="billStartMonthGroup" style="display:none;"><label for="billStartMonth">Start Month</label><select id="billStartMonth"><option value="1">January</option><option value="2">February</option><option value="3">March</option><option value="4">April</option><option value="5">May</option><option value="6">June</option><option value="7">July</option><option value="8">August</option><option value="9">September</option><option value="10">October</option><option value="11">November</option><option value="12">December</option></select></div>
<div class="form-group"><label for="billCategory">Category</label><select id="billCategory"><option value="Utilities">Utilities</option><option value="Housing">Housing</option><option value="Transportation">Transportation</option><option value="Insurance">Insurance</option><option value="Entertainment">Entertainment</option><option value="Subscriptions">Subscriptions</option><option value="Government">Government</option><option value="Financial">Financial</option><option value="Health &amp; Fitness">Health &amp; Fitness</option><option value="Technology">Technology</option><option value="Other">Other</option></select></div>
<div class="form-group" id="billTypeGroup" style="display: none;"><label for="billType">Bill Type</label><select id="billType"><option value="individual">Individual</option><option value="joint">Joint</option></select></div>
<div class="form-group" id="billPayerGroup" style="display: none;"><label for="billPayer">Paid By</label><select id="billPayer"></select></div>
<div class="checkbox-group"><input type="checkbox" id="isDebt"><label for="isDebt">This is a debt/loan</label></div>
<div class="checkbox-group"><input type="checkbox" id="isOneOff"><label for="isOneOff">This is a one-off unexpected expense</label></div>
<div id="debtFields" style="display:none;">
<div class="form-group"><label for="totalDebt">Total Debt Amount</label><input type="number" id="totalDebt" placeholder="0.00" step="0.01"></div>
<div class="form-group"><label for="interestRate">Interest Rate (% - optional)</label><input type="number" id="interestRate" placeholder="0.00" step="0.01"></div>
<div class="form-group"><label for="termYears">Term Length Years (optional)</label><input type="number" id="termYears" placeholder="30" min="0"></div>
<div class="form-group"><label for="termMonths">Additional Months (optional)</label><input type="number" id="termMonths" placeholder="0" min="0" max="11"></div>
<div class="form-group"><label for="overpayment">Monthly Overpayment (optional)</label><input type="number" id="overpayment" placeholder="0.00" step="0.01"></div>
</div>
<button id="addBillBtn">Add Bill</button>
</div>
<div class="card cascade-item"><h3>All Bills</h3><div id="billsList"></div></div>
</div>
<div id="history" class="tab-content">
<div class="card cascade-item">
<h3>Income &amp; Salary History</h3>
<div class="form-group"><label for="historyPersonFilter">Filter by Person</label><select id="historyPersonFilter"><option value="all">All People</option></select></div>
<div class="form-group"><label for="historyStartDate">Start Date</label><input type="date" id="historyStartDate"></div>
<div class="form-group"><label for="historyEndDate">End Date</label><input type="date" id="historyEndDate"></div>
<button id="clearHistoryFiltersBtn">Clear Filters</button>
<button id="fullResetBtn" class="btn-danger" style="margin-top:8px;">Full Reset</button>
<div class="history-table-wrapper"><table class="history-table"><thead><tr><th>Date</th><th>Person</th><th>Type</th><th>Amount</th><th>Description</th><th>Actions</th></tr></thead><tbody id="incomeHistoryList"><tr><td colspan="6">No income data for selected person.</td></tr></tbody></table></div>
</div>
<div class="card cascade-item">
<h3>Bill History</h3>
<div class="form-group">
    <label for="billNameFilter">Filter by Bill Name</label>
    <input type="text" id="billNameFilter" placeholder="Enter bill name" onkeyup="updateHistoryDisplay()">
</div>
<div class="history-table-wrapper"><table class="history-table"><thead><tr><th>Date</th><th>Bill Name</th><th>Amount</th><th>Category</th><th>Type</th><th>Actions</th></tr></thead><tbody id="billHistoryList"><tr><td colspan="6">No bill payments for selected person.</td></tr></tbody></table></div></div>
<div class="card cascade-item"><h3>Event History</h3><div class="history-table-wrapper"><table class="history-table"><thead><tr><th>Date</th><th>Event</th><th>Description</th><th>Actions</th></tr></thead><tbody id="eventHistoryList"><tr><td colspan="4">No events for selected person.</td></tr></tbody></table></div></div>
</div>
</div>
<script id="embedded-data" type="application/json">{
        "people": [],
        "bills": [],
        "currency": "GBP",
        "darkMode": false,
        "weightedBills": false,
        "nextPersonId": 1,
        "nextBillId": 1,
        "nextIncomeId": 1,
        "nextEventId": 2,
        "nextPaycheckId": 1,
        "paycheckHistory": [],
        "billHistory": [],
        "eventHistory": [],
        "billPayments": [],
        "lastProcessedDate": "2025-06-25",
        "peopleIncomeSettings": {},
        "savedFileHandle": null
}</script>
<script>
let data = {};
let nextPersonId = 1;
let nextBillId = 1;
let nextIncomeId = 1;
let nextEventId = 1;
let nextPaycheckId = 1;
let hasChanges = false;
let originalEmbeddedData = {};
let sessionStartData = {};
let savedFileHandle = null;
let isPostImport = false;
let isImporting = false;
let importBaseline = {};
const OriginalDate = Date;
window.Date = function(...args) {
    if (args.length === 1 && typeof args[0] === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(args[0])) {
        return new OriginalDate(args[0] + 'T00:00:00');
    }
    return new OriginalDate(...args);
};
Object.setPrototypeOf(window.Date, OriginalDate);
window.Date.prototype = OriginalDate.prototype;
window.Date.now = OriginalDate.now;
window.Date.parse = OriginalDate.parse;
window.Date.UTC = OriginalDate.UTC;
const STORAGE_KEY = 'budgetTrackerData';
const $ = id => document.getElementById(id);
const colorPalette = [
    {name: 'Moss', value: '#b9b99d'},
    {name: 'Blush', value: '#E0CFC3'},
    {name: 'Sand', value: '#D5caba'},
    {name: 'Fir', value: '#606c5a'},
    {name: 'Earth', value: '#8f837a'},
    {name: 'Water', value: '#95a8ac'},
    {name: 'Golden', value: '#dcb482'}
];


let currentViewMonth = new Date().getMonth();
let currentViewYear = new Date().getFullYear();

function updateCalendarView(year = null, month = null) {
    if (year !== null) currentViewYear = year;
    if (month !== null) currentViewMonth = month;
   
    const billCalendar = document.getElementById('billCalendar');
    if (!billCalendar) return;
   
    billCalendar.innerHTML = createCalendarView(currentViewYear, currentViewMonth);
   
    setTimeout(() => {
        initCalendarInteractions();
    }, 100);
}

function markAsPostImport() {
    setTimeout(() => {
        isPostImport = true;
        importBaseline = JSON.parse(JSON.stringify(data));
        localStorage.removeItem(STORAGE_KEY);
        isImporting = false;
        console.log('Post-import mode activated, localStorage cleared');
    }, 500);
}



function navigateCalendar(direction) {
    let newMonth = currentViewMonth + direction;
    let newYear = currentViewYear;
   
    if (newMonth > 11) {
        newMonth = 0;
        newYear++;
    } else if (newMonth < 0) {
        newMonth = 11;
        newYear--;
    }
   
    currentViewMonth = newMonth;
    currentViewYear = newYear;
   
    const billCalendar = $('billCalendar');
    if (billCalendar) {
        billCalendar.innerHTML = '';
    }
   
    updateCalendarView();
}

function createCalendarView(year = null, month = null) {
    const today = new Date();
    const currentMonth = month !== null ? month : today.getMonth();
    const currentYear = year !== null ? year : today.getFullYear();
   
    const firstDay = new Date(currentYear, currentMonth, 1);
    const lastDay = new Date(currentYear, currentMonth + 1, 0);
    const daysInMonth = lastDay.getDate();
    const startingDayOfWeek = firstDay.getDay();
   
    const prevMonth = new Date(currentYear, currentMonth, 0);
    const prevMonthDays = prevMonth.getDate();
   
    const monthNames = ["January", "February", "March", "April", "May", "June",
                       "July", "August", "September", "October", "November", "December"];
   
    let calendarHTML = `
        <div class="calendar-container">
            <div class="calendar-header-row">
                <button id="prevMonthBtn" class="calendar-btn">&lt;</button>
                <h4>${monthNames[currentMonth]} ${currentYear}</h4>
                <button id="nextMonthBtn" class="calendar-btn">&gt;</button>
            </div>
            <div class="calendar-grid" id="calendarGrid">
                <div class="calendar-header">Sun</div>
                <div class="calendar-header">Mon</div>
                <div class="calendar-header">Tue</div>
                <div class="calendar-header">Wed</div>
                <div class="calendar-header">Thu</div>
                <div class="calendar-header">Fri</div>
                <div class="calendar-header">Sat</div>
    `;
   
    let dayCount = 1;
    let nextMonthDay = 1;
   
    const totalDaysToShow = startingDayOfWeek + daysInMonth;
    const totalRows = Math.ceil(totalDaysToShow / 7);
   
    for (let i = 0; i < totalRows; i++) {
        for (let j = 0; j < 7; j++) {
            if (i === 0 && j < startingDayOfWeek) {
                const prevDate = prevMonthDays - (startingDayOfWeek - j - 1);
                const prevMonthDate = new Date(currentYear, currentMonth - 1, prevDate);
                const dayEvents = getDayEvents(prevMonthDate);
               
                calendarHTML += `
                    <div class="calendar-day empty" data-day="${prevDate}" data-month="${prevMonthDate.getMonth()}" data-year="${prevMonthDate.getFullYear()}">
                        <div class="day-close-btn">×</div>
                        <div class="day-number">${prevDate}</div>
                        <div class="day-events">
                            ${dayEvents.billText}
                            ${dayEvents.paydayText}
                            ${dayEvents.bonusText}
                            ${dayEvents.oneOffText}
                        </div>
                    </div>
                `;
            } else if (dayCount > daysInMonth) {
                const nextMonthDate = new Date(currentYear, currentMonth + 1, nextMonthDay);
                const dayEvents = getDayEvents(nextMonthDate);
               
                calendarHTML += `
                    <div class="calendar-day empty" data-day="${nextMonthDay}" data-month="${nextMonthDate.getMonth()}" data-year="${nextMonthDate.getFullYear()}">
                        <div class="day-close-btn">×</div>
                        <div class="day-number">${nextMonthDay}</div>
                        <div class="day-events">
                            ${dayEvents.billText}
                            ${dayEvents.paydayText}
                            ${dayEvents.bonusText}
                            ${dayEvents.oneOffText}
                        </div>
                    </div>
                `;
                nextMonthDay++;
            } else {
                const isToday = dayCount === today.getDate() &&
                               currentMonth === today.getMonth() &&
                               currentYear === today.getFullYear();
               
                const currentDayDate = new Date(currentYear, currentMonth, dayCount);
                const dayEvents = getDayEvents(currentDayDate);
               
                calendarHTML += `
                    <div class="calendar-day ${isToday ? 'today' : ''}" data-day="${dayCount}" data-month="${currentMonth}" data-year="${currentYear}">
                        <div class="day-close-btn">×</div>
                        <div class="day-number">${dayCount}</div>
                        <div class="day-events">
                            ${dayEvents.billText}
                            ${dayEvents.paydayText}
                            ${dayEvents.bonusText}
                            ${dayEvents.oneOffText}
                        </div>
                    </div>
                `;
                dayCount++;
            }
        }
    }
   
    calendarHTML += '</div></div>';
    return calendarHTML;
}

function getDayEvents(date) {
   const day = date.getDate();
   const month = date.getMonth();
   const year = date.getFullYear();
   const today = getDateString();
   const dateStr = getDateString(date);
   
   const billsForDay = [];
   const paydaysForDay = [];
   const bonusesForDay = [];
   const oneOffsForDay = [];
   
   const billPaymentsOnThisDay = data.billPayments.filter(payment => payment.date === dateStr);
   const billIdsWithPayments = new Set(billPaymentsOnThisDay.map(payment => payment.billId));
   
   const processedOneOffIds = new Set();
   
   data.bills.forEach(bill => {
       if (bill.isDeleted) return;
       
       if (bill.isOneOff) {
           const billDate = getDateString(bill.date);
           if (billDate === dateStr) {
               if (processedOneOffIds.has(bill.id)) return;
               
               const payer = bill.payer === 'joint' ? null : data.people.find(p => p.id === bill.payer);
               oneOffsForDay.push({
                   ...bill,
                   payerColor: payer ? payer.color : null
               });
               
               processedOneOffIds.add(bill.id);
           }
           return;
       }
       
       if (billIdsWithPayments.has(bill.id)) {
           return;
       }
       
       if (isBillDueOnDate(bill, date)) {
           const payer = bill.payer === 'joint' ? null : data.people.find(p => p.id === bill.payer);
           billsForDay.push({
               ...bill,
               payerColor: payer ? payer.color : null,
               isPaid: false
           });
       }
   });
   
   billPaymentsOnThisDay.forEach(payment => {
       const originalBill = data.bills.find(b => b.id === payment.billId);
       
       if (originalBill && originalBill.isOneOff) {
           if (processedOneOffIds.has(originalBill.id)) return;
           processedOneOffIds.add(originalBill.id);
           
           const payer = payment.payer === 'joint' ? null : data.people.find(p => p.id === payment.payer);
           oneOffsForDay.push({
               ...originalBill,
               name: payment.billName || originalBill.name,
               amount: payment.amount - (originalBill?.overpayment || 0),
               payerColor: payer ? payer.color : null,
               isPaid: true
           });
           return;
       }
       
       const payer = payment.payer === 'joint' ? null : data.people.find(p => p.id === payment.payer);
       billsForDay.push({
           id: payment.billId,
           name: payment.billName,
           amount: payment.amount - (originalBill?.overpayment || 0),
           overpayment: originalBill?.overpayment || 0,
           category: payment.category,
           payerColor: payer ? payer.color : null,
           isPaid: true,
           isHistorical: true,
           isEdited: payment.status && payment.status.includes('(edited)')
       });
   });
   
   data.paycheckHistory.forEach(paycheck => {
       if (paycheck.date === dateStr) {
           const person = data.people.find(p => p.id === paycheck.personId);
           if (person) {
               if (paycheck.type === 'bonus') {
                   bonusesForDay.push({ person, amount: paycheck.amount });
               } else {
                   paydaysForDay.push({ ...person, amount: paycheck.amount });
               }
           }
       }
   });
   
   const isViewingFutureOrToday = dateStr >= today;
   
   if (isViewingFutureOrToday) {
       data.people.forEach(person => {
           if (isPaydayOnDate(person, day, month, year)) {
               if (!paydaysForDay.some(p => p.id === person.id)) {
                   paydaysForDay.push(person);
               }
           }
       });
   }
   
   const billText = billsForDay.map(bill => {
       const backgroundColor = bill.payerColor ? bill.payerColor : '#e8e8e8';
       const textColor = bill.payerColor ? getContrastColor(bill.payerColor) : '#000000';
       return `<span class="bill-name" style="background-color: ${backgroundColor}; color: ${textColor};">${bill.name}: ${formatCurrency(bill.amount + (bill.overpayment || 0))}</span>`;
   }).join('');
   
   const paydayText = paydaysForDay.map(person => {
       return `<span class="payday-name" style="background-color: ${person.color}; color: #000000;">${person.name} Payday: ${formatCurrency(person.amount || person.income || 0)}</span>`;
   }).join('');
   
   const bonusText = bonusesForDay.map(bonus => {
       return `<span class="bonus-name" style="background-color: ${bonus.person.color}; color: #000000;">${bonus.person.name} Bonus: ${formatCurrency(bonus.amount)}</span>`;
   }).join('');
   
   const oneOffText = oneOffsForDay.map(oneOff => {
       const backgroundColor = oneOff.payerColor ? oneOff.payerColor : '#e8e8e8';
       const textColor = oneOff.payerColor ? getContrastColor(oneOff.payerColor) : '#000000';
       return `<span class="oneoff-name" style="background-color: ${backgroundColor}; color: ${textColor};">${oneOff.name}: ${formatCurrency(oneOff.amount)}</span>`;
   }).join('');
   
   return {
       billText,
       paydayText,
       bonusText,
       oneOffText
   };
}

function isBillDueOnDate(bill, date) {
   if (bill.isDeleted) return false;
 
   const billCreatedDate = getDateString(bill.dateCreated) || '1970-01-01';
   const checkDate = getDateString(date);
   const day = new Date(checkDate).getDate();
   const month = new Date(checkDate).getMonth();
   const year = new Date(checkDate).getFullYear();
   
   if (!bill.isOneOff) {
       const currentMonth = `${year}-${String(month + 1).padStart(2, '0')}`;
       const editedPaymentsThisMonth = data.billPayments.filter(payment =>
           payment.billId === bill.id &&
           payment.date.startsWith(currentMonth) &&
           new Date(payment.date).getDate() !== bill.day
       );
       
       if (editedPaymentsThisMonth.length > 0 && day === bill.day) {
           return false;
       }
   }
 
   if (bill.isOneOff) {
       const billDate = getDateString(bill.date);
       return billDate === checkDate;
   }
 
   const billDay = bill.day || new Date(getDateString(bill.date)).getDate();
 
   if (billDay !== day) {
       return false;
   }
 
   if (bill.frequency === 'monthly') {
       const billCreatedMonth = new Date(billCreatedDate).getMonth();
       const billCreatedYear = new Date(billCreatedDate).getFullYear();
     
       return year > billCreatedYear ||
              (year === billCreatedYear && month >= billCreatedMonth);
   } else if (bill.frequency === 'quarterly') {
       const billStartMonth = bill.startMonth || (new Date(billCreatedDate).getMonth() + 1);
       let quarterMonths = [];
       for (let k = 0; k < 4; k++) {
           quarterMonths.push(((billStartMonth - 1 + k * 3) % 12) + 1);
       }
     
       if (quarterMonths.includes(month + 1)) {
           const billCreatedYear = new Date(billCreatedDate).getFullYear();
           const firstQuarterMonth = billStartMonth - 1;
         
           return year > billCreatedYear ||
                  (year === billCreatedYear && month >= firstQuarterMonth);
       }
   } else if (bill.frequency === 'yearly' && bill.month) {
       if (bill.month - 1 === month) {
           const billCreatedYear = new Date(billCreatedDate).getFullYear();
         
           return year > billCreatedYear ||
                  (year === billCreatedYear && month >= new Date(billCreatedDate).getMonth());
       }
   }
 
   return false;
}



function navigateCalendar(direction) {
    let newMonth = currentViewMonth + direction;
    let newYear = currentViewYear;
   
    if (newMonth > 11) {
        newMonth = 0;
        newYear++;
    } else if (newMonth < 0) {
        newMonth = 11;
        newYear--;
    }
   
    currentViewMonth = newMonth;
    currentViewYear = newYear;
    updateCalendarView();
}

function resetCalendarToCurrentMonth() {
    const today = new Date();
    currentViewMonth = today.getMonth();
    currentViewYear = today.getFullYear();
    updateCalendarView();
}

function frequencyToMonthly(amount, frequency) {
    switch (frequency) {
        case 'weekly': return amount * 4.33;
        case 'biweekly': return amount * 26 / 12;
        case 'monthly': return amount;
        case 'quarterly': return amount / 3;
        case 'yearly': return amount / 12;
        default: return amount;
    }
}

function updateImportButtonHandler() {
    $('importBtn').addEventListener('click', () => {
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = '.txt';
        fileInput.style.display = 'none';
        document.body.appendChild(fileInput);
       
        fileInput.click();
       
        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) {
                document.body.removeChild(fileInput);
                return;
            }
           
            if (!confirm('Importing will replace all current data with the data from the selected file. Continue?')) {
                document.body.removeChild(fileInput);
                return;
            }
           
            isImporting = true;
           
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const fileContent = e.target.result;
                   
                    const importSuccess = processImportData(fileContent);
                   
                    if (!importSuccess) {
                        alert('Failed to import data. The file may be invalid or corrupted.');
                        document.body.removeChild(fileInput);
                        isImporting = false;
                        return;
                    }
                   
                    document.querySelectorAll('.tab[data-person-id]').forEach(tab => tab.remove());
                    document.querySelectorAll('.tab-content[id^="person-"]').forEach(content => content.remove());
                   
                    if (data.darkMode) {
                        document.body.classList.add('dark-mode');
                    } else {
                        document.body.classList.remove('dark-mode');
                    }
                   
                    $('currencySelect').value = data.currency;
                    $('weightedBillsSidebar').checked = data.weightedBills;
                   
                    data.people.forEach(person => createPersonTab(person));
                    attachPersonEventListeners();
                   
                    updateGreeting();
                    updateBillPayerOptions();
                    updateBillsList();
                    updateHistoryDisplay();
                    updateOverview();
                    toggleBillTypeVisibility();
                    updateTabsVisibility();
                   
                    setTimeout(() => {
                        data.eventHistory.push({
                            id: nextEventId++,
                            date: new Date().toISOString().split('T')[0],
                            event: 'Data Imported',
                            description: 'Imported data from a budget file'
                        });
                       
                        hideModal();
                        showTab('overview');
                       
                        alert('Data imported successfully!');
                    }, 600);
                   
                } catch (e) {
                    isImporting = false;
                    console.error('Import error:', e);
                    alert('Failed to import data. The file may be invalid or corrupted.');
                }
               
                document.body.removeChild(fileInput);
            };
           
            reader.readAsText(file);
        });
    });
}

function enhanceImportExportModal() {
    const originalShowImportExportModal = showImportExportModal;
   
    window.showImportExportModal = function() {
        originalShowImportExportModal.apply(this, arguments);
        updateImportButtonHandler();
    };
}

function initializeEnhancedImport() {
    enhanceImportExportModal();
   
    window.processElapsedIncome = processElapsedIncome;
    window.processImportIncome = processImportIncome;
    window.processImportData = processImportData;
}

function enhanceAttachEventListeners() {
    const originalAttachEventListeners = attachEventListeners;
   
    window.attachEventListeners = function() {
        originalAttachEventListeners.apply(this, arguments);
        initializeEnhancedImport();
    };
}

async function processImportData(fileContent) {
    isImporting = true;
   
    try {
        const cleanContent = fileContent.trim();
        
        if (!/^[A-Za-z0-9+/]*={0,2}$/.test(cleanContent)) {
            throw new Error('Invalid base64 format - file may be corrupted');
        }
        
        const sizeInMB = new Blob([cleanContent]).size / 1024 / 1024;
        if (sizeInMB > 5) {
            const proceed = confirm(
                `This file is ${sizeInMB.toFixed(1)}MB. ` +
                `Large files may cause performance issues on mobile devices. ` +
                `Continue anyway?`
            );
            if (!proceed) {
                isImporting = false;
                return false;
            }
        }
        
        let decodedContent;
        try {
            decodedContent = atob(cleanContent);
        } catch (e) {
            throw new Error('Failed to decode base64 - file may be corrupted or truncated');
        }
        
        const importData = JSON.parse(decodedContent);
       
        if (!importData.people || !importData.bills) {
            throw new Error('Invalid import data format - missing required fields');
        }

        if (importData.paycheckHistory?.length > 500) {
            const results = [];
            for (let i = 0; i < importData.paycheckHistory.length; i += 100) {
                const chunk = importData.paycheckHistory.slice(i, i + 100);
                results.push(...chunk);
                await new Promise(resolve => setTimeout(resolve, 0));
            }
            importData.paycheckHistory = results;
        }
        
        if (importData.billPayments?.length > 500) {
            const results = [];
            for (let i = 0; i < importData.billPayments.length; i += 100) {
                const chunk = importData.billPayments.slice(i, i + 100);
                results.push(...chunk);
                await new Promise(resolve => setTimeout(resolve, 0));
            }
            importData.billPayments = results;
        }
        
        if (importData.eventHistory?.length > 500) {
            const results = [];
            for (let i = 0; i < importData.eventHistory.length; i += 100) {
                const chunk = importData.eventHistory.slice(i, i + 100);
                results.push(...chunk);
                await new Promise(resolve => setTimeout(resolve, 0));
            }
            importData.eventHistory = results;
        }
       
        data = {
            people: JSON.parse(JSON.stringify(importData.people || [])),
            bills: JSON.parse(JSON.stringify(importData.bills || [])),
            currency: importData.currency || 'USD',
            darkMode: Boolean(importData.darkMode),
            weightedBills: Boolean(importData.weightedBills),
            paycheckHistory: importData.paycheckHistory || [],
            billHistory: JSON.parse(JSON.stringify(importData.billHistory || [])),
            eventHistory: importData.eventHistory || [],
            billPayments: importData.billPayments || [],
            lastProcessedDate: importData.lastProcessedDate || null,
            peopleIncomeSettings: JSON.parse(JSON.stringify(importData.peopleIncomeSettings || {})),
            uiPreferences: JSON.parse(JSON.stringify(importData.uiPreferences || {})),
            dataVersion: importData.dataVersion || "1.0",
            billHistoryId: importData.billHistoryId || 1
        };
       
        nextPersonId = data.people.length > 0 ? Math.max(...data.people.map(p => p.id)) + 1 : 1;
        nextBillId = data.bills.length > 0 ? Math.max(...data.bills.map(b => b.id)) + 1 : 1;
        nextEventId = data.eventHistory.length > 0 ? Math.max(...data.eventHistory.map(e => e.id)) + 1 : 1;
        nextPaycheckId = data.paycheckHistory.length > 0 ? Math.max(...data.paycheckHistory.map(p => p.id)) + 1 : 1;
       
        data.nextPersonId = nextPersonId;
        data.nextBillId = nextBillId;
        data.nextIncomeId = nextIncomeId;
        data.nextEventId = nextEventId;
        data.nextPaycheckId = nextPaycheckId;
       
        processImportBills();
        processImportIncome();
       
        markAsPostImport();
       
        return true;
    } catch (error) {
        console.error("Error processing import data:", error);
        isImporting = false;
        alert(`Import failed: ${error.message}`);
        return false;
    }
}

function createCleanExportData() {
   let exportData;
   
   if (isPostImport && Object.keys(importBaseline).length > 0) {
       exportData = mergeImportBaselineWithChanges();
       if (exportData) {
           validateExportData(exportData);
           return exportData;
       }
   }

   exportData = {
       people: JSON.parse(JSON.stringify(data.people)),
       bills: JSON.parse(JSON.stringify(data.bills)),
       billPayments: JSON.parse(JSON.stringify(data.billPayments)),
       billPaymentId: data.billPaymentId || 1,
       uiActionHistory: JSON.parse(JSON.stringify(data.uiActionHistory || [])),
       sessionId: data.sessionId,
       currency: data.currency,
       darkMode: data.darkMode,
       weightedBills: data.weightedBills,
       paycheckHistory: JSON.parse(JSON.stringify(data.paycheckHistory)),
       billHistory: JSON.parse(JSON.stringify(data.billHistory || [])),
       eventHistory: JSON.parse(JSON.stringify(data.eventHistory)),
       lastProcessedDate: data.lastProcessedDate,
       peopleIncomeSettings: JSON.parse(JSON.stringify(data.peopleIncomeSettings)),
       uiPreferences: JSON.parse(JSON.stringify(data.uiPreferences || {})),
       dataVersion: data.dataVersion || "1.0",
       lastExportDate: new Date().toISOString(),
       billHistoryId: data.billHistoryId || 1,
       nextPersonId: nextPersonId,
       nextBillId: nextBillId,
       nextIncomeId: nextIncomeId,
       nextEventId: nextEventId,
       nextPaycheckId: nextPaycheckId
   };
   
   validateExportData(exportData);
   return exportData;
}

function showImportExportModal() {
    let modal = $('editModal');
    let modalContent;
   
    if (!modal) {
        const modalData = createModal();
        modal = modalData.modal;
        modalContent = modalData.modalContent;
    } else {
        modalContent = $('modalContent');
    }
   
    modalContent.innerHTML = `
        <h3 style="margin-bottom:10px;color:${document.body.classList.contains('dark-mode') ? '#fff' : '#000'};text-align:center;">SAVE/IMPORT</h3>
       
        <p style="text-align:center;margin-bottom:25px;padding:10px;background-color:${document.body.classList.contains('dark-mode') ? '#333' : '#f5f5f5'};border-radius:5px;font-size:14px;color:${document.body.classList.contains('dark-mode') ? '#ff9' : '#800'};">
            For security, your data is only stored on your device unless you export it.  Remember to share/backup your budget to a safe place after making changes. Make sure only one person edits the budget at a time and re-shares the latest version with you.
        </p>
       
        <div style="display:flex;flex-direction:column;gap:20px;margin-bottom:20px;">
            <div>
                <button id="importBtn" style="width:100%;height:60px;font-size:16px;font-weight:bold;">IMPORT</button>
                <p style="margin-top:5px;font-size:13px;color:${document.body.classList.contains('dark-mode') ? '#ccc' : '#666'};">
                    Load your previously exported .txt file to view your budget.
                </p>
            </div>
           
            <div>
                <button id="exportBtn" style="width:100%;height:60px;font-size:16px;font-weight:bold;">EXPORT</button>
                <p style="margin-top:5px;font-size:13px;color:${document.body.classList.contains('dark-mode') ? '#ccc' : '#666'};">
                    Create a unique encoded .txt file with your budget data. Save to your device, or to a cloud service to access from any device or to share with others.
                </p>
            </div>
        </div>
       
        <div style="margin-top:20px;text-align:center;">
            <button id="closeModalBtn" style="background:#666;width:150px;">Close</button>
        </div>
    `;
   
    $('importBtn').addEventListener('click', () => {
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = '.txt';
        fileInput.style.display = 'none';
        document.body.appendChild(fileInput);
       
        fileInput.click();
       
        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) {
                document.body.removeChild(fileInput);
                return;
            }
           
            if (!confirm('Importing will replace all current data with the data from the selected file. Continue?')) {
                document.body.removeChild(fileInput);
                return;
            }
           
            isImporting = true;
           
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const fileContent = e.target.result;
                    const importSuccess = processImportData(fileContent);
                   
                    if (!importSuccess) {
                        alert('Failed to import data. The file may be invalid or corrupted.');
                        document.body.removeChild(fileInput);
                        isImporting = false;
                        return;
                    }
                   
                    document.querySelectorAll('.tab[data-person-id]').forEach(tab => tab.remove());
                    document.querySelectorAll('.tab-content[id^="person-"]').forEach(content => content.remove());
                   
                    if (data.darkMode) {
                        document.body.classList.add('dark-mode');
                    } else {
                        document.body.classList.remove('dark-mode');
                    }
                   
                    $('currencySelect').value = data.currency;
                    $('weightedBillsSidebar').checked = data.weightedBills;
                   
                    data.people.forEach(person => createPersonTab(person));
                    attachPersonEventListeners();
                   
                    updateGreeting();
                    updateBillPayerOptions();
                    updateBillsList();
                    updateHistoryDisplay();
                    updateOverview();
                    toggleBillTypeVisibility();
                    updateTabsVisibility();
                   
                    setTimeout(() => {
                        hideModal();
                        showTab('overview');
                    }, 600);
                   
                } catch (e) {
                    isImporting = false;
                    console.error('Import error:', e);
                    alert('Failed to import data. The file may be invalid or corrupted.');
                }
               
                document.body.removeChild(fileInput);
            };
           
            reader.readAsText(file);
        });
    });
   
    $('exportBtn').addEventListener('click', () => {
        const exportData = createCleanExportData();
        const exportString = btoa(JSON.stringify(exportData));
        const blob = new Blob([exportString], { type: 'text/plain' });
       
        if ('showSaveFilePicker' in window) {
            async function saveWithFilePicker() {
                try {
                    const handle = await window.showSaveFilePicker({
                        suggestedName: 'budget_data.txt',
                        types: [{
                            description: 'Text Files',
                            accept: { 'text/plain': ['.txt'] }
                        }]
                    });
                   
                    const writable = await handle.createWritable();
                    await writable.write(exportString);
                    await writable.close();
                   
                    alert('File exported successfully!');
                    saveDataToLocalStorage();
                } catch (err) {
                    if (err.name !== 'AbortError') {
                        console.error('Error saving file:', err);
                        alert('Error saving file. Please try again.');
                    }
                }
            }
           
            saveWithFilePicker();
        } else {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'budget_data.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            alert('File exported successfully!');
           
            saveDataToLocalStorage();
        }
    });
   
    $('closeModalBtn').addEventListener('click', hideModal);
   
    showModal();
}

function calculateMonthlyBudget(person) {
   const today = new Date();
   const currentYear = today.getFullYear();
   const currentMonth = today.getMonth();
   const currentMonthStr = `${currentYear}-${String(currentMonth + 1).padStart(2, '0')}`;
   
   const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
   let totalMonthIncome = 0;
   
   for (let day = 1; day <= daysInMonth; day++) {
       const dayDate = new Date(currentYear, currentMonth, day);
       const dayEvents = getDayEvents(dayDate);
       
       const paydayItems = getPaydayItemsFromEvents(dayEvents);
       
       const personPayday = paydayItems.find(payday => {
           return payday.name && payday.name.includes(person.name);
       });
       
       if (personPayday) {
           totalMonthIncome += personPayday.amount;
       }
   }
   
   if (totalMonthIncome > 0) {
       return totalMonthIncome;
   }
   
   const currentMonthIncome = data.paycheckHistory.filter(p =>
       p.personId === person.id &&
       p.date.startsWith(currentMonthStr)
   );
   
   const paycheckTotal = currentMonthIncome.reduce((sum, income) => sum + income.amount, 0);
   
   if (paycheckTotal > 0) {
       return paycheckTotal;
   }
   
   if (person.income && person.frequency && person.paymentDate) {
       if (person.frequency === 'biweekly') {
           const paymentDate = new Date(getDateString(person.paymentDate));
           let paydayCount = 0;
           let checkDate = new Date(paymentDate);
           
           while (checkDate.getFullYear() <= currentYear) {
               if (checkDate.getFullYear() === currentYear && checkDate.getMonth() === currentMonth) {
                   paydayCount++;
               } else if (checkDate.getFullYear() === currentYear && checkDate.getMonth() > currentMonth) {
                   break;
               }
               checkDate.setDate(checkDate.getDate() + 14);
           }
           
           return person.income * paydayCount;
       } else {
           return frequencyToMonthly(person.income, person.frequency);
       }
   }
   
   return 0;
}

function updateOverview() {
   const today = new Date();
   const currentYear = today.getFullYear();
   const currentMonth = today.getMonth();
   
   const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
   let billsTotal = 0;
   let incomeTotal = 0;
   
   for (let day = 1; day <= daysInMonth; day++) {
       const dayDate = new Date(currentYear, currentMonth, day);
       const dayEvents = getDayEvents(dayDate);
       
       const billItems = getBillItemsFromEvents(dayEvents);
       billItems.forEach(bill => {
           billsTotal += bill.amount;
       });
       
       const oneOffItems = getOneOffItemsFromEvents(dayEvents);
       oneOffItems.forEach(oneOff => {
           billsTotal += oneOff.amount;
       });
       
       const paydayItems = getPaydayItemsFromEvents(dayEvents);
       paydayItems.forEach(payday => {
           incomeTotal += payday.amount;
       });
       
       const bonusItems = getBonusItemsFromEvents(dayEvents);
       bonusItems.forEach(bonus => {
           incomeTotal += bonus.amount;
       });
   }
   
   const totalMonthlySavings = data.people.reduce((sum, person) => sum + (person.savings || 0), 0);
   const totalMonthlyExpenses = data.people.reduce((sum, person) => sum + (person.expenses || 0), 0);
   
   const leftover = incomeTotal - billsTotal - totalMonthlySavings - totalMonthlyExpenses;
   
   $('totalIncome').textContent = formatCurrency(incomeTotal);
   $('totalBills').textContent = formatCurrency(billsTotal);
   $('totalSavings').textContent = formatCurrency(totalMonthlySavings);
   $('totalLeftover').textContent = formatCurrency(leftover);
   
   $('billsPercentage').textContent = incomeTotal ?
       `${((billsTotal / incomeTotal) * 100).toFixed(1)}%` : '0%';
   $('savingsPercentage').textContent = incomeTotal ?
       `${((totalMonthlySavings / incomeTotal) * 100).toFixed(1)}%` : '0%';
   $('leftoverPercentage').textContent = incomeTotal ?
       `${((leftover / incomeTotal) * 100).toFixed(1)}%` : '0%';
   
   updatePeopleOverview();
   updateDebtOverview();
   updateOneOffOverview();
   updateTransfersOverview();
   resetCalendarToCurrentMonth();
   data.people.forEach(p => updatePersonOverview(p.id));
}

function getPaydayItemsFromEvents(dayEvents) {
    if (!dayEvents.paydayText) return [];
   
    const paydayItems = [];
   
    const regex = /<span[^>]*>([^<]*?Payday:[^<]*?)(\d[\d,.]+)<\/span>/g;
    let match;
    let matches = [...dayEvents.paydayText.matchAll(regex)];
   
    if (matches.length > 0) {
        matches.forEach(match => {
            if (match[1]) {
                const fullText = match[1].trim();
                const parts = fullText.split(':');
               
                if (parts.length >= 1) {
                    const name = parts[0].trim();
                    const amountStr = match[2].trim();
                    const amount = parseFloat(amountStr.replace(/[£$€¥,]/g, '')) || 0;
                   
                    paydayItems.push({ name, amount });
                }
            }
        });
    }
   
    if (paydayItems.length === 0) {
        const plainText = dayEvents.paydayText.replace(/<[^>]*>/g, ' ');
        const paydayMatches = plainText.match(/([^\s:]+(?:\s+[^\s:]+)*?)\s*Payday\s*:\s*([\d,.]+)/g) || [];
       
        paydayMatches.forEach(matchText => {
            const parts = matchText.split(':');
            if (parts.length >= 2) {
                const nameWithPayday = parts[0].trim();
                const name = nameWithPayday.replace(/\s+Payday$/, '');
                const amountStr = parts[1].trim();
                const amount = parseFloat(amountStr.replace(/[£$€¥,]/g, '')) || 0;
               
                paydayItems.push({ name, amount });
            }
        });
    }
   
    if (paydayItems.length === 0) {
        const paydayNameRegex = /<span class="payday-name"[^>]*>(.*?)<\/span>/g;
        const paydayNameMatches = [...dayEvents.paydayText.matchAll(paydayNameRegex)];
       
        paydayNameMatches.forEach(match => {
            const content = match[1];
            const nameMatch = content.match(/^(.*?)\s+Payday:\s*([\d,.]+)/);
           
            if (nameMatch) {
                const name = nameMatch[1].trim();
                const amountStr = nameMatch[2].trim();
                const amount = parseFloat(amountStr.replace(/[£$€¥,]/g, '')) || 0;
               
                paydayItems.push({ name, amount });
            }
        });
    }
   
    return paydayItems;
}

function getBonusItemsFromEvents(dayEvents) {
   if (!dayEvents.bonusText) return [];
   
   const bonusItems = [];
   const bonusTextWithoutHTML = dayEvents.bonusText.replace(/<[^>]*>/g, '|');
   const bonusParts = bonusTextWithoutHTML.split('|').filter(part => part.trim() && part.includes(':'));
   
   bonusParts.forEach(part => {
       const nameAmountParts = part.split(':');
       if (nameAmountParts.length === 2) {
           const name = nameAmountParts[0].trim();
           const amountStr = nameAmountParts[1].trim();
           const amount = parseFloat(amountStr.replace(/[£$€¥,]/g, '')) || 0;
           
           bonusItems.push({ name, amount });
       }
   });
   
   return bonusItems;
}

function isMonthlyBillDue(bill, month, year) {
   if (bill.frequency === 'monthly') {
       return true;
   } else if (bill.frequency === 'quarterly') {
       const billStartMonth = bill.startMonth || 1;
       const quarterMonths = [];
       for (let k = 0; k < 4; k++) {
           quarterMonths.push(((billStartMonth - 1 + k * 3) % 12));
       }
       return quarterMonths.includes(month);
   } else if (bill.frequency === 'yearly' && bill.month) {
       return month === bill.month - 1;
   }
   
   return false;
}

function calculateIncomeRatio() {
    const totalIncome = data.people.reduce((sum, p) => sum + calculateMonthlyBudget(p), 0);
    return data.people.map(p => ({
        id: p.id,
        ratio: totalIncome ? calculateMonthlyBudget(p) / totalIncome : 1 / data.people.length
    }));
}

function calculateWeightedShare(billAmount, personId, useWeighted = false) {
    if (!useWeighted || data.people.length <= 1) {
        return billAmount / data.people.length;
    }
   
    const incomeRatios = calculateIncomeRatio();
    const personRatio = incomeRatios.find(r => r.id === personId)?.ratio || (1 / data.people.length);
    return billAmount * personRatio;
}

function calculateSetAsideAmount(billAmount, frequency, isDebt, interestRate, currentDebtBalance) {
    if (frequency === 'monthly') {
        return 0;
    }
   
    const periods = frequency === 'quarterly' ? 3 : 12;
   
    if (isDebt && interestRate && interestRate > 0 && currentDebtBalance > 0) {
        const monthlyRate = interestRate / 100 / 12;
        let debtGrowth = 0;
        let tempBalance = currentDebtBalance;
       
        for (let i = 0; i < periods; i++) {
            debtGrowth += tempBalance * monthlyRate;
            tempBalance += (tempBalance * monthlyRate);
        }
       
        const adjustedPayment = billAmount + (debtGrowth / periods);
        return adjustedPayment / periods;
    }
   
    return billAmount / periods;
}

function updatePersonIncome(personId) {
   const person = data.people.find(p => p.id === personId);
   if (!person) return;
  
   const oldIncome = person.income || 0;
   const oldFrequency = person.frequency;
   const oldPaymentDate = person.paymentDate;
   const oldEmployer = person.employer || '';
  
   const income = parseFloat($(`income-${personId}`).value) || 0;
   const frequency = $(`frequency-${personId}`).value;
   const paymentDate = $(`paymentDate-${personId}`).value;
   const employer = $(`employer-${personId}`).value.trim();
   
   const today = getDateString();
   const isFutureDate = paymentDate && getDateString(paymentDate) > today;
   const wasInPast = oldPaymentDate && getDateString(oldPaymentDate) <= today;
   
   const hasDateChange = oldPaymentDate !== paymentDate && oldPaymentDate && paymentDate;
   const hasFrequencyChange = oldFrequency !== frequency && oldFrequency && frequency;
   const hasAmountChange = oldIncome !== income && oldIncome && income;
   
   if (hasDateChange && wasInPast && isFutureDate && oldPaymentDate && paymentDate) {
       const oldDate = new Date(getDateString(oldPaymentDate));
       const newDate = new Date(getDateString(paymentDate));
       const currentMonth = today.substring(0, 7);
       
       if (oldDate.toISOString().substring(0, 7) === currentMonth && 
           newDate.toISOString().substring(0, 7) === currentMonth) {
           
           if (frequency === 'biweekly') {
               const currentMonthPaychecks = data.paycheckHistory.filter(p => 
                   p.personId === personId && 
                   p.date.startsWith(currentMonth) && 
                   p.isAutoLogged && 
                   p.type === 'salary'
               );
               
               currentMonthPaychecks.forEach(paycheck => {
                   const paycheckDate = new Date(paycheck.date);
                   const daysDiff = Math.floor((paycheckDate - oldDate) / (1000 * 60 * 60 * 24));
                   
                   if (daysDiff >= 0 && daysDiff % 14 === 0) {
                       data.paycheckHistory = data.paycheckHistory.filter(p => p.id !== paycheck.id);
                   }
               });
               
           } else {
               data.paycheckHistory = data.paycheckHistory.filter(p => 
                   !(p.personId === personId && 
                     p.date === getDateString(oldPaymentDate) && 
                     p.isAutoLogged && 
                     p.type === 'salary')
               );
           }
           
           data.eventHistory.push({
               id: nextEventId++,
               date: today,
               event: 'Paycheck(s) Removed',
               description: `Removed auto-logged ${frequency} paycheck(s) for ${person.name} due to date change to future date`
           });
       }
   }
  
   if (!isFutureDate && (hasDateChange || hasFrequencyChange)) {
       const newStartDate = getDateString(paymentDate);
      
       const allPaychecks = data.paycheckHistory.filter(p =>
           p.personId === personId &&
           p.type === 'salary' &&
           p.isAutoLogged
       );
      
       const paychecksToRemove = allPaychecks.filter(p => {
           return p.date >= newStartDate;
       });
      
       if (paychecksToRemove.length > 0) {
           data.paycheckHistory = data.paycheckHistory.filter(p =>
               !(p.personId === personId &&
                 p.type === 'salary' &&
                 p.isAutoLogged &&
                 p.date >= newStartDate)
           );
       }
      
       generateHistoricalPayments(personId, person, new Date(newStartDate), income, frequency, employer);
      
   } else if (!isFutureDate && hasAmountChange && !hasDateChange && !hasFrequencyChange) {
       const startDate = getDateString(paymentDate);
      
       const paychecksToUpdate = data.paycheckHistory.filter(p =>
           p.personId === personId &&
           p.type === 'salary' &&
           p.isAutoLogged &&
           !p.isAdditional &&
           p.date >= startDate
       );
      
       paychecksToUpdate.forEach(paycheck => {
           paycheck.amount = income;
           paycheck.description = employer ? `${frequency} salary - ${employer}` : `${frequency} salary`;
           if (employer) paycheck.employer = employer;
       });
      
   } else if (!oldPaymentDate && paymentDate && !isFutureDate) {
       generateHistoricalPayments(personId, person, new Date(getDateString(paymentDate)), income, frequency, employer);
   }
  
   person.income = income;
   person.frequency = frequency;
   person.paymentDate = paymentDate;
   person.employer = employer;
  
   if (!data.peopleIncomeSettings[personId]) {
       data.peopleIncomeSettings[personId] = {};
   }
   data.peopleIncomeSettings[personId] = {
       lastAmount: income,
       lastFrequency: frequency,
       lastPaymentDate: paymentDate,
       nextPaymentDate: paymentDate ? getDateString(getNextPaymentDate(new Date(getDateString(paymentDate)), frequency)) : null,
       currentAmount: income
   };
  
   saveDataToLocalStorage();
   updateGreeting();
   updateBillPayerOptions();
   updateHistoryDisplay();
   updateOverview();
   updatePersonOverview(personId);
   ensureDataConsistency();
}

function rebuildScheduleFromDate(personId, newStartDate, income, frequency, employer) {
    const person = data.people.find(p => p.id === personId);
    if (!person) return false;
   
    const startDate = new Date(newStartDate);
    const today = new Date();
   
    if (startDate > today) {
        alert('Cannot set income start date in the future. Please select today or an earlier date.');
        return false;
    }
   
    const allPaychecks = data.paycheckHistory.filter(p =>
        p.personId === personId &&
        p.type === 'salary' &&
        p.isAutoLogged
    );
   
    const paychecksToKeep = allPaychecks.filter(p => new Date(p.date) < startDate);
    const paychecksToRemove = allPaychecks.filter(p => new Date(p.date) >= startDate);
   
    if (paychecksToRemove.length > 0) {
        data.paycheckHistory = data.paycheckHistory.filter(p =>
            !(p.personId === personId &&
              p.type === 'salary' &&
              p.isAutoLogged &&
              new Date(p.date) >= startDate)
        );
       
        data.eventHistory.push({
            id: nextEventId++,
            date: new Date().toISOString().split('T')[0],
            event: 'Schedule Rebuilt',
            description: `Removed ${paychecksToRemove.length} auto-logged paychecks from ${startDate.toISOString().split('T')[0]} forward. Kept ${paychecksToKeep.length} earlier paychecks.`
        });
    }
   
    generateHistoricalPayments(personId, person, startDate, income, frequency, employer);
   
    if (!data.peopleIncomeSettings[personId]) {
        data.peopleIncomeSettings[personId] = {};
    }
   
    data.peopleIncomeSettings[personId] = {
        ...data.peopleIncomeSettings[personId],
        lastAmount: income,
        lastFrequency: frequency,
        lastPaymentDate: newStartDate,
        nextPaymentDate: getNextPaymentDate(startDate, frequency).toISOString().split('T')[0],
        currentAmount: income,
        lastRebuildDate: new Date().toISOString().split('T')[0]
    };
   
    return true;
}

function cleanupFuturePaychecks(personId) {
    const today = new Date();
   
    const removedPaychecks = data.paycheckHistory.filter(paycheck =>
        paycheck.personId === personId &&
        paycheck.isAutoLogged &&
        new Date(paycheck.date) > today
    );
   
    if (removedPaychecks.length > 0) {
        data.paycheckHistory = data.paycheckHistory.filter(paycheck =>
            paycheck.personId !== personId ||
            !paycheck.isAutoLogged ||
            new Date(paycheck.date) <= today
        );
       
        data.eventHistory.push({
            id: nextEventId++,
            date: new Date().toISOString().split('T')[0],
            event: 'Future Paychecks Removed',
            description: `Removed ${removedPaychecks.length} future auto-logged paychecks due to income setting changes`
        });
    }
}

function cleanupExistingPaychecks(personId) {
    const removedPaychecks = data.paycheckHistory.filter(paycheck =>
        paycheck.personId === personId &&
        (paycheck.isAutoLogged || paycheck.isHistorical)
    );
   
    if (removedPaychecks.length > 0) {
        data.paycheckHistory = data.paycheckHistory.filter(paycheck =>
            paycheck.personId !== personId ||
            (!paycheck.isAutoLogged && !paycheck.isHistorical)
        );
       
        data.eventHistory.push({
            id: nextEventId++,
            date: new Date().toISOString().split('T')[0],
            event: 'Historical Paychecks Removed',
            description: `Removed ${removedPaychecks.length} historical/auto-logged paychecks due to income setting changes`
        });
    }
}

function generateHistoricalPayments(personId, person, startDate, income, frequency, employer) {
    const today = getDateString();
    const startDateStr = getDateString(startDate);
    let checkDate = new Date(startDateStr);
   
    const loggedDates = [];
   
    if (startDateStr > today) return;
   
    if (frequency === 'weekly') {
        while (getDateString(checkDate) <= today) {
            const paymentDate = getDateString(checkDate);
            const monthApplied = `${checkDate.getFullYear()}-${String(checkDate.getMonth() + 1).padStart(2, '0')}`;
           
            const existingPayment = data.paycheckHistory.find(p =>
                p.personId === personId &&
                p.date === paymentDate &&
                p.type === 'salary'
            );
           
            if (!existingPayment) {
                data.paycheckHistory.push({
                    id: nextPaycheckId++,
                    personId: personId,
                    personName: person.name,
                    type: 'salary',
                    amount: income,
                    date: paymentDate,
                    description: employer || '',
                    employer: employer,
                    frequency: frequency,
                    isAutoLogged: true,
                    isHistorical: paymentDate !== today,
                    monthApplied: monthApplied
                });
               
                loggedDates.push(paymentDate);
            }
           
            checkDate.setDate(checkDate.getDate() + 7);
        }
    } else if (frequency === 'biweekly') {
        while (getDateString(checkDate) <= today) {
            const paymentDate = getDateString(checkDate);
            const monthApplied = `${checkDate.getFullYear()}-${String(checkDate.getMonth() + 1).padStart(2, '0')}`;
           
            const existingPayment = data.paycheckHistory.find(p =>
                p.personId === personId &&
                p.date === paymentDate &&
                p.type === 'salary'
            );
           
            if (!existingPayment) {
                data.paycheckHistory.push({
                    id: nextPaycheckId++,
                    personId: personId,
                    personName: person.name,
                    type: 'salary',
                    amount: income,
                    date: paymentDate,
                    description: employer || '',
                    employer: employer,
                    frequency: frequency,
                    isAutoLogged: true,
                    isHistorical: paymentDate !== today,
                    monthApplied: monthApplied
                });
               
                loggedDates.push(paymentDate);
            }
           
            checkDate.setDate(checkDate.getDate() + 14);
        }
    } else if (frequency === 'monthly') {
        const paymentDay = checkDate.getDate();
        checkDate = new Date(checkDate.getFullYear(), checkDate.getMonth(), paymentDay);
       
        while (getDateString(checkDate) <= today) {
            const paymentDate = getDateString(checkDate);
            const monthApplied = `${checkDate.getFullYear()}-${String(checkDate.getMonth() + 1).padStart(2, '0')}`;
           
            const existingPayment = data.paycheckHistory.find(p =>
                p.personId === personId &&
                p.date === paymentDate &&
                p.type === 'salary'
            );
           
            if (!existingPayment) {
                data.paycheckHistory.push({
                    id: nextPaycheckId++,
                    personId: personId,
                    personName: person.name,
                    type: 'salary',
                    amount: income,
                    date: paymentDate,
                    description: employer || '',
                    employer: employer,
                    frequency: frequency,
                    isAutoLogged: true,
                    isHistorical: paymentDate !== today,
                    monthApplied: monthApplied
                });
               
                loggedDates.push(paymentDate);
            }
           
            const nextYear = checkDate.getMonth() === 11 ? checkDate.getFullYear() + 1 : checkDate.getFullYear();
            const nextMonth = checkDate.getMonth() === 11 ? 0 : checkDate.getMonth() + 1;
            const daysInNextMonth = new Date(nextYear, nextMonth + 1, 0).getDate();
            const actualDay = paymentDay > daysInNextMonth ? daysInNextMonth : paymentDay;
           
            checkDate = new Date(nextYear, nextMonth, actualDay);
        }
    } else if (frequency === 'quarterly') {
        const paymentDay = checkDate.getDate();
        checkDate = new Date(checkDate.getFullYear(), checkDate.getMonth(), paymentDay);
       
        while (getDateString(checkDate) <= today) {
            const paymentDate = getDateString(checkDate);
            const monthApplied = `${checkDate.getFullYear()}-${String(checkDate.getMonth() + 1).padStart(2, '0')}`;
           
            const existingPayment = data.paycheckHistory.find(p =>
                p.personId === personId &&
                p.date === paymentDate &&
                p.type === 'salary'
            );
           
            if (!existingPayment) {
                data.paycheckHistory.push({
                    id: nextPaycheckId++,
                    personId: personId,
                    personName: person.name,
                    type: 'salary',
                    amount: income,
                    date: paymentDate,
                    description: employer || '',
                    employer: employer,
                    frequency: frequency,
                    isAutoLogged: true,
                    isHistorical: paymentDate !== today,
                    monthApplied: monthApplied
                });
               
                loggedDates.push(paymentDate);
            }
           
            const nextMonth = checkDate.getMonth() + 3;
            const nextYear = nextMonth >= 12 ? checkDate.getFullYear() + 1 : checkDate.getFullYear();
            const actualNextMonth = nextMonth >= 12 ? nextMonth - 12 : nextMonth;
            const daysInTargetMonth = new Date(nextYear, actualNextMonth + 1, 0).getDate();
            const actualDay = paymentDay > daysInTargetMonth ? daysInTargetMonth : paymentDay;
           
            checkDate = new Date(nextYear, actualNextMonth, actualDay);
        }
    } else if (frequency === 'yearly') {
        const paymentDay = checkDate.getDate();
        const paymentMonth = checkDate.getMonth();
        checkDate = new Date(checkDate.getFullYear(), paymentMonth, paymentDay);
       
        while (getDateString(checkDate) <= today) {
            const paymentDate = getDateString(checkDate);
            const monthApplied = `${checkDate.getFullYear()}-${String(checkDate.getMonth() + 1).padStart(2, '0')}`;
           
            const existingPayment = data.paycheckHistory.find(p =>
                p.personId === personId &&
                p.date === paymentDate &&
                p.type === 'salary'
            );
           
            if (!existingPayment) {
                data.paycheckHistory.push({
                    id: nextPaycheckId++,
                    personId: personId,
                    personName: person.name,
                    type: 'salary',
                    amount: income,
                    date: paymentDate,
                    description: employer || '',
                    employer: employer,
                    frequency: frequency,
                    isAutoLogged: true,
                    isHistorical: paymentDate !== today,
                    monthApplied: monthApplied
                });
               
                loggedDates.push(paymentDate);
            }
           
            const nextYear = checkDate.getFullYear() + 1;
            const daysInTargetMonth = new Date(nextYear, paymentMonth + 1, 0).getDate();
            const actualDay = paymentDay > daysInTargetMonth ? daysInTargetMonth : paymentDay;
           
            checkDate = new Date(nextYear, paymentMonth, actualDay);
        }
    }
}

function shouldLogIncomeForCurrentMonth(paymentDate, frequency, today) {
    const currentMonth = today.getMonth();
    const currentYear = today.getFullYear();
    const payMonth = paymentDate.getMonth();
    const payYear = paymentDate.getFullYear();
   
    if (frequency === 'monthly') {
        return payMonth === currentMonth && payYear === currentYear;
    } else if (frequency === 'quarterly') {
        const monthsDiff = (currentYear - payYear) * 12 + (currentMonth - payMonth);
        return monthsDiff >= 0 && monthsDiff % 3 === 0;
    } else if (frequency === 'yearly') {
        return payMonth === currentMonth && payYear <= currentYear;
    } else if (frequency === 'biweekly') {
        return paymentDate <= today && payMonth === currentMonth && payYear === currentYear;
    }
   
    return false;
}

function updateBiweeklyPaydayChanges(personId, oldDate, newDate, today) {
    const currentMonth = today.getMonth();
    const currentYear = today.getFullYear();
   
    data.eventHistory.push({
        id: nextEventId++,
        date: new Date().toISOString().split('T')[0],
        event: 'Biweekly Payday Changed',
        description: `Changed biweekly payday schedule. Future paydays will be every 14 days starting from ${newDate.toISOString().split('T')[0]}`
    });
   
    if (!data.peopleIncomeSettings[personId]) {
        data.peopleIncomeSettings[personId] = {};
    }
   
    data.peopleIncomeSettings[personId] = {
        ...data.peopleIncomeSettings[personId],
        lastPaymentDate: newDate.toISOString().split('T')[0],
        nextPaymentDate: getNextPaymentDate(newDate, 'biweekly').toISOString().split('T')[0]
    };
}

function updateRegularPaydayChanges(personId, oldDate, newDate, frequency, today) {
    const currentMonth = today.getMonth();
    const currentYear = today.getFullYear();
    const todayDate = today.getDate();
   
    const oldDay = oldDate.getDate();
    const newDay = newDate.getDate();
   
    const oldPaydayThisMonth = new Date(currentYear, currentMonth, oldDay);
    const newPaydayThisMonth = new Date(currentYear, currentMonth, newDay);
   
    if (oldDay <= todayDate) {
        const existingPaycheck = data.paycheckHistory.find(p =>
            p.personId === personId &&
            p.date === oldPaydayThisMonth.toISOString().split('T')[0] &&
            p.type === 'salary'
        );
       
        if (existingPaycheck) {
            existingPaycheck.date = newPaydayThisMonth.toISOString().split('T')[0];
            existingPaycheck.description += ' (date updated)';
           
            data.eventHistory.push({
                id: nextEventId++,
                date: new Date().toISOString().split('T')[0],
                event: 'Payday Date Updated',
                description: `Updated payday date from ${oldDay}th to ${newDay}th for ${existingPaycheck.personName} in current month`
            });
        }
    }
   
    if (!data.peopleIncomeSettings[personId]) {
        data.peopleIncomeSettings[personId] = {};
    }
   
    data.peopleIncomeSettings[personId] = {
        ...data.peopleIncomeSettings[personId],
        lastPaymentDate: newDate.toISOString().split('T')[0],
        nextPaymentDate: getNextPaymentDate(newDate, frequency).toISOString().split('T')[0]
    };
}

function updateBiweeklyPaydayChanges(personId, oldDate, newDate, today) {
    const currentMonth = today.getMonth();
    const currentYear = today.getFullYear();
    const todayDate = today.getDate();
   
    const monthStart = new Date(currentYear, currentMonth, 1);
    const monthEnd = new Date(currentYear, currentMonth + 1, 0);
   
    const oldPaydays = [];
    let checkDate = new Date(oldDate);
   
    while (checkDate.getFullYear() < currentYear ||
           (checkDate.getFullYear() === currentYear && checkDate.getMonth() <= currentMonth)) {
       
        if (checkDate.getMonth() === currentMonth && checkDate.getFullYear() === currentYear) {
            oldPaydays.push(new Date(checkDate));
        }
       
        checkDate.setDate(checkDate.getDate() + 14);
       
        if (checkDate.getFullYear() > currentYear + 1) break;
    }
   
    oldPaydays.sort((a, b) => a.getDate() - b.getDate());
   
    const passedPaydays = oldPaydays.filter(date => date.getDate() <= todayDate);
   
    if (passedPaydays.length > 0) {
        const latestPassedPayday = passedPaydays[passedPaydays.length - 1];
       
        const existingPaycheck = data.paycheckHistory.find(p =>
            p.personId === personId &&
            p.date === latestPassedPayday.toISOString().split('T')[0] &&
            p.type === 'salary'
        );
       
        if (existingPaycheck) {
            const daysDifference = latestPassedPayday.getDate() - oldDate.getDate();
            const biweeklyPeriods = Math.floor(daysDifference / 14);
           
            const newPaydayDate = new Date(newDate);
            newPaydayDate.setDate(newDate.getDate() + (biweeklyPeriods * 14));
           
            if (newPaydayDate.getMonth() === currentMonth && newPaydayDate.getFullYear() === currentYear) {
                existingPaycheck.date = newPaydayDate.toISOString().split('T')[0];
                existingPaycheck.description += ' (date updated)';
               
                data.eventHistory.push({
                    id: nextEventId++,
                    date: new Date().toISOString().split('T')[0],
                    event: 'Biweekly Payday Date Updated',
                    description: `Updated biweekly payday from ${latestPassedPayday.getDate()}th to ${newPaydayDate.getDate()}th for ${existingPaycheck.personName}`
                });
            }
        }
    }
   
    if (!data.peopleIncomeSettings[personId]) {
        data.peopleIncomeSettings[personId] = {};
    }
   
    data.peopleIncomeSettings[personId] = {
        ...data.peopleIncomeSettings[personId],
        lastPaymentDate: newDate.toISOString().split('T')[0],
        nextPaymentDate: getNextPaymentDate(newDate, 'biweekly').toISOString().split('T')[0]
    };
}

function updatePaycheckDate(personId, oldDate, newDate) {
    const paycheck = data.paycheckHistory.find(p =>
        p.personId === personId &&
        p.date === oldDate &&
        p.type === 'salary'
    );
   
    if (paycheck) {
        paycheck.date = newDate;
        paycheck.description += ' (date updated)';
       
        data.eventHistory.push({
            id: nextEventId++,
            date: new Date().toISOString().split('T')[0],
            event: 'Payday Date Updated',
            description: `Updated payday date from ${oldDate} to ${newDate} for ${paycheck.personName}`
        });
    }
}

function getNextPaymentDate(currentDate, frequency) {
    const nextDate = new Date(currentDate.getTime());
   
    switch (frequency) {
        case 'weekly':
            nextDate.setDate(currentDate.getDate() + 7);
            break;
        case 'biweekly':
            nextDate.setDate(currentDate.getDate() + 14);
            break;
        case 'monthly':
            const currentDay = currentDate.getDate();
            const nextMonth = currentDate.getMonth() + 1;
            const nextYear = nextMonth > 11 ? currentDate.getFullYear() + 1 : currentDate.getFullYear();
            const actualNextMonth = nextMonth > 11 ? 0 : nextMonth;
           
            const daysInNextMonth = new Date(nextYear, actualNextMonth + 1, 0).getDate();
            const actualDay = currentDay > daysInNextMonth ? daysInNextMonth : currentDay;
           
            nextDate.setFullYear(nextYear);
            nextDate.setMonth(actualNextMonth);
            nextDate.setDate(actualDay);
            break;
        case 'quarterly':
            const currentDayQ = currentDate.getDate();
            const nextMonthQ = currentDate.getMonth() + 3;
            const nextYearQ = nextMonthQ > 11 ? currentDate.getFullYear() + 1 : currentDate.getFullYear();
            const actualNextMonthQ = nextMonthQ > 11 ? nextMonthQ - 12 : nextMonthQ;
           
            const daysInTargetMonthQ = new Date(nextYearQ, actualNextMonthQ + 1, 0).getDate();
            const actualDayQ = currentDayQ > daysInTargetMonthQ ? daysInTargetMonthQ : currentDayQ;
           
            nextDate.setFullYear(nextYearQ);
            nextDate.setMonth(actualNextMonthQ);
            nextDate.setDate(actualDayQ);
            break;
        case 'yearly':
            const currentDayY = currentDate.getDate();
            const currentMonthY = currentDate.getMonth();
            const nextYearY = currentDate.getFullYear() + 1;
           
            const daysInTargetMonthY = new Date(nextYearY, currentMonthY + 1, 0).getDate();
            const actualDayY = currentDayY > daysInTargetMonthY ? daysInTargetMonthY : currentDayY;
           
            nextDate.setFullYear(nextYearY);
            nextDate.setMonth(currentMonthY);
            nextDate.setDate(actualDayY);
            break;
    }
   
    return nextDate;
}

function updatePersonSavingsExpenses(personId) {
    const person = data.people.find(p => p.id === personId);
    if (!person) return;
   
    const oldSavings = person.savings || 0;
    const oldExpenses = person.expenses || 0;
   
    const savings = parseFloat($(`savings-${personId}`).value) || 0;
    const expenses = parseFloat($(`expenses-${personId}`).value) || 0;
   
    const today = new Date().toISOString().split('T')[0];
    const currentMonthYear = new Date().toISOString().substring(0, 7);
   
    if (oldSavings !== savings) {
        person.savings = savings;
       
        recordEvent('Savings Goal Changed', `${person.name}'s monthly savings goal changed from ${formatCurrency(oldSavings)} to ${formatCurrency(savings)}`);
       
        if (!person.savingsHistory) person.savingsHistory = [];
        person.savingsHistory.push({
            date: today,
            previousAmount: oldSavings,
            newAmount: savings,
            effectiveMonth: currentMonthYear
        });
    }
   
    if (oldExpenses !== expenses) {
        person.expenses = expenses;
       
        recordEvent('Expenses Goal Changed', `${person.name}'s monthly expenses goal changed from ${formatCurrency(oldExpenses)} to ${formatCurrency(expenses)}`);
       
        if (!person.expensesHistory) person.expensesHistory = [];
        person.expensesHistory.push({
            date: today,
            previousAmount: oldExpenses,
            newAmount: expenses,
            effectiveMonth: currentMonthYear
        });
    }
   
    saveDataToLocalStorage();
    updateOverview();
    updatePersonOverview(personId);
}

function deletePerson(personId) {
    if (!confirm(`Are you sure you want to delete this person and their associated data? This cannot be undone.`)) return;
   
    const person = data.people.find(p => p.id === personId);
    if (!person) return;
   
    if (data.bills.some(b => b.payer === person.id)) {
        alert('Cannot delete person with associated bills. Please reassign or delete their bills first.');
        return;
    }
   
    data.people = data.people.filter(p => p.id !== personId);
    data.paycheckHistory = data.paycheckHistory.filter(p => p.personId !== personId);
   
    recordEvent('Person Deleted', `Deleted ${person.name} from budget tracker`);
   
    saveDataToLocalStorage();
   
    const tab = document.querySelector(`button.tab[data-person-id="${personId}"]`);
    if (tab) tab.remove();
   
    const content = $(`person-${personId}`);
    if (content) content.remove();
   
    updateGreeting();
    updateBillPayerOptions();
    updateHistoryDisplay();
    updateOverview();
    toggleBillTypeVisibility();
    updateTabsVisibility();
   
    showTab('overview');
}

function addPaycheck(personId) {
    const person = data.people.find(p => p.id === personId);
    if (!person) return;
   
    const amount = parseFloat($(`paycheckAmount-${personId}`).value) || 0;
    const date = $(`paycheckDate-${personId}`).value;
    const employer = $(`paycheckEmployer-${personId}`).value.trim();
   
    if (!amount || !date) {
        alert('Please provide amount and date');
        return;
    }
   
    const selectedDate = getDateString(date);
    const today = getDateString();
    const currentMonthStart = getDateString(new Date(new Date().getFullYear(), new Date().getMonth(), 1));
    const currentMonthEnd = getDateString(new Date(new Date().getFullYear(), new Date().getMonth() + 1, 0));
   
    if (selectedDate > currentMonthEnd) {
        alert('Cannot add income for future months. You can only add income for past dates or the current month.');
        return;
    }
   
    const paymentDate = new Date(selectedDate);
    const monthApplied = `${paymentDate.getFullYear()}-${String(paymentDate.getMonth() + 1).padStart(2, '0')}`;
   
    const existingEntries = data.paycheckHistory.filter(p =>
        p.personId === personId &&
        p.date === selectedDate &&
        p.type === 'salary'
    );
   
    const paycheck = {
        id: nextPaycheckId++,
        personId: personId,
        personName: person.name,
        type: 'salary',
        amount: amount,
        date: selectedDate,
        description: employer || '',
        employer: employer,
        frequency: 'manual',
        isAutoLogged: false,
        monthApplied: monthApplied,
        isHistorical: selectedDate < currentMonthStart,
        isAdditional: existingEntries.length > 0
    };
   
    data.paycheckHistory.push(paycheck);
   
    $(`paycheckAmount-${personId}`).value = '';
    $(`paycheckDate-${personId}`).value = '';
    $(`paycheckEmployer-${personId}`).value = '';
   
    saveDataToLocalStorage();
    updateHistoryDisplay();
    updateOverview();
    updatePersonOverview(personId);
    ensureDataConsistency();
}

function addBonus(personId) {
   const person = data.people.find(p => p.id === personId);
   if (!person) return;
   
   const amount = parseFloat($(`bonusAmount-${personId}`).value) || 0;
   const date = $(`bonusDate-${personId}`).value;
   const employer = $(`bonusEmployer-${personId}`).value.trim();
   
   if (!amount || !date) {
       alert('Please provide amount and date');
       return;
   }
   
   const bonusDate = getDateString(date);
   const today = getDateString();
   const monthApplied = `${new Date(bonusDate).getFullYear()}-${String(new Date(bonusDate).getMonth() + 1).padStart(2, '0')}`;
   
   const bonus = {
       id: nextPaycheckId++,
       personId: personId,
       personName: person.name,
       type: 'bonus',
       amount: amount,
       date: bonusDate,
       description: employer || '',
       employer: employer,
       isAutoLogged: false,
       monthApplied: monthApplied,
       isOneTime: true,
       isHistorical: bonusDate < getDateString(new Date(new Date().getFullYear(), new Date().getMonth(), 1))
   };
   
   data.paycheckHistory.push(bonus);
   
   $(`bonusAmount-${personId}`).value = '';
   $(`bonusDate-${personId}`).value = '';
   $(`bonusEmployer-${personId}`).value = '';
   
   saveDataToLocalStorage();
   updateHistoryDisplay();
   updateOverview();
   updatePersonOverview(personId);
   ensureDataConsistency();
}

function deletePaycheck(paycheckId, personId) {
    const paycheck = data.paycheckHistory.find(p => p.id === paycheckId);
    if (!paycheck) return;
   
    data.paycheckHistory = data.paycheckHistory.filter(p => p.id !== paycheckId);
   
    data.eventHistory.push({
        id: nextEventId++,
        date: getDateString(),
        event: 'Paycheck Deleted',
        description: `Deleted ${formatCurrency(paycheck.amount)} ${paycheck.type} for ${paycheck.personName} on ${paycheck.date}`
    });
   
    saveDataToLocalStorage();
    updatePersonOverview(personId);
    updateHistoryDisplay();
    updateOverview();
    ensureDataConsistency();
}

function updatePersonOverview(personId) {
    const person = data.people.find(p => p.id === personId);
    if (!person) return;
   
    const personTab = $(`person-${personId}`);
    if (personTab) {
        const yearlyIncomeView = personTab.querySelector('.historical-income-container');
        if (yearlyIncomeView) {
            const newView = createYearlyIncomeView(personId);
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = newView;
            const newElement = tempDiv.firstChild;
            yearlyIncomeView.parentNode.replaceChild(newElement, yearlyIncomeView);
        }
    }
}

function updateHistoryDisplay() {
    const incomeHistoryList = $('incomeHistoryList');
    const billHistoryList = $('billHistoryList');
    const eventHistoryList = $('eventHistoryList');
    const personFilterContainer = $('historyPersonFilter');
    const startDate = $('historyStartDate').value;
    const endDate = $('historyEndDate').value;
    const billNameFilter = $('billNameFilter').value.toLowerCase();
   
    let selectedPersonId = personFilterContainer.tagName === 'SELECT' ?
        (personFilterContainer.value === 'all' ? 'all' : parseInt(personFilterContainer.value)) :
        (data.people.length === 1 ? data.people[0].id : 'all');
   
    if (data.people.length === 1) {
        personFilterContainer.outerHTML = `<span id="historyPersonFilter">${data.people[0].name}</span>`;
        selectedPersonId = data.people[0].id;
    } else {
        const currentValue = personFilterContainer.tagName === 'SELECT' ? personFilterContainer.value : 'all';
        personFilterContainer.outerHTML = `<select id="historyPersonFilter"><option value="all">All People</option>${data.people.map(p => `<option value="${p.id}" ${p.id == currentValue ? 'selected' : ''}>${p.name}</option>`).join('')}</select>`;
        const newPersonFilter = $('historyPersonFilter');
        newPersonFilter.value = currentValue;
        newPersonFilter.addEventListener('change', updateHistoryDisplay);
    }
   
    let filteredPaychecks = data.paycheckHistory || [];
    if (selectedPersonId !== 'all') {
        filteredPaychecks = filteredPaychecks.filter(p => p.personId === selectedPersonId);
    }
    if (startDate) {
        filteredPaychecks = filteredPaychecks.filter(p => p.date >= startDate);
    }
    if (endDate) {
        filteredPaychecks = filteredPaychecks.filter(p => p.date <= endDate);
    }
   
    const sortedPaychecks = filteredPaychecks.sort((a, b) => {
        return b.date.localeCompare(a.date);
    });
   
    incomeHistoryList.innerHTML = sortedPaychecks.length > 0 ? sortedPaychecks.map(p => {
        const typeDisplay = p.type === 'bonus' ? 'Bonus' : 'Salary';
        const companyDisplay = p.employer || '';
        return `
            <tr>
                <td>${p.date}</td>
                <td>${p.personName}</td>
                <td>${typeDisplay}</td>
                <td>${formatCurrency(p.amount)}</td>
                <td>${companyDisplay}</td>
                <td>
                    <button class="btn-small" onclick="showEditPaycheckModal(${p.id})" style="margin-right: 5px; margin-bottom: 5px;">Edit</button>
                </td>
            </tr>
        `;
    }).join('') : '<tr><td colspan="6">No income data for selected person.</td></tr>';
   
    let filteredBillHistory = data.billPayments || [];
    if (selectedPersonId !== 'all') {
        filteredBillHistory = filteredBillHistory.filter(p =>
            p.payer === selectedPersonId ||
            (p.payer === 'joint' && data.people.find(person => person.id === selectedPersonId))
        );
    }
    if (startDate) {
        filteredBillHistory = filteredBillHistory.filter(p => p.date >= startDate);
    }
    if (endDate) {
        filteredBillHistory = filteredBillHistory.filter(p => p.date <= endDate);
    }
    if (billNameFilter) {
        filteredBillHistory = filteredBillHistory.filter(p => 
            p.billName.toLowerCase().includes(billNameFilter)
        );
    }
   
    if (!data.billPayments) data.billPayments = [];
    data.billPayments.forEach((payment, index) => {
        if (!payment.id) {
            payment.id = (data.billPaymentId || 1);
            data.billPaymentId = (data.billPaymentId || 1) + 1;
        }
    });
   
    const sortedBillHistory = filteredBillHistory.sort((a, b) => {
        return b.date.localeCompare(a.date);
    });
   
    billHistoryList.innerHTML = sortedBillHistory.length > 0 ? sortedBillHistory.map(p => {
        const originalBill = data.bills.find(b => b.id === p.billId);
        const isOneOff = originalBill && originalBill.isOneOff;
        
        let typeLabel;
        if (isOneOff) {
            typeLabel = 'One-Off Expense';
        } else if (p.billType === 'joint') {
            if (p.payer === 'joint') {
                typeLabel = 'Joint - Shared';
            } else {
                const payerName = data.people.find(person => person.id === p.payer)?.name || 'Unknown';
                typeLabel = `Joint - ${payerName}`;
            }
        } else {
            const payerName = data.people.find(person => person.id === p.payer)?.name || 'Unknown';
            typeLabel = `Individual - ${payerName}`;
        }
       
        return `
        <tr>
            <td>${p.date}</td>
            <td>${p.billName}</td>
            <td>${formatCurrency(p.amount)}</td>
            <td>${p.category}</td>
            <td>${typeLabel}</td>
            <td>
                <button class="btn-small" onclick="showEditBillPaymentModal(${p.id})" style="margin-right: 5px;">Edit</button>
            </td>
        </tr>
    `}).join('') : '<tr><td colspan="6">No bill payments for selected person.</td></tr>';
   
    let filteredEvents = data.eventHistory || [];
    if (selectedPersonId !== 'all') {
        const person = data.people.find(p => p.id === selectedPersonId);
        if (person) {
            filteredEvents = filteredEvents.filter(e =>
                e.description.includes(person.name) ||
                e.event.includes('Savings Goal Changed') ||
                e.event.includes('Expenses Goal Changed') ||
                e.event.includes('Currency Changed') ||
                e.event.includes('One Off Expense Deleted')
            );
        }
    }
    if (startDate) {
        filteredEvents = filteredEvents.filter(e => e.date >= startDate);
    }
    if (endDate) {
        filteredEvents = filteredEvents.filter(e => e.date <= endDate);
    }
   
    const sortedEvents = filteredEvents.sort((a, b) => {
        return b.date.localeCompare(a.date);
    }).slice(0, 10);
   
    eventHistoryList.innerHTML = sortedEvents.length > 0 ? sortedEvents.map(e => `
        <tr>
            <td>${e.date}</td>
            <td>${e.event}</td>
            <td>${e.description}</td>
            <td><button class="btn-danger btn-small" onclick="deleteEvent(${e.id})">Delete</button></td>
        </tr>
    `).join('') : '<tr><td colspan="4">No events for selected person.</td></tr>';
}

function showEditBillPaymentModal(paymentId) {
    const payment = data.billPayments.find(p => p.id === paymentId);
    if (!payment) return;
   
    const originalBill = data.bills.find(b => b.id === payment.billId);
   
    let modal = $('editModal');
    let modalContent;
   
    if (!modal) {
        const modalData = createModal();
        modal = modalData.modal;
        modalContent = modalData.modalContent;
    } else {
        modalContent = $('modalContent');
    }
   
    const categoryOptions = [
        'Utilities', 'Housing', 'Transportation', 'Insurance', 'Entertainment',
        'Subscriptions', 'Government', 'Financial', 'Health & Fitness', 'Technology', 'Other'
    ].map(cat =>
        `<option value="${cat}"${payment.category === cat ? ' selected' : ''}>${cat}</option>`
    ).join('');
   
    const payerOptions = data.people.map(person =>
        `<option value="${person.id}"${payment.payer == person.id ? ' selected' : ''}>${person.name}</option>`
    ).join('') + (payment.payer === 'joint' ? '<option value="joint" selected>Joint Account</option>' : '<option value="joint">Joint Account</option>');
   
    modalContent.innerHTML = `
        <h3 style="margin-bottom:20px;">Edit Bill Payment: ${payment.billName}</h3>
        <div class="form-group">
            <label for="editPaymentAmount">Amount</label>
            <input type="number" id="editPaymentAmount" value="${payment.amount}" step="0.01">
        </div>
        <div class="form-group">
            <label for="editPaymentDate">Date</label>
            <input type="date" id="editPaymentDate" value="${payment.date}">
            <div id="futureDateWarning" style="display:none;background:#fff3cd;padding:10px;border-radius:5px;margin-top:8px;color:#856404;font-size:12px;border:1px solid:#ffeaa7;">
                Moving to a date in the future will remove the expense from your history until the new day elapses.
            </div>
        </div>
        <div class="form-group">
            <label for="editPaymentBillName">Bill Name</label>
            <input type="text" id="editPaymentBillName" value="${payment.billName}">
        </div>
        <div class="form-group">
            <label for="editPaymentCategory">Category</label>
            <select id="editPaymentCategory">
                ${categoryOptions}
            </select>
        </div>
        ${data.people.length > 1 ? `
        <div class="form-group">
            <label for="editPaymentPayer">Paid By</label>
            <select id="editPaymentPayer">
                ${payerOptions}
            </select>
        </div>` : ''}
        <div class="form-group">
            <label for="editPaymentStatus">Status</label>
            <input type="text" id="editPaymentStatus" value="${payment.status || ''}">
        </div>
       
        <div style="display:flex;gap:10px;margin-top:20px;">
            <button id="savePaymentEditBtn" style="flex:1;">Save Changes</button>
            <button id="deletePaymentFromModalBtn" class="btn-danger" style="flex:1;">Delete Payment</button>
            <button id="cancelPaymentEditBtn" style="flex:1;background:#666;">Cancel</button>
        </div>
    `;

    const dateInput = $('editPaymentDate');
    const warningDiv = $('futureDateWarning');
    
    dateInput.addEventListener('change', () => {
        const selectedDate = dateInput.value;
        const today = getDateString();
        
        if (originalBill && originalBill.isOneOff && selectedDate > today) {
            warningDiv.style.display = 'block';
        } else {
            warningDiv.style.display = 'none';
        }
    });
   
    $('savePaymentEditBtn').addEventListener('click', () => {
        const amount = parseFloat($('editPaymentAmount').value) || 0;
        const date = $('editPaymentDate').value;
        const billName = $('editPaymentBillName').value.trim();
        const category = $('editPaymentCategory').value;
        const payer = data.people.length <= 1 ? data.people[0]?.id : $('editPaymentPayer').value;
        const status = $('editPaymentStatus').value.trim();
        const today = getDateString();
       
        if (!amount || !date || !billName) {
            alert('Please fill in amount, date, and bill name');
            return;
        }

        if (originalBill && originalBill.isOneOff && date > today) {
            const wasFutureDate = true;
            
            payment.amount = amount;
            payment.date = date;
            payment.billName = billName;
            payment.category = category;
            payment.payer = payer === 'joint' ? 'joint' : parseInt(payer);
            payment.status = status + ' (edited)';
           
            originalBill.name = billName;
            originalBill.amount = amount;
            originalBill.date = date;
            originalBill.category = category;
            originalBill.payer = payment.payer;
            
            data.billPayments = data.billPayments.filter(p => p.id !== paymentId);
            originalBill.isDeleted = false;
            delete originalBill.deletedDate;
            
            data.eventHistory.push({
                id: nextEventId++,
                date: getDateString(),
                event: 'Bill Payment Edited',
                description: `Edited payment: ${billName} - ${formatCurrency(amount)} on ${date} (moved to future - removed from history until due)`
            });
        } else {
            payment.amount = amount;
            payment.date = date;
            payment.billName = billName;
            payment.category = category;
            payment.payer = payer === 'joint' ? 'joint' : parseInt(payer);
            payment.status = status + ' (edited)';
           
            if (originalBill && originalBill.isOneOff) {
                originalBill.name = billName;
                originalBill.amount = amount;
                originalBill.date = date;
                originalBill.category = category;
                originalBill.payer = payment.payer;
            }
           
            data.eventHistory.push({
                id: nextEventId++,
                date: getDateString(),
                event: 'Bill Payment Edited',
                description: `Edited payment: ${billName} - ${formatCurrency(amount)} on ${date}`
            });
        }
       
        saveDataToLocalStorage();
        updateHistoryDisplay();
        updateBillsList();
        updateOverview();
        updateOneOffOverview();
        updateCalendarView();
        hideModal();
    });
   
    $('deletePaymentFromModalBtn').addEventListener('click', () => {
        if (!confirm('Are you sure you want to delete this payment record? This cannot be undone.')) return;
       
        data.billPayments = data.billPayments.filter(p => p.id !== paymentId);
       
        if (originalBill && originalBill.isOneOff) {
            originalBill.isDeleted = true;
            originalBill.deletedDate = getDateString();
        }
       
        data.eventHistory.push({
            id: nextEventId++,
            date: getDateString(),
            event: 'Bill Payment Deleted',
            description: `Deleted payment record: ${payment.billName} - ${formatCurrency(payment.amount)} from ${payment.date}`
        });
       
        saveDataToLocalStorage();
        updateHistoryDisplay();
        updateBillsList();
        updateOverview();
        updateOneOffOverview();
        updateCalendarView();
        hideModal();
    });
   
    $('cancelPaymentEditBtn').addEventListener('click', hideModal);
   
    showModal();
}

function showEditPaycheckModal(paycheckId) {
    const paycheck = data.paycheckHistory.find(p => p.id === paycheckId);
    if (!paycheck) return;
   
    let modal = $('editModal');
    let modalContent;
   
    if (!modal) {
        const modalData = createModal();
        modal = modalData.modal;
        modalContent = modalData.modalContent;
    } else {
        modalContent = $('modalContent');
    }
   
    const typeOptions = `
        <option value="salary"${paycheck.type === 'salary' ? ' selected' : ''}>Salary</option>
        <option value="bonus"${paycheck.type === 'bonus' ? ' selected' : ''}>Bonus</option>
    `;
   
    const frequencyOptions = `
        <option value="weekly"${paycheck.frequency === 'weekly' ? ' selected' : ''}>Weekly</option>
        <option value="biweekly"${paycheck.frequency === 'biweekly' ? ' selected' : ''}>Biweekly</option>
        <option value="monthly"${paycheck.frequency === 'monthly' ? ' selected' : ''}>Monthly</option>
        <option value="quarterly"${paycheck.frequency === 'quarterly' ? ' selected' : ''}>Quarterly</option>
        <option value="yearly"${paycheck.frequency === 'yearly' ? ' selected' : ''}>Yearly</option>
        <option value="manual"${paycheck.frequency === 'manual' ? ' selected' : ''}>Manual</option>
    `;
   
    const isAutoLogged = paycheck.isAutoLogged || false;
    const autoLoggedWarning = isAutoLogged ? `
        <div style="background:#fff3cd;padding:15px;border-radius:8px;margin:20px 0;color:#856404;font-size:12px;border:1px solid #ffeaa7;">
            <strong>FYI:</strong> Editing this information will only change this specific income date/amount. It won't affect any other salary entries, or your future salary schedule.
        </div>
    ` : '';
   
    modalContent.innerHTML = `
        <h3 style="margin-bottom:20px;">Edit ${paycheck.type === 'bonus' ? 'Bonus' : 'Salary'}: ${paycheck.personName}</h3>
        <div class="form-group">
            <label for="editPaycheckAmount">Amount</label>
            <input type="number" id="editPaycheckAmount" value="${paycheck.amount}" step="0.01">
        </div>
        <div class="form-group">
            <label for="editPaycheckDate">Date</label>
            <input type="date" id="editPaycheckDate" value="${paycheck.date}">
        </div>
        <div class="form-group">
            <label for="editPaycheckType">Type</label>
            <select id="editPaycheckType">
                ${typeOptions}
            </select>
        </div>
        <div class="form-group">
            <label for="editPaycheckFrequency">Frequency</label>
            <select id="editPaycheckFrequency">
                ${frequencyOptions}
            </select>
        </div>
        <div class="form-group">
            <label for="editPaycheckEmployer">Employer/Source</label>
            <input type="text" id="editPaycheckEmployer" value="${paycheck.employer || ''}" placeholder="Company name or income source">
        </div>
        <div class="form-group">
            <label for="editPaycheckDescription">Description</label>
            <input type="text" id="editPaycheckDescription" value="${paycheck.description || ''}" placeholder="Description of this income">
        </div>
       
        ${autoLoggedWarning}
       
        <div style="background:#f5f5f5;padding:15px;border-radius:8px;margin:20px 0;color:#666;font-size:12px;">
            <strong>Note:</strong> If your income has permanently changed since your last paycheck, then you can set a new start date and amount from your user page. Salary entries that have already been logged won't be affected when you do this (Unless you set your start date to before a previously logged salary).
        </div>
       
        <div style="display:flex;gap:10px;margin-top:20px;">
            <button id="savePaycheckEditBtn" style="flex:1;">Save Changes</button>
            <button id="deletePaycheckFromModalBtn" class="btn-danger" style="flex:1;">Delete Entry</button>
            <button id="cancelPaycheckEditBtn" style="flex:1;background:#666;">Cancel</button>
        </div>
    `;
   
    $('savePaycheckEditBtn').addEventListener('click', () => {
        const amount = parseFloat($('editPaycheckAmount').value) || 0;
        const date = $('editPaycheckDate').value;
        const type = $('editPaycheckType').value;
        const frequency = $('editPaycheckFrequency').value;
        const employer = $('editPaycheckEmployer').value.trim();
        const description = $('editPaycheckDescription').value.trim();
       
        if (!amount || !date) {
            alert('Please provide amount and date');
            return;
        }
       
        const selectedDate = getDateString(date);
        const today = getDateString();
        const currentMonthStart = getDateString(new Date(new Date().getFullYear(), new Date().getMonth(), 1));
       
        paycheck.amount = amount;
        paycheck.date = selectedDate;
        paycheck.type = type;
        paycheck.frequency = frequency;
        paycheck.employer = employer;
        paycheck.description = description + ' (edited)';
        paycheck.isHistorical = selectedDate < currentMonthStart;
        paycheck.monthApplied = `${new Date(selectedDate).getFullYear()}-${String(new Date(selectedDate).getMonth() + 1).padStart(2, '0')}`;
       
        data.eventHistory.push({
            id: nextEventId++,
            date: getDateString(),
            event: 'Income Entry Edited',
            description: `Edited ${type} entry: ${formatCurrency(amount)} for ${paycheck.personName} on ${selectedDate}${employer ? ` from ${employer}` : ''}`
        });
       
        saveDataToLocalStorage();
        updateHistoryDisplay();
        updateOverview();
        updateCalendarView();
        data.people.forEach(p => updatePersonOverview(p.id));
        hideModal();
    });
   
    $('deletePaycheckFromModalBtn').addEventListener('click', () => {
        customDeletePaycheckFromModal(paycheckId);
    });
   
    $('cancelPaycheckEditBtn').addEventListener('click', hideModal);
   
    showModal();
}

function deleteEvent(eventId) {
    if (!confirm('Are you sure you want to delete this event? This cannot be undone.')) return;
   
    const event = data.eventHistory.find(e => e.id === eventId);
    if (!event) return;
   
    data.eventHistory = data.eventHistory.filter(e => e.id !== eventId);
    saveDataToLocalStorage();
    updateHistoryDisplay();
}

function clearHistoryFilters() {
    $('historyPersonFilter').value = 'all';
    $('historyStartDate').value = '';
    $('historyEndDate').value = '';
    $('billNameFilter').value = '';
    updateHistoryDisplay();
}

function showTab(tabId) {
    document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
    });
   
    document.querySelectorAll('.tab').forEach(tab => {
        tab.classList.remove('active');
        if (tab.dataset.personId) {
            tab.style.backgroundColor = '';
            tab.style.color = '';
        }
    });
   
    const content = $(tabId);
    if (content) {
        content.classList.add('active');
    }
   
    const activeTab = document.querySelector(`.tab[data-tab="${tabId}"],.tab[data-person-id="${tabId.replace('person-', '')}"]`);
    if (activeTab) {
        activeTab.classList.add('active');
        if (activeTab.dataset.personId) {
            const personId = parseInt(activeTab.dataset.personId);
            const person = data.people.find(p => p.id === personId);
            if (person && person.color) {
                activeTab.style.backgroundColor = person.color;
                activeTab.style.color = '#ffffff';
            }
        }
    }
   
    if (tabId === 'overview') {
        resetCalendarToCurrentMonth();
    }
}

function resetCalendarToCurrentMonth() {
    const today = new Date();
    currentViewMonth = today.getMonth();
    currentViewYear = today.getFullYear();
    updateCalendarView();
}


function initCalendarInteractions() {
    const calendarDays = document.querySelectorAll('.calendar-day');
    const calendarOverlay = document.getElementById('calendarOverlay');
    const calendarGrid = document.querySelector('.calendar-grid');
   
    calendarDays.forEach(day => {
        day.addEventListener('click', function(event) {
            if (this.classList.contains('expanded') || event.target.classList.contains('day-close-btn')) {
                this.classList.remove('expanded');
                calendarGrid.classList.remove('has-expanded-day');
                if (calendarOverlay) calendarOverlay.style.display = 'none';
                return;
            }
           
            calendarDays.forEach(d => d.classList.remove('expanded'));
            calendarGrid.classList.remove('has-expanded-day');
           
            const dayIndex = Array.from(this.parentNode.children).indexOf(this) - 7;
            const dayOfWeek = dayIndex % 7;
           
            if (dayOfWeek >= 4) {
                this.style.right = '0';
                this.style.left = 'auto';
            } else {
                this.style.left = '0';
                this.style.right = 'auto';
            }
           
            this.classList.add('expanded');
            calendarGrid.classList.add('has-expanded-day');
           
            if (calendarOverlay) calendarOverlay.style.display = 'block';
        });
    });
   
    if (calendarOverlay) {
        calendarOverlay.addEventListener('click', function() {
            const expandedDay = document.querySelector('.calendar-day.expanded');
            if (expandedDay) {
                expandedDay.classList.remove('expanded');
                calendarGrid.classList.remove('has-expanded-day');
            }
            this.style.display = 'none';
        });
    }
   
    const prevMonthBtn = document.getElementById('prevMonthBtn');
    const nextMonthBtn = document.getElementById('nextMonthBtn');
   
    if (prevMonthBtn) {
        prevMonthBtn.removeEventListener('click', handlePrevMonth);
        prevMonthBtn.addEventListener('click', handlePrevMonth);
    }
   
    if (nextMonthBtn) {
        nextMonthBtn.removeEventListener('click', handleNextMonth);
        nextMonthBtn.addEventListener('click', handleNextMonth);
    }
}

function handlePrevMonth(e) {
    e.preventDefault();
    navigateCalendar(-1);
}

function handleNextMonth(e) {
    e.preventDefault();
    navigateCalendar(1);
}

function fullReset() {
    if (!confirm('Are you sure you want to reset all data? This cannot be undone.')) return;
   
    data = {
        people: [],
        bills: [],
        currency: "USD",
        darkMode: document.body.classList.contains('dark-mode'),
        weightedBills: false,
        nextPersonId: 1,
        nextBillId: 1,
        nextIncomeId: 1,
        nextEventId: 1,
        nextPaycheckId: 1,
        paycheckHistory: [],
        billHistory: [],
        eventHistory: [],
        billPayments: [],
        lastProcessedDate: null,
        peopleIncomeSettings: {},
        uiPreferences: {},
        savedFileHandle: null,
        billHistoryId: 1,
        dataVersion: "1.0"
    };
   
    nextPersonId = 1;
    nextBillId = 1;
    nextIncomeId = 1;
    nextEventId = 1;
    nextPaycheckId = 1;
    savedFileHandle = null;
   
    localStorage.removeItem(STORAGE_KEY);
    isPostImport = false;
    importBaseline = {};
   
    document.querySelectorAll('.tab[data-person-id]').forEach(tab => tab.remove());
    document.querySelectorAll('.tab-content[id^="person-"]').forEach(content => content.remove());
   
    updateGreeting();
    updateBillPayerOptions();
    updateBillsList();
    updateHistoryDisplay();
    updateOverview();
    toggleBillTypeVisibility();
    showTab('overview');
}

function updatePersonColor(personId, colorValue) {
    const person = data.people.find(p => p.id === personId);
    if (person) {
        const otherPersonWithSameColor = data.people.find(p => p.id !== personId && p.color === colorValue);
        if (otherPersonWithSameColor) {
            alert(`${otherPersonWithSameColor.name} is already using this colour. Please choose a different one.`);
            return;
        }
       
        person.color = colorValue;
        saveDataToLocalStorage();
        updateOverview();
       
        const personTab = document.querySelector(`button.tab[data-person-id="${personId}"]`);
        if (personTab) {
            if (personTab.classList.contains('active')) {
                personTab.style.backgroundColor = colorValue;
                personTab.style.color = '#ffffff';
            } else {
                personTab.style.backgroundColor = '';
                personTab.style.color = '';
            }
        }
       
        const changeColorBtn = document.querySelector(`#person-${personId} .card:nth-child(1) button[onclick*="showColorModal"]`);
        if (changeColorBtn) {
            changeColorBtn.style.backgroundColor = colorValue;
            changeColorBtn.style.color = '#ffffff';
        }
       
        hideColorModal();
    }
}

function getContrastColor(hexColor) {
    const r = parseInt(hexColor.substr(1, 2), 16);
    const g = parseInt(hexColor.substr(3, 2), 16);
    const b = parseInt(hexColor.substr(5, 2), 16);
    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
    return brightness > 128 ? '#000000' : '#ffffff';
}

function showColorModal(personId) {
    let modal = document.getElementById('colorModal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'colorModal';
        modal.className = 'color-modal';
        document.body.appendChild(modal);
       
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                hideColorModal();
            }
        });
    }
   
    const person = data.people.find(p => p.id === personId);
    const currentColor = person ? person.color : colorPalette[0].value;
    const usedColors = data.people.filter(p => p.id !== personId).map(p => p.color);
   
    const colorOptions = colorPalette.map(color => {
        const isUsed = usedColors.includes(color.value);
        const isCurrentColor = currentColor === color.value;
        const disabledStyle = isUsed && !isCurrentColor ? 'opacity:0.3;cursor:not-allowed;' : '';
        const onClick = isUsed && !isCurrentColor ? '' : `onclick="updatePersonColor(${personId}, '${color.value}')"`;
       
        return `<div class="color-option-item" style="${disabledStyle}" ${onClick}>
            <span class="color-swatch" style="background-color: ${color.value}"></span>
            <span>${color.name}${isUsed && !isCurrentColor ? ' (Used)' : ''}</span>
        </div>`;
    }).join('');
   
    const modalStyle = document.body.classList.contains('dark-mode') ?
        'background-color: #000000; color: #ffffff; border-color: #ffffff;' :
        'background-color: #ffffff; color: #000000; border-color: #000000;';
   
    modal.innerHTML = `
        <div class="color-modal-content" style="${modalStyle}">
            <h3 style="margin-bottom:20px;color:${document.body.classList.contains('dark-mode') ? '#fff' : '#000'};">Choose User Colour</h3>
            ${colorOptions}
            <div style="margin-top:20px;text-align:right;">
                <button onclick="hideColorModal()" style="background:#666;">Cancel</button>
            </div>
        </div>
    `;
   
    modal.style.display = 'flex';
}

function hideColorModal() {
    const modal = document.getElementById('colorModal');
    if (modal) {
        modal.style.display = 'none';
    }
}

function toggleSidebar() {
    $('sidebar').classList.toggle('open');
}

function markAsChanged() {
    const currentDataString = JSON.stringify(data);
    const originalDataString = JSON.stringify(originalEmbeddedData);
    hasChanges = currentDataString !== originalDataString;
}

function clearChanges() {
    hasChanges = false;
    localStorage.removeItem(STORAGE_KEY);
    originalEmbeddedData = JSON.parse(JSON.stringify(data));
}

function loadData() {
    try {
        localStorage.removeItem(STORAGE_KEY);
        
        const embeddedScript = document.getElementById('embedded-data');
        data = JSON.parse(embeddedScript.textContent);
        originalEmbeddedData = JSON.parse(JSON.stringify(data));
        sessionStartData = JSON.parse(JSON.stringify(data));
       
        nextPersonId = data.nextPersonId || 1;
        nextBillId = data.nextBillId || 1;
        nextIncomeId = data.nextIncomeId || 1;
        nextEventId = data.nextEventId || 1;
        nextPaycheckId = data.nextPaycheckId || 1;
        savedFileHandle = data.savedFileHandle || null;
       
        isPostImport = false;
        importBaseline = {};
       
        initializeBillPaymentIds();
       
        if (data.darkMode) document.body.classList.add('dark-mode');
        document.getElementById('currencySelect').value = data.currency || 'USD';
        document.getElementById('weightedBillsSidebar').checked = data.weightedBills || false;
       
        showTab('overview');
        const sidebar = document.getElementById('sidebar');
        if (sidebar.classList.contains('open')) {
            sidebar.classList.remove('open');
        }
       
        attachPersonEventListeners();
        clearChanges();
       
        setTimeout(() => {
            processElapsedBills();
            processElapsedIncome();
        }, 100);
       
        isPostImport = false;
        importBaseline = {};
       
    } catch (e) {
        console.error('Failed to load embedded data:', e);
        initializeDefaultData();
    }
}

function initializeBillPaymentIds() {
    if (!data.billPayments) data.billPayments = [];
    if (!data.billPaymentId) data.billPaymentId = 1;
   
    data.billPayments.forEach(payment => {
        if (!payment.id) {
            payment.id = data.billPaymentId++;
        }
    });
   
    if (data.billPayments.length > 0) {
        const maxId = Math.max(...data.billPayments.map(p => p.id));
        data.billPaymentId = Math.max(data.billPaymentId, maxId + 1);
    }
}


function initializeDefaultData() {
    data = {
        people: [],
        bills: [],
        currency: "USD",
        darkMode: false,
        weightedBills: false,
        nextPersonId: 1,
        nextBillId: 1,
        nextIncomeId: 1,
        nextEventId: 1,
        nextPaycheckId: 1,
        paycheckHistory: [],
        billHistory: [],
        eventHistory: [],
        billPayments: [],
        lastProcessedDate: null,
        peopleIncomeSettings: {},
        savedFileHandle: null
    };
    originalEmbeddedData = JSON.parse(JSON.stringify(data));
    sessionStartData = JSON.parse(JSON.stringify(data));
   
    showTab('overview');
    const sidebar = $('sidebar');
    if (sidebar.classList.contains('open')) {
        sidebar.classList.remove('open');
    }
   
    clearChanges();
    isPostImport = false;
    importBaseline = {};
}

function saveDataToLocalStorage() {
    if (isImporting) {
        console.log('Skipping save during import process');
        return;
    }
   
    try {
        if (isPostImport && Object.keys(importBaseline).length > 0) {
            const changes = calculateChanges();
            if (Object.keys(changes).length > 0) {
                const deltaData = {
                    isPostImport: true,
                    changes: changes,
                    counters: {
                        nextPersonId: nextPersonId,
                        nextBillId: nextBillId,
                        nextIncomeId: nextIncomeId,
                        nextEventId: nextEventId,
                        nextPaycheckId: nextPaycheckId
                    },
                    lastSaveTime: new Date().toISOString()
                };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(deltaData));
            }
        } else {
            data.nextPersonId = nextPersonId;
            data.nextBillId = nextBillId;
            data.nextIncomeId = nextIncomeId;
            data.nextEventId = nextEventId;
            data.nextPaycheckId = nextPaycheckId;
            data.savedFileHandle = savedFileHandle;
            localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
            markAsChanged();
        }
    } catch (e) {
        console.error('Failed to save to localStorage:', e);
        if (e.name === 'QuotaExceededError') {
            console.log('Storage quota exceeded, but continuing...');
        }
    }
}

function calculateChanges() {
    const changes = {};
   
    if (JSON.stringify(data.people) !== JSON.stringify(importBaseline.people)) {
        changes.people = data.people;
    }
   
    if (JSON.stringify(data.bills) !== JSON.stringify(importBaseline.bills)) {
        changes.bills = data.bills;
    }
   
    if (data.paycheckHistory.length > importBaseline.paycheckHistory.length) {
        changes.newPaychecks = data.paycheckHistory.slice(importBaseline.paycheckHistory.length);
    }
   
    if (data.eventHistory.length > importBaseline.eventHistory.length) {
        changes.newEvents = data.eventHistory.slice(importBaseline.eventHistory.length);
    }
   
    if (data.billPayments.length > (importBaseline.billPayments?.length || 0)) {
        changes.newBillPayments = data.billPayments.slice(importBaseline.billPayments?.length || 0);
    }
   
    if (data.currency !== importBaseline.currency) {
        changes.currency = data.currency;
    }
   
    if (data.darkMode !== importBaseline.darkMode) {
        changes.darkMode = data.darkMode;
    }
   
    if (data.weightedBills !== importBaseline.weightedBills) {
        changes.weightedBills = data.weightedBills;
    }
   
    if (data.lastProcessedDate !== importBaseline.lastProcessedDate) {
        changes.lastProcessedDate = data.lastProcessedDate;
    }
   
    if (JSON.stringify(data.peopleIncomeSettings) !== JSON.stringify(importBaseline.peopleIncomeSettings)) {
        changes.peopleIncomeSettings = data.peopleIncomeSettings;
    }
   
    return changes;
}



async function saveDataToFile() {
    try {
        const exportData = createCleanExportData();
        
        data.nextPersonId = nextPersonId;
        data.nextBillId = nextBillId;
        data.nextIncomeId = nextIncomeId;
        data.nextEventId = nextEventId;
        data.nextPaycheckId = nextPaycheckId;
        data.savedFileHandle = savedFileHandle;
       
        const embeddedScript = document.getElementById('embedded-data');
        embeddedScript.textContent = JSON.stringify(exportData, null, 8);
        const htmlContent = document.documentElement.outerHTML;
       
        if ('showSaveFilePicker' in window) {
            if (savedFileHandle) {
                try {
                    const writable = await savedFileHandle.createWritable();
                    await writable.write(htmlContent);
                    await writable.close();
                    alert('File saved successfully!');
                    
                    if (isPostImport) {
                        localStorage.removeItem(STORAGE_KEY);
                        importBaseline = JSON.parse(JSON.stringify(exportData));
                    }
                    
                    clearChanges();
                    return;
                } catch (err) {
                    if (err.name === 'NotAllowedError') {
                        savedFileHandle = null;
                        data.savedFileHandle = null;
                    }
                }
            }
           
            try {
                const currentPath = window.location.pathname;
                const fileName = currentPath.split('/').pop() || 'BUDGET.html';
                const fileHandle = await window.showSaveFilePicker({
                    suggestedName: fileName,
                    types: [{
                        description: 'HTML files',
                        accept: { 'text/html': ['.html'] }
                    }]
                });
               
                const writable = await fileHandle.createWritable();
                await writable.write(htmlContent);
                await writable.close();
                savedFileHandle = fileHandle;
                data.savedFileHandle = fileHandle;
                alert('File saved successfully!');
            } catch (err) {
                if (err.name !== 'AbortError') {
                    throw err;
                }
                return;
            }
        } else {
            const blob = new Blob([htmlContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'BUDGET.html';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            alert('File downloaded successfully! Please save it over your original file.');
        }
        
        if (isPostImport) {
            localStorage.removeItem(STORAGE_KEY);
            importBaseline = JSON.parse(JSON.stringify(exportData));
        }
        
        clearChanges();
    } catch (e) {
        console.error('Failed to save file:', e);
        alert('Failed to save file. Please try again.');
    }
}

function recordEvent(eventType, description) {
  if (!data.eventHistory) {
    data.eventHistory = [];
  }

  if (!['Person Added', 'Person Deleted', 'Currency Changed', 'Savings Goal Changed', 'Expenses Goal Changed', 'One Off Expense Deleted'].includes(eventType)) {
    return;
  }

  const eventEntry = {
    id: nextEventId++,
    date: new Date().toISOString().split('T')[0],
    event: eventType,
    description: description
  };

  data.eventHistory.unshift(eventEntry);
  
  if (data.eventHistory.length > 10) {
    data.eventHistory = data.eventHistory.slice(0, 10);
  }
  
  saveDataToLocalStorage();
}


function processElapsedBills() {
   const today = getDateString();
   let billsUpdated = false;
   let billPaymentsAdded = 0;

   if (!data.billPayments) data.billPayments = [];
   if (!data.billPaymentId) data.billPaymentId = 1;

   data.bills.forEach(bill => {
       if (bill.isDeleted) return;
      
       if (bill.isDebt && bill.totalDebt <= 0.01) {
           recordEvent('Debt Paid Off', `${bill.name} debt fully paid off!`);
           bill.isDeleted = true;
           return;
       }
      
       if (bill.isOneOff) {
           const billDate = getDateString(bill.date);
          
           if (billDate <= today) {
               const paymentExists = data.billPayments.some(payment => payment.billId === bill.id);
              
               if (!paymentExists) {
                   const paymentRecord = {
                       id: data.billPaymentId++,
                       billId: bill.id,
                       billName: bill.name,
                       amount: bill.amount,
                       date: billDate,
                       category: bill.category,
                       billType: bill.billType || 'individual',
                       payer: bill.payer,
                       status: 'Auto-processed one-off expense'
                   };
                  
                   data.billPayments.push(paymentRecord);
                   billsUpdated = true;
                   billPaymentsAdded++;
               }
           }
           return;
       }
      
       const billCreatedDate = getDateString(bill.dateCreated) || '1970-01-01';
       let checkDate = new Date(billCreatedDate);
      
       if (bill.frequency === 'monthly') {
           checkDate = new Date(new Date(billCreatedDate).getFullYear(), new Date(billCreatedDate).getMonth(), bill.day);
          
           if (getDateString(checkDate) < billCreatedDate) {
               checkDate.setMonth(checkDate.getMonth() + 1);
           }
          
           while (getDateString(checkDate) <= today) {
               const paymentDate = getDateString(checkDate);
              
               const paymentExists = data.billPayments.some(payment =>
                   payment.billId === bill.id &&
                   payment.date === paymentDate
               );

               if (!paymentExists) {
                   const paymentAmount = bill.amount + (bill.overpayment || 0);
                  
                   if (bill.isDebt) {
                       const monthlyRate = (bill.interestRate || 0) / 100 / 12;
                       const interest = bill.totalDebt * monthlyRate;
                       const principal = Math.min(paymentAmount - interest, bill.totalDebt);
                      
                       bill.totalDebt = Math.max(0, bill.totalDebt - principal);
                       billsUpdated = true;

                       const paymentRecord = {
                           id: data.billPaymentId++,
                           billId: bill.id,
                           billName: bill.name,
                           amount: paymentAmount,
                           date: paymentDate,
                           category: bill.category,
                           billType: bill.billType || 'individual',
                           payer: bill.payer,
                           status: 'Auto-processed debt payment',
                           interestPaid: interest,
                           principalPaid: principal
                       };
                      
                       data.billPayments.push(paymentRecord);
                       billPaymentsAdded++;

                       if (bill.totalDebt <= 0.01) {
                           recordEvent('Debt Paid Off', `${bill.name} debt fully paid off!`);
                           break;
                       }
                   } else {
                       const paymentRecord = {
                           id: data.billPaymentId++,
                           billId: bill.id,
                           billName: bill.name,
                           amount: paymentAmount,
                           date: paymentDate,
                           category: bill.category,
                           billType: bill.billType || 'individual',
                           payer: bill.payer,
                           status: 'Auto-processed payment'
                       };
                      
                       data.billPayments.push(paymentRecord);
                       billsUpdated = true;
                       billPaymentsAdded++;
                   }
               }

               checkDate.setMonth(checkDate.getMonth() + 1);
              
               const daysInNextMonth = new Date(checkDate.getFullYear(), checkDate.getMonth() + 1, 0).getDate();
               if (bill.day > daysInNextMonth) {
                   checkDate.setDate(daysInNextMonth);
               } else {
                   checkDate.setDate(bill.day);
               }
           }

           bill.date = getDateString(checkDate);
           billsUpdated = true;
       } else if (bill.frequency === 'quarterly') {
           const billStartMonth = bill.startMonth || (new Date(billCreatedDate).getMonth() + 1);
           checkDate = new Date(new Date(billCreatedDate).getFullYear(), billStartMonth - 1, bill.day);
          
           if (getDateString(checkDate) < billCreatedDate) {
               checkDate.setMonth(checkDate.getMonth() + 3);
           }
          
           while (getDateString(checkDate) <= today) {
               const paymentExists = data.billPayments.some(payment =>
                   payment.billId === bill.id &&
                   payment.date === getDateString(checkDate)
               );

               if (!paymentExists) {
                   const paymentAmount = bill.amount + (bill.overpayment || 0);
                  
                   const paymentRecord = {
                       id: data.billPaymentId++,
                       billId: bill.id,
                       billName: bill.name,
                       amount: paymentAmount,
                       date: getDateString(checkDate),
                       category: bill.category,
                       billType: bill.billType || 'individual',
                       payer: bill.payer,
                       status: 'Auto-processed payment'
                   };
                  
                   data.billPayments.push(paymentRecord);
                   billsUpdated = true;
                   billPaymentsAdded++;
               }
              
               checkDate.setMonth(checkDate.getMonth() + 3);
              
               const daysInTargetMonth = new Date(checkDate.getFullYear(), checkDate.getMonth() + 1, 0).getDate();
               if (bill.day > daysInTargetMonth) {
                   checkDate.setDate(daysInTargetMonth);
               } else {
                   checkDate.setDate(bill.day);
               }
           }

           bill.date = getDateString(checkDate);
           billsUpdated = true;
       } else if (bill.frequency === 'yearly' && bill.month) {
           checkDate = new Date(new Date(billCreatedDate).getFullYear(), bill.month - 1, bill.day);
          
           if (getDateString(checkDate) < billCreatedDate) {
               checkDate.setFullYear(checkDate.getFullYear() + 1);
           }
          
           while (getDateString(checkDate) <= today) {
               const paymentExists = data.billPayments.some(payment =>
                   payment.billId === bill.id &&
                   payment.date === getDateString(checkDate)
               );

               if (!paymentExists) {
                   const paymentAmount = bill.amount + (bill.overpayment || 0);
                  
                   const paymentRecord = {
                       id: data.billPaymentId++,
                       billId: bill.id,
                       billName: bill.name,
                       amount: paymentAmount,
                       date: getDateString(checkDate),
                       category: bill.category,
                       billType: bill.billType || 'individual',
                       payer: bill.payer,
                       status: 'Auto-processed payment'
                   };
                  
                   data.billPayments.push(paymentRecord);
                   billsUpdated = true;
                   billPaymentsAdded++;
               }
              
               checkDate.setFullYear(checkDate.getFullYear() + 1);
              
               const daysInTargetMonth = new Date(checkDate.getFullYear(), bill.month, 0).getDate();
               if (bill.day > daysInTargetMonth) {
                   checkDate.setDate(daysInTargetMonth);
               } else {
                   checkDate.setDate(bill.day);
               }
           }

           bill.date = getDateString(checkDate);
           billsUpdated = true;
       }
   });

   data.bills = data.bills.filter(bill => !(bill.isDebt && bill.totalDebt <= 0.01));
  
   if (billsUpdated) {
       data.lastProcessedDate = today;
       saveDataToLocalStorage();
   }
  
   return billsUpdated;
}

function ensureDataConsistency() {
    if (!data.billPayments) data.billPayments = [];
    if (!data.paycheckHistory) data.paycheckHistory = [];
    if (!data.eventHistory) data.eventHistory = [];
    if (!data.people) data.people = [];
    if (!data.bills) data.bills = [];
   
    if (!data.billPaymentId) data.billPaymentId = 1;
    if (!nextPersonId) nextPersonId = 1;
    if (!nextBillId) nextBillId = 1;
    if (!nextEventId) nextEventId = 1;
    if (!nextPaycheckId) nextPaycheckId = 1;
   
    data.billPayments.forEach(payment => {
        if (!payment.id) {
            payment.id = data.billPaymentId++;
        }
    });
   
    if (data.billPayments.length > 0) {
        const maxBillPaymentId = Math.max(...data.billPayments.map(p => p.id || 0));
        data.billPaymentId = Math.max(data.billPaymentId, maxBillPaymentId + 1);
    }
   
    if (data.people.length > 0) {
        const maxPersonId = Math.max(...data.people.map(p => p.id || 0));
        nextPersonId = Math.max(nextPersonId, maxPersonId + 1);
    }
   
    if (data.bills.length > 0) {
        const maxBillId = Math.max(...data.bills.map(b => b.id || 0));
        nextBillId = Math.max(nextBillId, maxBillId + 1);
    }
   
    if (data.paycheckHistory.length > 0) {
        const maxPaycheckId = Math.max(...data.paycheckHistory.map(p => p.id || 0));
        nextPaycheckId = Math.max(nextPaycheckId, maxPaycheckId + 1);
    }
   
    if (data.eventHistory.length > 0) {
        const maxEventId = Math.max(...data.eventHistory.map(e => e.id || 0));
        nextEventId = Math.max(nextEventId, maxEventId + 1);
    }
   
    const validPersonIds = data.people.map(p => p.id);
   
    data.paycheckHistory = data.paycheckHistory.filter(paycheck => validPersonIds.includes(paycheck.personId));
   
    data.bills = data.bills.filter(bill => {
        if (bill.isDeleted) return true;
        if (!validPersonIds.includes(bill.payer) && bill.payer !== 'joint') {
            if (bill.billType === 'individual' && bill.isDebt) {
                return false;
            }
        }
        return true;
    });
   
    data.billPayments = data.billPayments.filter(payment => {
        const originalBill = data.bills.find(b => b.id === payment.billId);
        if (originalBill && originalBill.isOneOff && !validPersonIds.includes(payment.payer) && payment.payer !== 'joint') {
            return false;
        }
        return true;
    });
   
    const personNameMap = {};
    data.people.forEach(person => {
        personNameMap[person.id] = person.name;
    });
   
    data.paycheckHistory.forEach(paycheck => {
        if (paycheck.personId && personNameMap[paycheck.personId]) {
            paycheck.personName = personNameMap[paycheck.personId];
        }
    });
   
    data.bills.forEach(bill => {
        if (bill.payer !== 'joint' && !validPersonIds.includes(bill.payer)) {
            bill.payer = 'Deleted';
        }
    });
   
    data.billPayments.forEach(payment => {
        if (payment.payer !== 'joint' && !validPersonIds.includes(payment.payer)) {
            const originalBill = data.bills.find(b => b.id === payment.billId);
            if (originalBill && originalBill.billType === 'joint') {
                payment.payer = 'Deleted';
            }
        }
    });
   
    data.nextPersonId = nextPersonId;
    data.nextBillId = nextBillId;
    data.nextEventId = nextEventId;
    data.nextPaycheckId = nextPaycheckId;
}

function getDateString(date = null) {
    if (date === null) {
        const today = new Date();
        return `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
    }
   
    if (typeof date === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(date)) {
        return date;
    }
   
    if (typeof date === 'string') {
        return date.split('T')[0];
    }
   
    if (date instanceof Date) {
        return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
    }
   
    return date.toString().split('T')[0];
}

function findBillPayment(billId, date) {
    const dateStr = getDateString(date);
    return data.billPayments.find(payment =>
        payment.billId === billId &&
        payment.date === dateStr
    );
}

function hasBillPayment(billId, date) {
    const dateStr = getDateString(date);
    return data.billPayments.some(payment =>
        payment.billId === billId &&
        payment.date === dateStr
    );
}

function generateMissingBillPayments(startDate, endDate) {
    const start = new Date(startDate);
    const end = new Date(endDate || new Date());
    let paymentsAdded = 0;
   
    let currentDate = new Date(start);
   
    while (currentDate <= end) {
        data.bills.forEach(bill => {
            if (isBillDueOnDate(bill, currentDate)) {
                const paymentExists = data.billPayments.some(payment =>
                    payment.billId === bill.id &&
                    payment.date === currentDate.toISOString().split('T')[0]
                );
               
                if (!paymentExists) {
                    const paymentRecord = {
                        billId: bill.id,
                        billName: bill.name,
                        amount: bill.amount + (bill.overpayment || 0),
                        date: currentDate.toISOString().split('T')[0],
                        category: bill.category,
                        billType: bill.billType || 'individual',
                        payer: bill.payer,
                        status: 'Historical auto-processed payment'
                    };
                   
                    if (!data.billPayments) data.billPayments = [];
                    data.billPayments.push(paymentRecord);
                    paymentsAdded++;
                }
            }
        });
       
        currentDate.setDate(currentDate.getDate() + 1);
    }
   
    if (paymentsAdded > 0) {
        data.eventHistory.push({
            id: nextEventId++,
            date: new Date().toISOString().split('T')[0],
            event: 'Historical Payments Generated',
            description: `Generated ${paymentsAdded} missing bill payments from ${startDate} to ${endDate || 'today'}`
        });
    }
   
    return paymentsAdded;
}

function processImportBills() {
    if (!data.billPayments) data.billPayments = [];
    if (!data.billPaymentId) data.billPaymentId = 1;
    
    const billPaymentsCountBefore = data.billPayments.length;
   
    const billsUpdated = processElapsedBills();
   
    const billPaymentsAdded = data.billPayments.length - billPaymentsCountBefore;
   
    if (billPaymentsAdded > 0) {
        console.log(`Added ${billPaymentsAdded} bill payments during import processing`);
        data.eventHistory.push({
            id: nextEventId++,
            date: new Date().toISOString().split('T')[0],
            event: 'Import Bill Processing',
            description: `Added ${billPaymentsAdded} bill payments for past due dates during import processing`
        });
    }
   
    return billPaymentsAdded > 0;
}

function getFrequencyMs(frequency) {
    switch (frequency) {
        case 'daily': return 1000 * 60 * 60 * 24;
        case 'biweekly': return 1000 * 60 * 60 * 24 * 14;
        case 'monthly': return 1000 * 60 * 60 * 24 * 30;
        case 'quarterly': return 1000 * 60 * 60 * 24 * 90;
        case 'yearly': return 1000 * 60 * 60 * 24 * 365;
        default: return 0;
    }
}

function processElapsedIncome() {
    const today = getDateString();
    let incomeUpdated = false;
   
    if (!data.peopleIncomeSettings) data.peopleIncomeSettings = {};
   
    data.people.forEach(person => {
        if (!person.paymentDate || !person.income || !person.frequency) return;
        
        const paymentStartDate = getDateString(person.paymentDate);
        if (paymentStartDate > today) return;
       
        if (!data.peopleIncomeSettings[person.id]) {
            data.peopleIncomeSettings[person.id] = {
                lastAmount: person.income,
                lastFrequency: person.frequency,
                lastPaymentDate: person.paymentDate,
                currentAmount: person.income
            };
        }
       
        const settings = data.peopleIncomeSettings[person.id];
        let paymentDateObj = new Date(getDateString(person.paymentDate));
       
        let nextPayDate;
       
        if (settings.nextPaymentDate) {
            nextPayDate = new Date(getDateString(settings.nextPaymentDate));
        } else {
            nextPayDate = new Date(paymentDateObj);
           
            if (getDateString(nextPayDate) > today) {
                settings.nextPaymentDate = getDateString(nextPayDate);
                return;
            }
        }
       
        while (getDateString(nextPayDate) <= today) {
            const paymentDate = getDateString(nextPayDate);
            const monthApplied = `${nextPayDate.getFullYear()}-${String(nextPayDate.getMonth() + 1).padStart(2, '0')}`;
           
            const existingPaychecks = data.paycheckHistory.filter(p =>
                p.personId === person.id &&
                p.date === paymentDate &&
                p.type === 'salary'
            );
           
            if (existingPaychecks.length === 0) {
                const currentAmount = settings.currentAmount || person.income;
               
                data.paycheckHistory.push({
                    id: nextPaycheckId++,
                    personId: person.id,
                    personName: person.name,
                    type: 'salary',
                    amount: currentAmount,
                    date: paymentDate,
                    description: `Auto-logged ${person.frequency} salary${person.employer ? ` - ${person.employer}` : ''}`,
                    employer: person.employer,
                    frequency: person.frequency,
                    isAutoLogged: true,
                    isHistorical: paymentDate !== today,
                    monthApplied: monthApplied
                });
               
                incomeUpdated = true;
               
                data.eventHistory.push({
                    id: nextEventId++,
                    date: getDateString(),
                    event: 'Salary Auto-Logged',
                    description: `Auto-logged ${person.frequency} salary of ${formatCurrency(currentAmount)} for ${person.name} on ${paymentDate}`
                });
            }
           
            nextPayDate = getNextPaymentDate(nextPayDate, person.frequency);
        }
       
        settings.nextPaymentDate = getDateString(nextPayDate);
       
        if (person.income !== settings.currentAmount) {
            let nextPayDateObj = new Date(getDateString(settings.nextPaymentDate));
            if (today < getDateString(nextPayDateObj)) {
                settings.currentAmount = person.income;
            }
        }
    });
   
    data.lastProcessedDate = today;
   
    if (incomeUpdated) {
        saveDataToLocalStorage();
    }
   
    return incomeUpdated;
}

function getNextPaymentDate(currentDate, frequency) {
    const nextDate = new Date(currentDate.getTime());
   
    switch (frequency) {
        case 'weekly':
            nextDate.setDate(currentDate.getDate() + 7);
            break;
        case 'biweekly':
            nextDate.setDate(currentDate.getDate() + 14);
            break;
        case 'monthly':
            const currentDay = currentDate.getDate();
            const nextMonth = currentDate.getMonth() + 1;
            const nextYear = nextMonth > 11 ? currentDate.getFullYear() + 1 : currentDate.getFullYear();
            const actualNextMonth = nextMonth > 11 ? 0 : nextMonth;
           
            const daysInNextMonth = new Date(nextYear, actualNextMonth + 1, 0).getDate();
            const actualDay = currentDay > daysInNextMonth ? daysInNextMonth : currentDay;
           
            nextDate.setFullYear(nextYear);
            nextDate.setMonth(actualNextMonth);
            nextDate.setDate(actualDay);
            break;
        case 'quarterly':
            const currentDayQ = currentDate.getDate();
            const nextMonthQ = currentDate.getMonth() + 3;
            const nextYearQ = nextMonthQ > 11 ? currentDate.getFullYear() + 1 : currentDate.getFullYear();
            const actualNextMonthQ = nextMonthQ > 11 ? nextMonthQ - 12 : nextMonthQ;
           
            const daysInTargetMonthQ = new Date(nextYearQ, actualNextMonthQ + 1, 0).getDate();
            const actualDayQ = currentDayQ > daysInTargetMonthQ ? daysInTargetMonthQ : currentDayQ;
           
            nextDate.setFullYear(nextYearQ);
            nextDate.setMonth(actualNextMonthQ);
            nextDate.setDate(actualDayQ);
            break;
        case 'yearly':
            const currentDayY = currentDate.getDate();
            const currentMonthY = currentDate.getMonth();
            const nextYearY = currentDate.getFullYear() + 1;
           
            const daysInTargetMonthY = new Date(nextYearY, currentMonthY + 1, 0).getDate();
            const actualDayY = currentDayY > daysInTargetMonthY ? daysInTargetMonthY : currentDayY;
           
            nextDate.setFullYear(nextYearY);
            nextDate.setMonth(currentMonthY);
            nextDate.setDate(actualDayY);
            break;
    }
   
    return nextDate;
}

function processImportIncome() {
    console.log("Processing incomes after import...");
   
    const payCheckCountBefore = data.paycheckHistory.length;
   
    const updatedIncomes = processElapsedIncome();
   
    const payChecksAdded = data.paycheckHistory.length - payCheckCountBefore;
   
    if (payChecksAdded > 0) {
        console.log(`Added ${payChecksAdded} missing paychecks during import processing`);
        data.eventHistory.push({
            id: nextEventId++,
            date: new Date().toISOString().split('T')[0],
            event: 'Import Income Processing',
            description: `Added ${payChecksAdded} missing paychecks for all users during import processing`
        });
    } else {
        console.log("No missing paychecks found during import processing");
    }
   
    return payChecksAdded > 0;
}

function updateGreeting() {
    const names = data.people.map(p => p.name).join(' & ');
    $('greeting').textContent = names ? `Hello, ${names}!` : 'Hello, Welcome!';
}

function toggleDarkMode() {
    document.body.classList.toggle('dark-mode');
    data.darkMode = document.body.classList.contains('dark-mode');
    saveDataToLocalStorage();
    ensureDataConsistency();
}

function updateCurrency() {
  const oldCurrency = data.currency;
  const newCurrency = $('currencySelect').value;
 
  if (oldCurrency === newCurrency) return;
 
  data.currency = newCurrency;
 
  recordEvent('Currency Changed', `Changed currency from ${oldCurrency} to ${newCurrency}. All amounts will now display in ${newCurrency}.`);
 
  saveDataToLocalStorage();
  updateOverview();
  updateHistoryDisplay();
  updateBillsList();
  data.people.forEach(p => updatePersonOverview(p.id));
  updateCalendarView();
  ensureDataConsistency();
}

function formatCurrency(amount) {
const roundedAmount = Math.round((amount + Number.EPSILON) * 100) / 100;
    const currencySymbols = {
        'USD': '$',
        'EUR': '€',
        'GBP': '£',
        'JPY': '¥',
        'CAD': '$'
    };
   
    const symbol = currencySymbols[data.currency] || '$';
    const formattedAmount = new Intl.NumberFormat('en-US', {
        minimumFractionDigits: data.currency === 'JPY' ? 0 : 2,
        maximumFractionDigits: data.currency === 'JPY' ? 0 : 2
    }).format(amount);
   
    return `${symbol}${formattedAmount}`;
}

function updateWeightedBills() {
    data.weightedBills = $('weightedBillsSidebar').checked;
    saveDataToLocalStorage();
    updateOverview();
    ensureDataConsistency();
}

function addPersonIncome(personId, incomeAmount, paymentDate, frequency, employer, isHistorical = false) {
    const person = data.people.find(p => p.id === personId);
    if (!person) return;
   
    const payDate = new Date(paymentDate);
    const currentMonthYear = `${payDate.getFullYear()}-${String(payDate.getMonth() + 1).padStart(2, '0')}`;
   
    const paycheck = {
        id: nextPaycheckId++,
        personId: personId,
        personName: person.name,
        type: 'salary',
        amount: incomeAmount,
        date: paymentDate,
        description: employer ? `${frequency} salary - ${employer}` : `${frequency} salary`,
        employer: employer,
        frequency: frequency,
        isAutoLogged: false,
        monthApplied: currentMonthYear,
        dateCreated: new Date().toISOString().split('T')[0],
        isHistorical: isHistorical
    };
   
    data.paycheckHistory.push(paycheck);
    return paycheck;
}

function updateTabsVisibility() {
    const addPersonTab = $('addPersonTab');
    if (!addPersonTab) return;
   
    if (data.people.length === 0) {
        addPersonTab.style.display = 'block';
    } else {
        addPersonTab.style.display = 'none';
    }
}

function addNewPerson() {
  const name = prompt('Enter User Name Below\nAdd more users using the sidemenu ☰');
  if (!name || !name.trim()) return;
 
  const trimmedName = name.trim();
  if (data.people.some(p => p.name.toLowerCase() === trimmedName.toLowerCase())) {
    alert('A person with this name already exists!');
    return;
  }
 
  const newPerson = {
    id: nextPersonId++,
    name: trimmedName,
    income: 0,
    frequency: 'monthly',
    paymentDate: '',
    savings: 0,
    expenses: 0,
    employer: '',
    color: colorPalette[data.people.length % colorPalette.length].value
  };
 
  data.people.push(newPerson);
  recordEvent('Person Added', `Added ${trimmedName} to budget tracker`);
 
  saveDataToLocalStorage();
  createPersonTab(newPerson);
  attachPersonEventListeners();
  updateGreeting();
  updateBillPayerOptions();
  updateHistoryDisplay();
  updateOverview();
  toggleBillTypeVisibility();
  updateTabsVisibility();
 
  const sidebar = $('sidebar');
  if (sidebar.classList.contains('open')) {
    sidebar.classList.remove('open');
  }
 
  showTab(`person-${newPerson.id}`);
}

function calculateJointBillTransfers() {
    const transfers = [];
    const jointBills = data.bills.filter(b => b.billType === 'joint' && b.payer !== 'joint' && !b.isDeleted);
    const jointAccountBills = data.bills.filter(b => b.billType === 'joint' && b.payer === 'joint' && !b.isDeleted);
    const consolidatedTransfers = {};
    const personToPersonDebts = {};
   
    jointBills.forEach(bill => {
        let monthlyAmount;
        if (bill.isOneOff) {
            const billDate = new Date(bill.date);
            const today = new Date();
            if (billDate.getMonth() === today.getMonth() && billDate.getFullYear() === today.getFullYear()) {
                monthlyAmount = bill.amount + (bill.overpayment || 0);
            } else {
                return;
            }
        } else {
            monthlyAmount = frequencyToMonthly(bill.amount + (bill.overpayment || 0), bill.frequency);
        }
       
        const payerId = parseInt(bill.payer);
        const payer = data.people.find(p => p.id === payerId);
        if (!payer) return;
       
        data.people.forEach(person => {
            if (person.id !== payerId) {
                const personShare = calculateWeightedShare(monthlyAmount, person.id, data.weightedBills);
               
                if (personShare > 0) {
                    const debtKey = `${person.id}-owes-${payerId}`;
                    if (!personToPersonDebts[debtKey]) {
                        personToPersonDebts[debtKey] = {
                            fromId: person.id,
                            fromName: person.name,
                            toId: payerId,
                            toName: payer.name,
                            amount: 0
                        };
                    }
                    personToPersonDebts[debtKey].amount += personShare;
                }
            }
        });
    });
   
    const netDebts = {};
    Object.values(personToPersonDebts).forEach(debt => {
        const reverseKey = `${debt.toId}-${debt.fromId}`;
        const forwardKey = `${debt.fromId}-${debt.toId}`;
       
        if (!netDebts[reverseKey]) {
            if (!netDebts[forwardKey]) {
                netDebts[forwardKey] = {
                    fromId: debt.fromId,
                    fromName: debt.fromName,
                    toId: debt.toId,
                    toName: debt.toName,
                    amount: debt.amount
                };
            } else {
                netDebts[forwardKey].amount += debt.amount;
            }
        } else {
            const netAmount = debt.amount - netDebts[reverseKey].amount;
            if (netAmount > 0) {
                netDebts[forwardKey] = {
                    fromId: debt.fromId,
                    fromName: debt.fromName,
                    toId: debt.toId,
                    toName: debt.toName,
                    amount: netAmount
                };
                delete netDebts[reverseKey];
            } else if (netAmount < 0) {
                netDebts[reverseKey].amount = Math.abs(netAmount);
            } else {
                delete netDebts[reverseKey];
            }
        }
    });
   
    Object.values(netDebts).forEach(debt => {
        if (debt.amount > 0.01) {
            consolidatedTransfers[`${debt.fromName}-to-${debt.toName}`] = {
                from: debt.fromName,
                to: debt.toName,
                amount: debt.amount,
                type: 'person'
            };
        }
    });
   
    jointAccountBills.forEach(bill => {
        let monthlyAmount;
        if (bill.isOneOff) {
            const billDate = new Date(bill.date);
            const today = new Date();
            if (billDate.getMonth() === today.getMonth() && billDate.getFullYear() === today.getFullYear()) {
                monthlyAmount = bill.amount + (bill.overpayment || 0);
            } else {
                return;
            }
        } else {
            monthlyAmount = frequencyToMonthly(bill.amount + (bill.overpayment || 0), bill.frequency);
        }
       
        data.people.forEach(person => {
            const personShare = calculateWeightedShare(monthlyAmount, person.id, data.weightedBills);
           
            if (personShare > 0) {
                const key = `${person.name}-to-Joint`;
                if (!consolidatedTransfers[key]) {
                    consolidatedTransfers[key] = {
                        from: person.name,
                        to: 'Joint Account',
                        amount: 0,
                        type: 'joint'
                    };
                }
                consolidatedTransfers[key].amount += personShare;
            }
        });
    });
   
    return Object.values(consolidatedTransfers);
}

function isPaydayOnDate(person, day, month, year) {
    if (!person.paymentDate || !person.frequency) return false;
   
    const paymentDate = new Date(getDateString(person.paymentDate));
    const checkDate = new Date(year, month, day);
   
    if (person.frequency === 'monthly') {
        const payDay = paymentDate.getDate();
        const daysInMonth = new Date(year, month + 1, 0).getDate();
       
        if (payDay > daysInMonth) {
            return day === daysInMonth;
        }
        return payDay === day;
    }
   
    if (person.frequency === 'biweekly') {
        const timeDiff = checkDate.getTime() - paymentDate.getTime();
        const daysDiff = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
        return daysDiff >= 0 && daysDiff % 14 === 0;
    }
   
    if (person.frequency === 'quarterly') {
        const payDay = paymentDate.getDate();
        const payMonth = paymentDate.getMonth();
       
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        const adjustedPayDay = payDay > daysInMonth ? daysInMonth : payDay;
       
        if (adjustedPayDay !== day) return false;
       
        const monthsDiff = (year - paymentDate.getFullYear()) * 12 + (month - payMonth);
        return monthsDiff >= 0 && monthsDiff % 3 === 0;
    }
   
    if (person.frequency === 'yearly') {
        const payDay = paymentDate.getDate();
        const payMonth = paymentDate.getMonth();
       
        if (month !== payMonth) return false;
       
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        const adjustedPayDay = payDay > daysInMonth ? daysInMonth : payDay;
       
        return adjustedPayDay === day && year >= paymentDate.getFullYear();
    }
   
    return false;
}

function showDayEvents(element) {
    const eventsData = JSON.parse(element.dataset.events);
   
    let modal = $('editModal');
    let modalContent;
   
    if (!modal) {
        const modalData = createModal();
        modal = modalData.modal;
        modalContent = modalData.modalContent;
    } else {
        modalContent = $('modalContent');
    }
   
    const monthNames = ["January", "February", "March", "April", "May", "June",
                       "July", "August", "September", "October", "November", "December"];
   
    const dateString = `${eventsData.day} ${monthNames[eventsData.month]} ${eventsData.year}`;
   
    let billsHTML = '';
    if (eventsData.bills && eventsData.bills.length > 0) {
        billsHTML = `
            <div class="day-events-section">
                <h4>Bills</h4>
                ${eventsData.bills.map(bill => {
                    const backgroundColor = bill.payerColor ? bill.payerColor : '#e8e8e8';
                    const textColor = bill.payerColor ? getContrastColor(bill.payerColor) : '#000000';
                    return `
                        <div class="day-event-item" style="background-color: ${backgroundColor}; color: ${textColor}; padding: 10px; margin-bottom: 8px; border-radius: 4px;">
                            <div>${bill.name}: ${formatCurrency(bill.amount + (bill.overpayment || 0))}</div>
                            <div style="font-size: 12px;">Category: ${bill.category}</div>
                            ${bill.displayNote ? `<div style="font-size: 12px;">${bill.displayNote}</div>` : ''}
                        </div>
                    `;
                }).join('')}
            </div>
        `;
    }
   
    let paydaysHTML = '';
    if (eventsData.paydays && eventsData.paydays.length > 0) {
        paydaysHTML = `
            <div class="day-events-section">
                <h4>Paydays</h4>
                ${eventsData.paydays.map(person => {
                    return `
                        <div class="day-event-item" style="background-color: ${person.color}; color: #000000; padding: 10px; margin-bottom: 8px; border-radius: 4px;">
                            <div>${person.name} Payday: ${formatCurrency(person.amount || person.income || 0)}</div>
                        </div>
                    `;
                }).join('')}
            </div>
        `;
    }
   
    let bonusesHTML = '';
    if (eventsData.bonuses && eventsData.bonuses.length > 0) {
        bonusesHTML = `
            <div class="day-events-section">
                <h4>Bonuses</h4>
                ${eventsData.bonuses.map(bonus => {
                    return `
                        <div class="day-event-item" style="background-color: ${bonus.person.color}; color: #000000; padding: 10px; margin-bottom: 8px; border-radius: 4px;">
                            <div>${bonus.person.name} Bonus: ${formatCurrency(bonus.amount)}</div>
                        </div>
                    `;
                }).join('')}
            </div>
        `;
    }
   
    let oneOffsHTML = '';
    if (eventsData.oneOffs && eventsData.oneOffs.length > 0) {
        oneOffsHTML = `
            <div class="day-events-section">
                <h4>One-Off Expenses</h4>
                ${eventsData.oneOffs.map(oneOff => {
                    const backgroundColor = oneOff.payerColor ? oneOff.payerColor : '#8e1600';
                    const textColor = oneOff.payerColor ? getContrastColor(oneOff.payerColor) : '#ffffff';
                    return `
                        <div class="day-event-item" style="background-color: ${backgroundColor}; color: ${textColor}; padding: 10px; margin-bottom: 8px; border-radius: 4px;">
                            <div>${oneOff.name}: ${formatCurrency(oneOff.amount)}</div>
                            <div style="font-size: 12px;">Category: ${oneOff.category}</div>
                        </div>
                    `;
                }).join('')}
            </div>
        `;
    }
   
    modalContent.innerHTML = `
        <h3 style="margin-bottom:20px;color:${document.body.classList.contains('dark-mode') ? '#fff' : '#000'};">Events for ${dateString}</h3>
        <div class="day-events-container">
            ${billsHTML}
            ${paydaysHTML}
            ${bonusesHTML}
            ${oneOffsHTML}
        </div>
        <div style="margin-top:20px;text-align:right;">
            <button onclick="hideModal()" style="background:#666;">Close</button>
        </div>
    `;
   
    showModal();
}



function createYearlyIncomeView(personId) {
    const person = data.people.find(p => p.id === personId);
    if (!person) return '';
   
    const paychecks = data.paycheckHistory.filter(p => p.personId === personId);
    if (paychecks.length === 0) {
        return '<div class="historical-income-container"><h4>Income History</h4><p>No income data recorded.</p></div>';
    }
   
    const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
                       "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    const yearData = {};
   
    paychecks.forEach(paycheck => {
        const date = new Date(getDateString(paycheck.date));
        const year = date.getFullYear();
        const month = date.getMonth();
       
        if (!yearData[year]) {
            yearData[year] = {
                months: {},
                totalSalary: 0,
                totalBonuses: 0,
                salaryCount: 0,
                bonusCount: 0
            };
        }
        if (!yearData[year].months[month]) {
            yearData[year].months[month] = { salary: 0, bonuses: 0, items: [] };
        }
       
        if (paycheck.type === 'bonus') {
            yearData[year].months[month].bonuses += paycheck.amount;
            yearData[year].totalBonuses += paycheck.amount;
            yearData[year].bonusCount++;
        } else {
            yearData[year].months[month].salary += paycheck.amount;
            yearData[year].totalSalary += paycheck.amount;
            yearData[year].salaryCount++;
        }
       
        yearData[year].months[month].items.push({
            type: paycheck.type,
            amount: paycheck.amount,
            date: paycheck.date,
            description: paycheck.description
        });
    });
   
    const years = Object.keys(yearData).sort((a, b) => b - a);
    let html = `<div class="historical-income-container" id="salaryHistory-${personId}"><h4>Income History</h4>`;
   
    years.forEach(year => {
        const yearInfo = yearData[year];
        const monthsWithData = Object.keys(yearInfo.months).sort((a, b) => b - a);
        const totalIncome = yearInfo.totalSalary + yearInfo.totalBonuses;
       
        html += `<div class="year-group">`;
        html += `<div class="year-header">${year}</div>`;
        html += `<div class="year-totals">`;
        html += `Total Income: ${formatCurrency(totalIncome)} `;
        if (yearInfo.totalSalary > 0 && yearInfo.totalBonuses > 0) {
            html += `(Salary: ${formatCurrency(yearInfo.totalSalary)} | Bonuses: ${formatCurrency(yearInfo.totalBonuses)})`;
        }
        html += `</div>`;
       
        if (monthsWithData.length > 0) {
            html += `<div class="months-list">`;
            monthsWithData.forEach(month => {
                const monthData = yearInfo.months[month];
                const monthTotal = monthData.salary + monthData.bonuses;
               
                html += `<div class="month-item">`;
                html += `<span class="month-name">${monthNames[month]}</span>`;
                html += `<span class="month-total">`;
               
                if (monthData.salary > 0 && monthData.bonuses > 0) {
                    html += `${formatCurrency(monthTotal)} (${formatCurrency(monthData.salary)} + ${formatCurrency(monthData.bonuses)} bonus)`;
                } else {
                    html += `${formatCurrency(monthTotal)}`;
                    if (monthData.bonuses > 0) html += ` (bonus)`;
                }
               
                html += `</span>`;
                html += `</div>`;
            });
            html += `</div>`;
        }
        html += `</div>`;
    });
   
    html += '</div>';
    return html;
}

function formatCurrency(amount) {
    const formatter = new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: data.currency || 'USD'
    });
    return formatter.format(amount);
}

function calculateDebtInfo(bill) {
    if (!bill.isDebt || !bill.totalDebt || !bill.interestRate) return null;
   
    const monthlyRate = bill.interestRate / 100 / 12;
    const totalPayment = bill.amount + (bill.overpayment || 0);
    const monthlyPayment = frequencyToMonthly(totalPayment, bill.frequency);
    const monthlyInterest = bill.totalDebt * monthlyRate;
   
    let balance = bill.totalDebt;
    let months = 0;
    let totalInterestPaid = 0;
    const maxMonths = 600;
   
    while (balance > 0.01 && months < maxMonths) {
        const interestPayment = balance * monthlyRate;
        const principalPayment = monthlyPayment - interestPayment;
       
        if (principalPayment <= 0) break;
       
        balance -= principalPayment;
        totalInterestPaid += interestPayment;
        months++;
    }
   
    let balanceWithoutOverpayment = bill.totalDebt;
    let monthsWithoutOverpayment = 0;
    let totalInterestWithoutOverpayment = 0;
    const basePayment = frequencyToMonthly(bill.amount, bill.frequency);
   
    while (balanceWithoutOverpayment > 0.01 && monthsWithoutOverpayment < maxMonths) {
        const interestPayment = balanceWithoutOverpayment * monthlyRate;
        const principalPayment = basePayment - interestPayment;
       
        if (principalPayment <= 0) break;
       
        balanceWithoutOverpayment -= principalPayment;
        totalInterestWithoutOverpayment += interestPayment;
        monthsWithoutOverpayment++;
    }
   
    return {
        monthlyInterest: monthlyInterest,
        payoffMonths: months < maxMonths ? months : null,
        payoffMonthsWithoutOverpayment: monthsWithoutOverpayment < maxMonths ? monthsWithoutOverpayment : null,
        overpaymentSavings: bill.overpayment || 0,
        interestSaved: totalInterestWithoutOverpayment - totalInterestPaid,
        termReduction: monthsWithoutOverpayment - months
    };
}

function toggleBillFrequencyOptions() {
    const frequency = $('billFrequency').value;
    const monthGroup = $('billMonthGroup');
    const startMonthGroup = $('billStartMonthGroup');
   
    if (frequency === 'yearly') {
        monthGroup.style.display = 'block';
        startMonthGroup.style.display = 'none';
    } else if (frequency === 'quarterly') {
        monthGroup.style.display = 'none';
        startMonthGroup.style.display = 'block';
    } else {
        monthGroup.style.display = 'none';
        startMonthGroup.style.display = 'none';
    }
}

function getNextWorkingDay(date) {
    const nextDay = new Date(date);
    nextDay.setDate(date.getDate() + 1);
    while (nextDay.getDay() === 0 || nextDay.getDay() === 6) {
        nextDay.setDate(nextDay.getDate() + 1);
    }
    return nextDay;
}

function generateBillDate(day, month, frequency, startMonth) {
    const today = getDateString();
    const todayDate = new Date(today);
    let billDate;
   
    if (frequency === 'monthly') {
        billDate = new Date(todayDate.getFullYear(), todayDate.getMonth(), day);
       
        if (getDateString(billDate) < today) {
            billDate.setMonth(billDate.getMonth() + 1);
           
            const daysInNextMonth = new Date(billDate.getFullYear(), billDate.getMonth() + 1, 0).getDate();
            if (day > daysInNextMonth) {
                billDate.setDate(daysInNextMonth);
            }
        }
    }
    else if (frequency === 'yearly' && month) {
        billDate = new Date(todayDate.getFullYear(), month - 1, day);
       
        if (getDateString(billDate) < today) {
            billDate.setFullYear(todayDate.getFullYear() + 1);
           
            const daysInNextMonth = new Date(billDate.getFullYear(), billDate.getMonth() + 1, 0).getDate();
            if (day > daysInNextMonth) {
                billDate.setDate(daysInNextMonth);
            }
        }
    }
    else if (frequency === 'quarterly') {
        const currentMonth = todayDate.getMonth() + 1;
        const quarterStart = startMonth || currentMonth;
       
        let nextQuarterMonth = quarterStart;
       
        while (nextQuarterMonth <= currentMonth) {
            nextQuarterMonth += 3;
        }
       
        if (nextQuarterMonth > 12) {
            nextQuarterMonth = ((nextQuarterMonth - 1) % 12) + 1;
            billDate = new Date(todayDate.getFullYear() + 1, nextQuarterMonth - 1, day);
        } else {
            billDate = new Date(todayDate.getFullYear(), nextQuarterMonth - 1, day);
        }
       
        const daysInMonth = new Date(billDate.getFullYear(), billDate.getMonth() + 1, 0).getDate();
        if (day > daysInMonth) {
            billDate.setDate(daysInMonth);
        }
    }
    else {
        billDate = new Date(todayDate.getFullYear(), todayDate.getMonth(), day);
       
        if (getDateString(billDate) < today) {
            billDate.setMonth(billDate.getMonth() + 1);
           
            const daysInNextMonth = new Date(billDate.getFullYear(), billDate.getMonth() + 1, 0).getDate();
            if (day > daysInNextMonth) {
                billDate.setDate(daysInNextMonth);
            }
        }
    }
   
    return getDateString(billDate);
}



function isPaydayOnDate(person, day, month, year) {
    if (!person.paymentDate || !person.frequency) return false;
   
    const paymentDate = new Date(person.paymentDate);
    const checkDate = new Date(year, month, day);
   
    if (person.frequency === 'monthly') {
        const payDay = paymentDate.getDate();
        const daysInMonth = new Date(year, month + 1, 0).getDate();
       
        if (payDay > daysInMonth) {
            return day === daysInMonth;
        }
        return payDay === day;
    }
   
    if (person.frequency === 'biweekly') {
        const timeDiff = checkDate.getTime() - paymentDate.getTime();
        const daysDiff = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
        return daysDiff >= 0 && daysDiff % 14 === 0;
    }
   
    if (person.frequency === 'quarterly') {
        const payDay = paymentDate.getDate();
        const payMonth = paymentDate.getMonth();
       
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        const adjustedPayDay = payDay > daysInMonth ? daysInMonth : payDay;
       
        if (adjustedPayDay !== day) return false;
       
        const monthsDiff = (year - paymentDate.getFullYear()) * 12 + (month - payMonth);
        return monthsDiff >= 0 && monthsDiff % 3 === 0;
    }
   
    if (person.frequency === 'yearly') {
        const payDay = paymentDate.getDate();
        const payMonth = paymentDate.getMonth();
       
        if (month !== payMonth) return false;
       
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        const adjustedPayDay = payDay > daysInMonth ? daysInMonth : payDay;
       
        return adjustedPayDay === day && year >= paymentDate.getFullYear();
    }
   
    return false;
}

function toggleBillTypeVisibility() {
    const billTypeGroup = $('billTypeGroup');
    const billPayerGroup = $('billPayerGroup');
   
    if (data.people.length <= 1) {
        billTypeGroup.style.display = 'none';
        billPayerGroup.style.display = 'none';
        $('billType').value = 'individual';
    } else {
        billTypeGroup.style.display = 'block';
        toggleBillPayerVisibility();
    }
}

function toggleBillPayerVisibility() {
    const billType = $('billType').value;
    const billPayerGroup = $('billPayerGroup');
    billPayerGroup.style.display = 'block';
    updateBillPayerOptions();
}

function updateBillPayerOptions() {
    const billPayer = $('billPayer');
    const billType = $('billType').value;
   
    billPayer.innerHTML = '';
   
    if (billType === 'joint') {
        const jointOption = document.createElement('option');
        jointOption.value = 'joint';
        jointOption.textContent = 'Joint Account';
        billPayer.appendChild(jointOption);
    }
   
    data.people.forEach(person => {
        const option = document.createElement('option');
        option.value = person.id;
        option.textContent = person.name;
        billPayer.appendChild(option);
    });
   
    if (billPayer.options.length > 0 && !billPayer.value) {
        if (billType === 'joint') {
            billPayer.value = 'joint';
        } else {
            billPayer.value = data.people[0].id;
        }
    }
}

function toggleDebtFields() {
    const isDebt = $('isDebt').checked;
    const debtFields = $('debtFields');
    debtFields.style.display = isDebt ? 'block' : 'none';
}

function toggleOneOffFields() {
    const isOneOff = $('isOneOff').checked;
    const billFrequency = $('billFrequency');
    const billFrequencyGroup = billFrequency.closest('.form-group');
    const billDate = $('billDate');
    const billDateGroup = billDate.closest('.form-group');
    const billMonthGroup = $('billMonthGroup');
    const billStartMonthGroup = $('billStartMonthGroup');
    const isDebtCheckbox = $('isDebt');
   
    if (isOneOff) {
        billFrequency.disabled = true;
        billFrequency.value = 'monthly';
        billFrequencyGroup.style.display = 'none';
        billDateGroup.style.display = 'none';
        billMonthGroup.style.display = 'none';
        billStartMonthGroup.style.display = 'none';
        isDebtCheckbox.checked = false;
        isDebtCheckbox.disabled = true;
        toggleDebtFields();
    } else {
        billFrequency.disabled = false;
        billFrequencyGroup.style.display = 'block';
        billDateGroup.style.display = 'block';
        isDebtCheckbox.disabled = false;
        toggleBillFrequencyOptions();
    }
}

function createModal() {
    const modal = document.createElement('div');
    modal.id = 'editModal';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: none;
        z-index: 10000;
        justify-content: center;
        align-items: center;
        padding: 20px;
        box-sizing: border-box;
    `;
   
    const modalContent = document.createElement('div');
    modalContent.id = 'modalContent';
    modalContent.className = 'color-modal-content';
    modalContent.style.cssText = `
        max-height: 90vh;
        overflow-y: auto;
        max-width: 500px;
        width: 100%;
    `;
   
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
   
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            hideModal();
        }
    });
   
    return { modal, modalContent };
}

function showModal() {
    let modal = $('editModal');
    if (!modal) {
        const modalData = createModal();
        modal = modalData.modal;
    }
    modal.style.display = 'flex';
}

function hideModal() {
    const modal = $('editModal');
    if (modal) {
        modal.style.display = 'none';
    }
}

function showEditBillPaymentModal(paymentId) {
    const payment = data.billPayments.find(p => p.id === paymentId);
    if (!payment) return;
   
    const originalBill = data.bills.find(b => b.id === payment.billId);
   
    let modal = $('editModal');
    let modalContent;
   
    if (!modal) {
        const modalData = createModal();
        modal = modalData.modal;
        modalContent = modalData.modalContent;
    } else {
        modalContent = $('modalContent');
    }
   
    const categoryOptions = [
        'Utilities', 'Housing', 'Transportation', 'Insurance', 'Entertainment',
        'Subscriptions', 'Government', 'Financial', 'Health & Fitness', 'Technology', 'Other'
    ].map(cat =>
        `<option value="${cat}"${payment.category === cat ? ' selected' : ''}>${cat}</option>`
    ).join('');
   
    const payerOptions = data.people.map(person =>
        `<option value="${person.id}"${payment.payer == person.id ? ' selected' : ''}>${person.name}</option>`
    ).join('') + (payment.payer === 'joint' ? '<option value="joint" selected>Joint Account</option>' : '<option value="joint">Joint Account</option>');
   
    modalContent.innerHTML = `
        <h3 style="margin-bottom:20px;">Edit Bill Payment: ${payment.billName}</h3>
        <div class="form-group">
            <label for="editPaymentAmount">Amount</label>
            <input type="number" id="editPaymentAmount" value="${payment.amount}" step="0.01">
        </div>
        <div class="form-group">
            <label for="editPaymentDate">Date</label>
            <input type="date" id="editPaymentDate" value="${payment.date}">
            <div id="futureDateWarning" style="display:none;background:#fff3cd;padding:10px;border-radius:5px;margin-top:8px;color:#856404;font-size:12px;border:1px solid:#ffeaa7;">
                Moving to a date in the future will remove the expense from your history until the new day elapses.
            </div>
        </div>
        <div class="form-group">
            <label for="editPaymentBillName">Bill Name</label>
            <input type="text" id="editPaymentBillName" value="${payment.billName}">
        </div>
        <div class="form-group">
            <label for="editPaymentCategory">Category</label>
            <select id="editPaymentCategory">
                ${categoryOptions}
            </select>
        </div>
        ${data.people.length > 1 ? `
        <div class="form-group">
            <label for="editPaymentPayer">Paid By</label>
            <select id="editPaymentPayer">
                ${payerOptions}
            </select>
        </div>` : ''}
        <div class="form-group">
            <label for="editPaymentStatus">Status</label>
            <input type="text" id="editPaymentStatus" value="${payment.status || ''}">
        </div>
       
        <div style="display:flex;gap:10px;margin-top:20px;">
            <button id="savePaymentEditBtn" style="flex:1;">Save Changes</button>
            <button id="deletePaymentFromModalBtn" class="btn-danger" style="flex:1;">Delete Payment</button>
            <button id="cancelPaymentEditBtn" style="flex:1;background:#666;">Cancel</button>
        </div>
    `;

    const dateInput = $('editPaymentDate');
    const warningDiv = $('futureDateWarning');
    
    dateInput.addEventListener('change', () => {
        const selectedDate = dateInput.value;
        const today = getDateString();
        
        if (originalBill && originalBill.isOneOff && selectedDate > today) {
            warningDiv.style.display = 'block';
        } else {
            warningDiv.style.display = 'none';
        }
    });
   
    $('savePaymentEditBtn').addEventListener('click', () => {
        const amount = parseFloat($('editPaymentAmount').value) || 0;
        const date = $('editPaymentDate').value;
        const billName = $('editPaymentBillName').value.trim();
        const category = $('editPaymentCategory').value;
        const payer = data.people.length <= 1 ? data.people[0]?.id : $('editPaymentPayer').value;
        const status = $('editPaymentStatus').value.trim();
        const today = getDateString();
       
        if (!amount || !date || !billName) {
            alert('Please fill in amount, date, and bill name');
            return;
        }

        if (originalBill && originalBill.isOneOff && date > today) {
            payment.amount = amount;
            payment.date = date;
            payment.billName = billName;
            payment.category = category;
            payment.payer = payer === 'joint' ? 'joint' : parseInt(payer);
            payment.status = status + ' (edited)';
           
            originalBill.name = billName;
            originalBill.amount = amount;
            originalBill.date = date;
            originalBill.category = category;
            originalBill.payer = payment.payer;
            
            data.billPayments = data.billPayments.filter(p => p.id !== paymentId);
            originalBill.isDeleted = false;
            delete originalBill.deletedDate;
            
            data.eventHistory.push({
                id: nextEventId++,
                date: getDateString(),
                event: 'Bill Payment Edited',
                description: `Edited payment: ${billName} - ${formatCurrency(amount)} on ${date} (moved to future - removed from history until due)`
            });
        } else {
            payment.amount = amount;
            payment.date = date;
            payment.billName = billName;
            payment.category = category;
            payment.payer = payer === 'joint' ? 'joint' : parseInt(payer);
            payment.status = status + ' (edited)';
           
            if (originalBill && originalBill.isOneOff) {
                originalBill.name = billName;
                originalBill.amount = amount;
                originalBill.date = date;
                originalBill.category = category;
                originalBill.payer = payment.payer;
            }
           
            data.eventHistory.push({
                id: nextEventId++,
                date: getDateString(),
                event: 'Bill Payment Edited',
                description: `Edited payment: ${billName} - ${formatCurrency(amount)} on ${date}`
            });
        }
       
        saveDataToLocalStorage();
        updateHistoryDisplay();
        updateBillsList();
        updateOverview();
        updateOneOffOverview();
        updateCalendarView();
        hideModal();
    });
   
    $('deletePaymentFromModalBtn').addEventListener('click', () => {
        customDeleteBillPaymentFromModal(paymentId);
    });
   
    $('cancelPaymentEditBtn').addEventListener('click', hideModal);
   
    showModal();
}

function updateBillSchedule(bill, newDay, newMonth, newStartMonth, newFrequency) {
    const today = getDateString();
    const billCreatedDate = getDateString(bill.dateCreated) || today;
    
    const existingPayments = data.billPayments.filter(payment => payment.billId === bill.id);
    const updatedPayments = [];
    
    existingPayments.forEach(payment => {
        const oldPaymentDate = new Date(payment.date);
        const newPaymentDate = calculateNewPaymentDate(oldPaymentDate, bill, newDay, newMonth, newStartMonth, newFrequency);
        
        if (newPaymentDate) {
            payment.date = getDateString(newPaymentDate);
            payment.status = payment.status.includes('(date changed)') ? payment.status : payment.status + ' (date changed)';
            updatedPayments.push(payment);
        }
    });
    
    const newBillDate = generateBillDate(newDay, newMonth, newFrequency, newStartMonth);
    
    data.eventHistory.push({
        id: nextEventId++,
        date: today,
        event: 'Bill Schedule Updated',
        description: `Updated ${bill.name} schedule. ${updatedPayments.length} existing payments adjusted to new dates.`
    });
    
    return newBillDate;
}

function calculateNewPaymentDate(oldDate, bill, newDay, newMonth, newStartMonth, newFrequency) {
    const oldYear = oldDate.getFullYear();
    const oldMonthNum = oldDate.getMonth();
    
    if (newFrequency === 'yearly' && newMonth) {
        return new Date(oldYear, newMonth - 1, newDay);
    }
    
    if (newFrequency === 'quarterly' && newStartMonth) {
        const quarterMonths = [];
        for (let k = 0; k < 4; k++) {
            quarterMonths.push(((newStartMonth - 1 + k * 3) % 12));
        }
        
        const oldQuarterIndex = quarterMonths.findIndex(month => month === oldMonthNum);
        if (oldQuarterIndex !== -1) {
            return new Date(oldYear, quarterMonths[oldQuarterIndex], newDay);
        }
        
        const nearestQuarterMonth = quarterMonths.reduce((prev, curr) => 
            Math.abs(curr - oldMonthNum) < Math.abs(prev - oldMonthNum) ? curr : prev
        );
        return new Date(oldYear, nearestQuarterMonth, newDay);
    }
    
    if (newFrequency === 'monthly') {
        return new Date(oldYear, oldMonthNum, newDay);
    }
    
    return null;
}

function removeFutureBillPayments(billId, fromDate) {
    const removedPayments = data.billPayments.filter(payment =>
        payment.billId === billId &&
        new Date(payment.date) >= fromDate
    );
   
    if (removedPayments.length > 0) {
        data.billPayments = data.billPayments.filter(payment =>
            !(payment.billId === billId && new Date(payment.date) >= fromDate)
        );
       
        data.eventHistory.push({
            id: nextEventId++,
            date: new Date().toISOString().split('T')[0],
            event: 'Future Bill Payments Removed',
            description: `Removed ${removedPayments.length} future bill payments due to bill edits. Payments before ${fromDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })} preserved.`
        });
    }
   
    return removedPayments.length;
}

function addBill() {
    const name = $('billName').value.trim();
    const amount = parseFloat($('billAmount').value) || 0;
    const frequency = $('billFrequency').value;
    const day = parseInt($('billDate').value);
    const month = $('billMonth').value ? parseInt($('billMonth').value) : null;
    const startMonth = $('billStartMonth').value ? parseInt($('billStartMonth').value) : null;
    const category = $('billCategory').value;
    const billType = data.people.length <= 1 ? 'individual' : $('billType').value;
    const isDebt = $('isDebt').checked;
    const isOneOff = $('isOneOff').checked;
   
    let payer;
    if (data.people.length <= 1) {
        payer = data.people[0]?.id;
    } else {
        const selectedPayer = $('billPayer').value;
        if (billType === 'joint' && selectedPayer === 'joint') {
            payer = 'joint';
        } else {
            payer = parseInt(selectedPayer);
        }
    }
   
    if (!name || !amount) {
        alert('Please fill in bill name and amount');
        return;
    }
   
    if (!isOneOff && frequency === 'yearly' && !month) {
        alert('Please select a month for yearly bills');
        return;
    }
   
    if (!isOneOff && frequency === 'quarterly' && !startMonth) {
        alert('Please select a start month for quarterly bills');
        return;
    }
   
    if (!isOneOff && day && month && frequency === 'yearly') {
        const testDate = new Date(2024, month - 1, day);
        if (testDate.getMonth() !== month - 1) {
            alert(`Day ${day} does not exist in ${['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'][month - 1]}. The bill will be moved to the next valid day when that month occurs.`);
        }
    }
   
    if (!isOneOff && day > 31) {
        alert('Please select a valid day (1-31)');
        return;
    }
   
    if (payer !== 'joint' && !data.people.find(p => p.id === payer)) {
        alert('Please select a valid payer');
        return;
    }
   
    const today = new Date();
    const todayString = getDateString();
   
    const billDate = isOneOff ? todayString : generateBillDate(day, month, frequency, startMonth);
   
    const bill = {
        id: nextBillId++,
        name: name,
        amount: amount,
        frequency: isOneOff ? 'one-off' : frequency,
        date: billDate,
        day: isOneOff ? null : day,
        month: isOneOff ? null : month,
        startMonth: frequency === 'quarterly' ? startMonth : null,
        category: category,
        billType: billType,
        payer: payer,
        isDebt: isDebt,
        isOneOff: isOneOff,
        dateCreated: todayString
    };
   
    if (isDebt) {
        bill.totalDebt = parseFloat($('totalDebt').value) || 0;
        bill.interestRate = parseFloat($('interestRate').value) || 0;
        bill.termYears = parseInt($('termYears').value) || 0;
        bill.termMonths = parseInt($('termMonths').value) || 0;
        bill.overpayment = parseFloat($('overpayment').value) || 0;
    }
   
    data.bills.push(bill);
   
    const payerName = payer === 'joint' ? 'Joint Account' :
                     data.people.find(p => p.id === parseInt(payer))?.name || 'Unknown';
   
    let shouldCreatePayment = false;
    let paymentReason = '';
   
    if (isOneOff) {
        shouldCreatePayment = true;
        paymentReason = 'One-off expense';
    }
    else if (day === today.getDate()) {
        shouldCreatePayment = true;
        paymentReason = 'Due today';
    }
    else if (!isOneOff) {
        const currentMonthBillDate = new Date(today.getFullYear(), today.getMonth(), day);
       
        if (getDateString(currentMonthBillDate) < todayString) {
            shouldCreatePayment = true;
            paymentReason = 'Past due date in current month';
        }
    }
   
    if (shouldCreatePayment) {
        const paymentDate = isOneOff ? billDate :
                           getDateString(new Date(today.getFullYear(), today.getMonth(), day));
       
        const paymentRecord = {
            id: data.billPaymentId++,
            billId: bill.id,
            billName: bill.name,
            amount: bill.amount + (bill.overpayment || 0),
            date: paymentDate,
            category: bill.category,
            billType: bill.billType,
            payer: bill.payer,
            status: isOneOff ? 'One-off expense' : `Auto-processed payment (${paymentReason})`
        };
       
        if (!data.billPayments) data.billPayments = [];
        data.billPayments.push(paymentRecord);
    }
   
    $('billName').value = '';
    $('billAmount').value = '';
    $('billDate').value = '';
    $('billMonth').value = '';
    $('billStartMonth').value = '';
    $('isDebt').checked = false;
    $('isOneOff').checked = false;
    $('totalDebt').value = '';
    $('interestRate').value = '';
    $('termYears').value = '';
    $('termMonths').value = '';
    $('overpayment').value = '';
    toggleDebtFields();
    toggleOneOffFields();
    toggleBillFrequencyOptions();
   
    saveDataToLocalStorage();
    updateBillsList();
    updateHistoryDisplay();
    updateOverview();
    toggleBillTypeVisibility();
    resetCalendarToCurrentMonth();
    ensureDataConsistency();
}

function editBill(billId) {
    const bill = data.bills.find(b => b.id === billId);
    if (!bill) return;
    showEditBillModal(bill);
}

function showEditBillModal(bill) {
    let modal = $('editModal');
    let modalContent;
   
    if (!modal) {
        const modalData = createModal();
        modal = modalData.modal;
        modalContent = modalData.modalContent;
    } else {
        modalContent = $('modalContent');
    }
   
    const dayOptions = Array.from({length: 31}, (_, i) => {
        const day = i + 1;
        return `<option value="${day}"${bill.day === day ? ' selected' : ''}>${day}</option>`;
    }).join('');
   
    const monthOptions = [
        'January', 'February', 'March', 'April', 'May', 'June',
        'July', 'August', 'September', 'October', 'November', 'December'
    ].map((month, i) => {
        const value = i + 1;
        return `<option value="${value}"${bill.month === value ? ' selected' : ''}>${month}</option>`;
    }).join('');
   
    const startMonthOptions = [
        'January', 'February', 'March', 'April', 'May', 'June',
        'July', 'August', 'September', 'October', 'November', 'December'
    ].map((month, i) => {
        const value = i + 1;
        return `<option value="${value}"${bill.startMonth === value ? ' selected' : ''}>${month}</option>`;
    }).join('');
   
    const categoryOptions = [
        'Utilities', 'Housing', 'Transportation', 'Insurance', 'Entertainment',
        'Subscriptions', 'Government', 'Financial', 'Health & Fitness', 'Technology', 'Other'
    ].map(cat =>
        `<option value="${cat}"${bill.category === cat ? ' selected' : ''}>${cat}</option>`
    ).join('');
   
    const generatePayerOptions = (currentBillType, currentPayer) => {
        let options = '';
       
        if (currentBillType === 'joint') {
            options += `<option value="joint"${currentPayer === 'joint' ? ' selected' : ''}>Joint Account</option>`;
        }
       
        data.people.forEach(person => {
            const isSelected = currentPayer == person.id ? ' selected' : '';
            options += `<option value="${person.id}"${isSelected}>${person.name}</option>`;
        });
       
        return options;
    };
   
    const billTypeSection = data.people.length > 1 ? `
        <div class="form-group">
            <label for="editBillType">Bill Type</label>
            <select id="editBillType">
                <option value="individual"${bill.billType === 'individual' ? ' selected' : ''}>Individual</option>
                <option value="joint"${bill.billType === 'joint' ? ' selected' : ''}>Joint</option>
            </select>
        </div>
        <div class="form-group" id="editBillPayerGroup">
            <label for="editBillPayer">Paid By</label>
            <select id="editBillPayer">
                ${generatePayerOptions(bill.billType, bill.payer)}
            </select>
        </div>
    ` : '';
   
    const recurringFieldsHTML = bill.isOneOff ? `
        <div class="form-group">
            <label for="editOneOffDate">Date</label>
            <input type="date" id="editOneOffDate" value="${bill.date}">
            <div id="futureDateWarning" style="display:none;background:#fff3cd;padding:10px;border-radius:5px;margin-top:8px;color:#856404;font-size:12px;border:1px solid:#ffeaa7;">
                Moving to a date in the future will remove the expense from your history until the new day elapses.
            </div>
        </div>
    ` : `
        <div class="form-group">
            <label for="editBillFrequency">Frequency</label>
            <select id="editBillFrequency">
                <option value="monthly"${bill.frequency === 'monthly' ? ' selected' : ''}>Monthly</option>
                <option value="quarterly"${bill.frequency === 'quarterly' ? ' selected' : ''}>Quarterly</option>
                <option value="yearly"${bill.frequency === 'yearly' ? ' selected' : ''}>Yearly</option>
            </select>
        </div>
        <div class="form-group">
            <label for="editBillDate">Due Day of Month</label>
            <select id="editBillDate">
                <option value="">Select day...</option>
                ${dayOptions}
            </select>
        </div>
        <div class="form-group" id="editBillMonthGroup" style="display:${bill.frequency === 'yearly' ? 'block' : 'none'};">
            <label for="editBillMonth">Month</label>
            <select id="editBillMonth">
                ${monthOptions}
            </select>
        </div>
        <div class="form-group" id="editBillStartMonthGroup" style="display:${bill.frequency === 'quarterly' ? 'block' : 'none'};">
            <label for="editBillStartMonth">Start Month</label>
            <select id="editBillStartMonth">
                ${startMonthOptions}
            </select>
        </div>
    `;

    modalContent.innerHTML = `
        <h3 style="margin-bottom:20px;">Edit ${bill.isOneOff ? 'One-off Expense' : 'Bill'}: ${bill.name}</h3>
        <div style="background:#e3f2fd;padding:15px;border-radius:8px;margin:20px 0;color:#1565c0;font-size:12px;border:1px solid #90caf9;">
            <strong>Template Edit:</strong> This will update the bill template and adjust ALL existing payment dates to match the new schedule. To edit only a single payment, use the History tab.
        </div>
        <div class="form-group">
            <label for="editBillName">${bill.isOneOff ? 'Expense' : 'Bill'} Name</label>
            <input type="text" id="editBillName" value="${bill.name}">
        </div>
        <div class="form-group">
            <label for="editBillAmount">Amount</label>
            <input type="number" id="editBillAmount" value="${bill.amount}" step="0.01">
        </div>
        ${recurringFieldsHTML}
        <div class="form-group">
            <label for="editBillCategory">Category</label>
            <select id="editBillCategory">
                ${categoryOptions}
            </select>
        </div>
        ${billTypeSection}
        <div class="checkbox-group" ${bill.isOneOff ? 'style="display:none;"' : ''}>
            <input type="checkbox" id="editIsDebt"${bill.isDebt ? ' checked' : ''} ${bill.isOneOff ? 'disabled' : ''}>
            <label for="editIsDebt">This is a debt/loan</label>
        </div>
        <div id="editDebtFields" style="display:${bill.isDebt && !bill.isOneOff ? 'block' : 'none'};">${bill.isOneOff ? '' : `
            <div class="form-group">
                <label for="editTotalDebt">Total Debt Amount</label>
                <input type="number" id="editTotalDebt" value="${bill.totalDebt || ''}" step="0.01">
            </div>
            <div class="form-group">
                <label for="editInterestRate">Interest Rate (%)</label>
                <input type="number" id="editInterestRate" value="${bill.interestRate || ''}" step="0.01">
            </div>
            <div class="form-group">
                <label for="editTermYears">Term Length Years</label>
                <input type="number" id="editTermYears" value="${bill.termYears || ''}" min="0">
            </div>
            <div class="form-group">
                <label for="editTermMonths">Additional Months</label>
                <input type="number" id="editTermMonths" value="${bill.termMonths || ''}" min="0" max="11">
            </div>
            <div class="form-group">
                <label for="editOverpayment">Monthly Overpayment</label>
                <input type="number" id="editOverpayment" value="${bill.overpayment || ''}" step="0.01">
            </div>`}
        </div>
       
        <div style="display:flex;gap:10px;margin-top:20px;">
            <button id="saveEditBtn" style="flex:1;">Save Changes</button>
            <button id="cancelEditBtn" style="flex:1;background:#666;">Cancel</button>
        </div>
    `;
   
    if (!bill.isOneOff) {
        $('editBillFrequency').addEventListener('change', () => {
            const frequency = $('editBillFrequency').value;
            const monthGroup = $('editBillMonthGroup');
            const startMonthGroup = $('editBillStartMonthGroup');
           
            if (frequency === 'yearly') {
                monthGroup.style.display = 'block';
                startMonthGroup.style.display = 'none';
            } else if (frequency === 'quarterly') {
                monthGroup.style.display = 'none';
                startMonthGroup.style.display = 'block';
            } else {
                monthGroup.style.display = 'none';
                startMonthGroup.style.display = 'none';
            }
        });
       
        $('editIsDebt').addEventListener('change', () => {
            const isDebt = $('editIsDebt').checked;
            const debtFields = $('editDebtFields');
            debtFields.style.display = isDebt ? 'block' : 'none';
        });
    } else {
        const dateInput = $('editOneOffDate');
        const warningDiv = $('futureDateWarning');
        
        dateInput.addEventListener('change', () => {
            const selectedDate = dateInput.value;
            const today = getDateString();
            
            if (selectedDate > today) {
                warningDiv.style.display = 'block';
            } else {
                warningDiv.style.display = 'none';
            }
        });
    }
   
    if (data.people.length > 1) {
        $('editBillType').addEventListener('change', () => {
            const billType = $('editBillType').value;
            const billPayer = $('editBillPayer');
           
            billPayer.innerHTML = '';
           
            if (billType === 'joint') {
                const jointOption = document.createElement('option');
                jointOption.value = 'joint';
                jointOption.textContent = 'Joint Account';
                billPayer.appendChild(jointOption);
            }
           
            data.people.forEach(person => {
                const option = document.createElement('option');
                option.value = person.id;
                option.textContent = person.name;
                billPayer.appendChild(option);
            });
           
            if (billType === 'joint') {
                billPayer.value = 'joint';
            } else if (billPayer.options.length > 0) {
                billPayer.value = data.people[0].id;
            }
        });
    }
   
    $('saveEditBtn').addEventListener('click', () => {
        const name = $('editBillName').value.trim();
        const amount = parseFloat($('editBillAmount').value) || 0;
        let day, month, startMonth, frequency, newDate;
       
        if (bill.isOneOff) {
            const oneOffDate = $('editOneOffDate').value;
            if (!oneOffDate) {
                alert('Please select a date for the one-off expense');
                return;
            }
            newDate = oneOffDate;
        } else {
            frequency = $('editBillFrequency').value;
            day = parseInt($('editBillDate').value);
            month = $('editBillMonth').value ? parseInt($('editBillMonth').value) : null;
            startMonth = $('editBillStartMonth').value ? parseInt($('editBillStartMonth').value) : null;
           
            if (!day) {
                alert('Please select a due day');
                return;
            }
           
            if (frequency === 'yearly' && !month) {
                alert('Please select a month for yearly bills');
                return;
            }
           
            if (frequency === 'quarterly' && !startMonth) {
                alert('Please select a start month for quarterly bills');
                return;
            }
        }
       
        const category = $('editBillCategory').value;
        const billType = data.people.length <= 1 ? 'individual' : $('editBillType').value;
        const isDebt = bill.isOneOff ? false : $('editIsDebt').checked;
       
        let payer;
        if (data.people.length <= 1) {
            payer = data.people[0]?.id;
        } else {
            const selectedPayer = $('editBillPayer').value;
            if (billType === 'joint' && selectedPayer === 'joint') {
                payer = 'joint';
            } else {
                payer = parseInt(selectedPayer);
            }
        }
       
        if (!name || !amount) {
            alert('Please fill in name and amount');
            return;
        }
       
        if (payer !== 'joint' && !data.people.find(p => p.id === payer)) {
            alert('Please select a valid payer');
            return;
        }

        if (bill.isOneOff) {
            const oldDate = bill.date;
            const today = getDateString();
            
            bill.name = name;
            bill.amount = amount;
            bill.category = category;
            bill.billType = billType;
            bill.payer = payer;
            bill.date = getDateString(newDate);
           
            const associatedPayment = data.billPayments.find(p => p.billId === bill.id);
            if (associatedPayment) {
                if (newDate > today) {
                    data.billPayments = data.billPayments.filter(p => p.billId !== bill.id);
                    bill.isDeleted = false;
                    delete bill.deletedDate;
                } else {
                    associatedPayment.billName = name;
                    associatedPayment.amount = amount;
                    associatedPayment.category = category;
                    associatedPayment.billType = billType;
                    associatedPayment.payer = payer;
                    associatedPayment.date = bill.date;
                   
                    if (oldDate !== bill.date && !associatedPayment.status.includes('(date changed)')) {
                        associatedPayment.status += ' (date changed)';
                    }
                }
            }
           
            data.eventHistory.push({
                id: nextEventId++,
                date: getDateString(),
                event: 'One-Off Expense Updated',
                description: `Updated one-off expense: ${name} - ${formatCurrency(amount)}, date: ${bill.date}${newDate > today ? ' (moved to future - removed from history until due)' : ''}`
            });
        } else {
            const oldDay = bill.day;
            const oldMonth = bill.month;
            const oldStartMonth = bill.startMonth;
            const oldFrequency = bill.frequency;
            
            bill.name = name;
            bill.amount = amount;
            bill.frequency = frequency;
            bill.day = day;
            bill.month = month;
            bill.startMonth = frequency === 'quarterly' ? startMonth : null;
            bill.category = category;
            bill.billType = billType;
            bill.payer = payer;
            bill.isDebt = isDebt;
            
            if (isDebt) {
                bill.totalDebt = parseFloat($('editTotalDebt').value) || 0;
                bill.interestRate = parseFloat($('editInterestRate').value) || 0;
                bill.termYears = parseInt($('editTermYears').value) || 0;
                bill.termMonths = parseInt($('editTermMonths').value) || 0;
                bill.overpayment = parseFloat($('editOverpayment').value) || 0;
            } else {
                delete bill.totalDebt;
                delete bill.interestRate;
                delete bill.termYears;
                delete bill.termMonths;
                delete bill.overpayment;
            }
            
            if (oldDay !== day || oldMonth !== month || oldStartMonth !== startMonth || oldFrequency !== frequency) {
                bill.date = updateBillSchedule(bill, day, month, startMonth, frequency);
            } else {
                bill.date = generateBillDate(day, month, frequency, startMonth);
            }
        }
       
        saveDataToLocalStorage();
        updateBillsList();
        updateHistoryDisplay();
        updateOverview();
        updateOneOffOverview();
        resetCalendarToCurrentMonth();
        hideModal();
    });
   
    $('cancelEditBtn').addEventListener('click', hideModal);
   
    showModal();
}

function deleteBill(billId) {
  const bill = data.bills.find(b => b.id === billId);
  if (!bill) return;
 
  const confirmMessage = bill.isOneOff ?
      'Delete this one off expense? This will remove it completely from all records and history.' :
      'Are you sure you want to stop this bill? This will prevent future payments but keep the payment history.';
 
  if (!confirm(confirmMessage)) return;

  const today = getDateString();

  bill.isDeleted = true;
  bill.deletedDate = today;

  if (bill.isOneOff) {
      const relatedPayments = data.billPayments.filter(payment => payment.billId === bill.id);
     
      if (relatedPayments.length > 0) {
          data.billPayments = data.billPayments.filter(payment => payment.billId !== bill.id);
      }
     
      recordEvent('One Off Expense Deleted', `Deleted one-off expense: ${bill.name} - ${formatCurrency(bill.amount + (bill.overpayment || 0))}. All records removed.`);
  } else {
      const futurePayments = data.billPayments.filter(payment =>
          payment.billId === bill.id &&
          payment.date > today
      );

      if (futurePayments.length > 0) {
          data.billPayments = data.billPayments.filter(payment =>
              !(payment.billId === bill.id && payment.date > today)
          );
      }
  }

  if (bill.isDebt) {
      bill.isDebt = false;
      bill.totalDebt = 0;
      bill.interestRate = 0;
      bill.termYears = 0;
      bill.termMonths = 0;
      bill.overpayment = 0;
  }

  saveDataToLocalStorage();
  updateBillsList();
  updateHistoryDisplay();
  updateOverview();
  updateOneOffOverview();
  resetCalendarToCurrentMonth();
  toggleBillTypeVisibility();
  ensureDataConsistency();
}

function getNextBillDueDate(billDate, billDay, frequency, month, startMonth) {
    const currentDate = new Date(billDate);
    const today = new Date();
   
    if (frequency === 'monthly') {
        const nextMonth = currentDate.getMonth() + 1;
        const nextYear = currentDate.getFullYear();
       
        let nextDate = new Date(nextYear, nextMonth, billDay);
       
        if (nextDate.getMonth() !== nextMonth) {
            const lastDayOfMonth = new Date(nextYear, nextMonth + 1, 0).getDate();
            nextDate = new Date(nextYear, nextMonth, Math.min(billDay, lastDayOfMonth));
        }
       
        return nextDate;
    } else if (frequency === 'quarterly') {
        const currentQuarter = Math.floor(currentDate.getMonth() / 3);
        const nextQuarterStartMonth = ((currentQuarter + 1) * 3) % 12;
        const nextYear = currentDate.getFullYear() + (nextQuarterStartMonth === 0 ? 1 : 0);
       
        let nextDate = new Date(nextYear, nextQuarterStartMonth, billDay);
       
        if (nextDate.getMonth() !== nextQuarterStartMonth) {
            const lastDayOfMonth = new Date(nextYear, nextQuarterStartMonth + 1, 0).getDate();
            nextDate = new Date(nextYear, nextQuarterStartMonth, Math.min(billDay, lastDayOfMonth));
        }
       
        return nextDate;
    } else if (frequency === 'yearly') {
        const nextYear = currentDate.getFullYear() + 1;
        let nextDate = new Date(nextYear, month - 1, billDay);
       
        if (nextDate.getMonth() !== month - 1) {
            const lastDayOfMonth = new Date(nextYear, month, 0).getDate();
            nextDate = new Date(nextYear, month - 1, Math.min(billDay, lastDayOfMonth));
        }
       
        return nextDate;
    }
   
    return currentDate;
}

function updateBillsList() {
    const billsList = $('billsList');
    billsList.innerHTML = '';
    
    const today = new Date();
    const currentMonth = today.getMonth();
    const currentYear = today.getFullYear();
   
    const activeBills = data.bills.filter(b => {
        if (b.isDeleted) return false;
        
        if (b.isOneOff) {
            const billDate = new Date(b.date);
            return billDate.getMonth() === currentMonth && billDate.getFullYear() === currentYear;
        }
        
        if (b.isDebt && b.totalDebt <= 0.01) {
            return false;
        }
        
        return true;
    }).map(bill => {
        if (bill.isOneOff) {
            const payment = data.billPayments.find(p => p.billId === bill.id);
            if (payment && payment.date !== bill.date) {
                bill.date = payment.date;
            }
        }
        return bill;
    });
   
    if (data.people.length <= 1) {
        activeBills.forEach(bill => {
            billsList.appendChild(createBillItem(bill));
        });
        return;
    }
   
    const jointBills = activeBills.filter(b => b.billType === 'joint');
    const individualBills = activeBills.filter(b => b.billType === 'individual');
   
    if (jointBills.length > 0) {
        const jointGroup = document.createElement('div');
        jointGroup.className = 'bills-group';
        jointGroup.innerHTML = '<div class="bills-group-header">Joint Bills</div>';
       
        jointBills.forEach(bill => {
            jointGroup.appendChild(createBillItem(bill));
        });
       
        billsList.appendChild(jointGroup);
    }
   
    const peopleWithBills = data.people.filter(person =>
        individualBills.some(bill => bill.payer === person.id)
    );
   
    peopleWithBills.forEach(person => {
        const personBills = individualBills.filter(bill => bill.payer === person.id);
       
        if (personBills.length > 0) {
            const personGroup = document.createElement('div');
            personGroup.className = 'bills-group';
            personGroup.innerHTML = `<div class="bills-group-header">${person.name}'s Bills</div>`;
           
            personBills.forEach(bill => {
                personGroup.appendChild(createBillItem(bill));
            });
           
            billsList.appendChild(personGroup);
        }
    });
}

function createBillItem(bill) {
    const billItem = document.createElement('div');
    billItem.className = 'bill-item';
   
    const payerName = bill.payer === 'joint' ? 'Joint Account' :
                     data.people.find(p => p.id === parseInt(bill.payer))?.name || 'Unknown';
   
    let debtInfo = '';
    if (bill.isDebt && bill.totalDebt > 0) {
        const debtCalc = calculateDebtInfo(bill);
        debtInfo = `
            <div>Total Debt: ${formatCurrency(bill.totalDebt)}</div>
            ${bill.interestRate > 0 ? `<div>Interest Rate: ${bill.interestRate}%</div>` : ''}
            ${bill.termYears > 0 || bill.termMonths > 0 ?
              `<div>Term: ${bill.termYears} years${bill.termMonths > 0 ? `, ${bill.termMonths} months` : ''}</div>` : ''}
            ${bill.overpayment > 0 ? `<div>Overpayment: ${formatCurrency(bill.overpayment)}/month</div>` : ''}
            ${debtCalc && debtCalc.monthlyInterest ?
              `<div>Est. Monthly Interest: ${formatCurrency(debtCalc.monthlyInterest)}</div>` : ''}
            ${debtCalc && debtCalc.payoffMonths ?
              `<div>Est. Payoff: ${Math.floor(debtCalc.payoffMonths / 12)} years ${debtCalc.payoffMonths % 12} months</div>` : ''}
        `;
    }
   
    const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
                       "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    let dueText;
   
    if (bill.isOneOff) {
        const billDate = new Date(bill.date);
        dueText = `${billDate.getDate()} ${monthNames[billDate.getMonth()]} ${billDate.getFullYear()}`;
    } else if (bill.frequency === 'yearly' && bill.month) {
        dueText = `Day ${bill.day} of ${monthNames[bill.month - 1]}`;
    } else if (bill.frequency === 'quarterly' && bill.startMonth) {
        dueText = `Day ${bill.day}, starting ${monthNames[bill.startMonth - 1]}`;
    } else {
        dueText = `Day ${bill.day} of month`;
    }
   
    billItem.innerHTML = `
        <div class="bill-info">
            <strong>${bill.name}</strong>
            <div>Amount: ${formatCurrency(bill.amount)}/${bill.frequency}${bill.overpayment > 0 ? ` + ${formatCurrency(bill.overpayment)} overpayment` : ''}</div>
            <div>Total: ${formatCurrency(bill.amount + (bill.overpayment || 0))}/${bill.frequency}</div>
            <div>Due: ${dueText}</div>
            <div>Category: ${bill.category}</div>
            ${data.people.length > 1 ? `<div>Type: ${bill.billType}</div>` : ''}
            ${data.people.length > 1 ? `<div>Paid by: ${payerName}</div>` : ''}
            ${bill.isDebt ? '<div>Type: Debt/Loan</div>' : ''}
            ${debtInfo}
        </div>
        <div class="bill-actions">
            <button class="btn-small" onclick="editBill(${bill.id})">Edit</button>
            <button class="btn-danger btn-small" onclick="deleteBill(${bill.id})">Delete</button>
        </div>
    `;
   
    return billItem;
}

function updateOverview() {
    const today = new Date();
    const currentYear = today.getFullYear();
    const currentMonth = today.getMonth();
   
    const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
    let incomeTotal = 0;
    let billsTotal = 0;
   
    for (let day = 1; day <= daysInMonth; day++) {
        const dayDate = new Date(currentYear, currentMonth, day);
        const dayEvents = getDayEvents(dayDate);
       
        const billItems = getBillItemsFromEvents(dayEvents);
        billItems.forEach(bill => {
            billsTotal += bill.amount;
        });
       
        const oneOffItems = getOneOffItemsFromEvents(dayEvents);
        oneOffItems.forEach(oneOff => {
            billsTotal += oneOff.amount;
        });
       
        const paydayItems = getPaydayItemsFromEvents(dayEvents);
        paydayItems.forEach(payday => {
            incomeTotal += payday.amount;
        });
       
        const bonusItems = getBonusItemsFromEvents(dayEvents);
        bonusItems.forEach(bonus => {
            incomeTotal += bonus.amount;
        });
    }
   
    const totalMonthlySavings = data.people.reduce((sum, person) => sum + (person.savings || 0), 0);
    const totalMonthlyExpenses = data.people.reduce((sum, person) => sum + (person.expenses || 0), 0);
   
    const leftover = incomeTotal - billsTotal - totalMonthlySavings - totalMonthlyExpenses;
   
    $('totalIncome').textContent = formatCurrency(incomeTotal);
    $('totalBills').textContent = formatCurrency(billsTotal);
    $('totalSavings').textContent = formatCurrency(totalMonthlySavings);
    $('totalLeftover').textContent = formatCurrency(leftover);
   
    $('billsPercentage').textContent = incomeTotal ?
        `${((billsTotal / incomeTotal) * 100).toFixed(1)}%` : '0%';
    $('savingsPercentage').textContent = incomeTotal ?
        `${((totalMonthlySavings / incomeTotal) * 100).toFixed(1)}%` : '0%';
    $('leftoverPercentage').textContent = incomeTotal ?
        `${((leftover / incomeTotal) * 100).toFixed(1)}%` : '0%';
   
    updatePeopleOverview();
    updateDebtOverview();
    updateOneOffOverview();
    updateTransfersOverview();
    resetCalendarToCurrentMonth();
    data.people.forEach(p => updatePersonOverview(p.id));
}

function getBillItemsFromEvents(dayEvents) {
   if (!dayEvents.billText) return [];
   
   const billItems = [];
   const billTextWithoutHTML = dayEvents.billText.replace(/<[^>]*>/g, '|');
   const billParts = billTextWithoutHTML.split('|').filter(part => part.trim() && part.includes(':'));
   
   billParts.forEach(part => {
       const nameAmountParts = part.split(':');
       if (nameAmountParts.length === 2) {
           const name = nameAmountParts[0].trim().replace(/\s*\(edited\)\s*$/, '');
           const amountStr = nameAmountParts[1].trim();
           const amount = parseFloat(amountStr.replace(/[£$€¥,]/g, '')) || 0;
           
           billItems.push({ name, amount });
       }
   });
   
   return billItems;
}

function getOneOffItemsFromEvents(dayEvents) {
   if (!dayEvents.oneOffText) return [];
   
   const oneOffItems = [];
   const oneOffTextWithoutHTML = dayEvents.oneOffText.replace(/<[^>]*>/g, '|');
   const oneOffParts = oneOffTextWithoutHTML.split('|').filter(part => part.trim() && part.includes(':'));
   
   oneOffParts.forEach(part => {
       const nameAmountParts = part.split(':');
       if (nameAmountParts.length === 2) {
           const name = nameAmountParts[0].trim();
           const amountStr = nameAmountParts[1].trim();
           const amount = parseFloat(amountStr.replace(/[£$€¥,]/g, '')) || 0;
           
           oneOffItems.push({ name, amount });
       }
   });
   
   return oneOffItems;
}

function updatePeopleOverview() {
    const container = $('peopleOverview');
    container.innerHTML = '';
    const hasJointBills = data.bills.some(b => b.billType === 'joint' && !b.isDeleted);
   
    const today = new Date();
    const currentMonth = today.getMonth();
    const currentYear = today.getFullYear();
   
    data.people.forEach(person => {
        const monthlyIncome = calculateMonthlyBudget(person);
        const monthlySavings = person.savings || 0;
        const monthlyExpenses = person.expenses || 0;
       
        const individualBills = data.bills
            .filter(b => b.billType === 'individual' && b.payer === person.id && !b.isDeleted);
       
        let individualBillsMonthly = 0;
        let quarterlySetAside = 0;
        let yearlySetAside = 0;
       
        individualBills.forEach(bill => {
            const totalAmount = bill.amount + (bill.overpayment || 0);
            if (bill.isOneOff) {
                const billDate = new Date(bill.date);
                if (billDate.getMonth() === currentMonth && billDate.getFullYear() === currentYear) {
                    individualBillsMonthly += totalAmount;
                }
            } else if (bill.frequency === 'monthly') {
                individualBillsMonthly += totalAmount;
            } else if (bill.frequency === 'quarterly') {
                quarterlySetAside += calculateSetAsideAmount(totalAmount, 'quarterly', bill.isDebt, bill.interestRate, bill.totalDebt);
            } else if (bill.frequency === 'yearly') {
                yearlySetAside += calculateSetAsideAmount(totalAmount, 'yearly', bill.isDebt, bill.interestRate, bill.totalDebt);
            }
        });
       
        let jointBillsShare = 0;
        let jointQuarterlySetAside = 0;
        let jointYearlySetAside = 0;
       
        const jointBills = data.bills.filter(b => b.billType === 'joint' && !b.isDeleted);
        jointBills.forEach(bill => {
            const totalAmount = bill.amount + (bill.overpayment || 0);
            const personShare = calculateWeightedShare(totalAmount, person.id, data.weightedBills);
           
            if (bill.isOneOff) {
                const billDate = new Date(bill.date);
                if (billDate.getMonth() === currentMonth && billDate.getFullYear() === currentYear) {
                    jointBillsShare += personShare;
                }
            } else if (bill.frequency === 'monthly') {
                jointBillsShare += personShare;
            } else if (bill.frequency === 'quarterly') {
                const setAsideAmount = calculateSetAsideAmount(totalAmount, 'quarterly', bill.isDebt, bill.interestRate, bill.totalDebt);
                jointQuarterlySetAside += calculateWeightedShare(setAsideAmount, person.id, data.weightedBills);
            } else if (bill.frequency === 'yearly') {
                const setAsideAmount = calculateSetAsideAmount(totalAmount, 'yearly', bill.isDebt, bill.interestRate, bill.totalDebt);
                jointYearlySetAside += calculateWeightedShare(setAsideAmount, person.id, data.weightedBills);
            }
        });
       
        const totalQuarterlySetAside = quarterlySetAside + jointQuarterlySetAside;
        const totalYearlySetAside = yearlySetAside + jointYearlySetAside;
       
        const netMonthly = monthlyIncome - monthlySavings - monthlyExpenses - individualBillsMonthly -
                          jointBillsShare - totalQuarterlySetAside - totalYearlySetAside;
       
        const personCard = document.createElement('div');
        personCard.className = 'person-card';
        personCard.innerHTML = `
            <h3><span class="person-color-dot" style="background-color: ${person.color || colorPalette[0].value}"></span>${person.name}</h3>
            <div class="person-info">
                <div class="info-item">
                    <span class="info-label">Monthly Income</span>
                    <span class="info-value">${formatCurrency(monthlyIncome)}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Monthly Savings</span>
                    <span class="info-value">${formatCurrency(monthlySavings)}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Monthly Expenses</span>
                    <span class="info-value">${formatCurrency(monthlyExpenses)}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">${data.people.length === 1 ? 'Monthly Bills' : 'Individual Monthly Bills'}</span>
                    <span class="info-value">${formatCurrency(individualBillsMonthly)}</span>
                </div>
                ${totalQuarterlySetAside > 0 ? `
                    <div class="info-item">
                        <span class="info-label">Set aside for Quarterly Bills</span>
                        <span class="info-value">${formatCurrency(totalQuarterlySetAside)}/month</span>
                    </div>
                ` : ''}
                ${totalYearlySetAside > 0 ? `
                    <div class="info-item">
                        <span class="info-label">Set aside for Yearly Bills</span>
                        <span class="info-value">${formatCurrency(totalYearlySetAside)}/month</span>
                    </div>
                ` : ''}
                ${hasJointBills ? `
                    <div class="info-item">
                        <span class="info-label">Joint Monthly Bills</span>
                        <span class="info-value">${formatCurrency(jointBillsShare)}</span>
                    </div>
                ` : ''}
                <div class="info-item">
                    <span class="info-label">Net Monthly</span>
                    <span class="info-value">${formatCurrency(netMonthly)}</span>
                </div>
            </div>
        `;
       
        container.appendChild(personCard);
    });
}

function updateDebtOverview() {
    const debtsList = $('debtsList');
    const debtOverview = $('debtOverview');
    const debts = data.bills.filter(b => b.isDebt && b.totalDebt > 0.01 && !b.isDeleted);

    if (debts.length === 0) {
        debtOverview.style.display = 'none';
        return;
    }

    debtOverview.style.display = 'block';
    debtsList.innerHTML = '';

    if (data.people.length <= 1) {
        debts.forEach(debt => {
            debtsList.appendChild(createDebtItem(debt));
        });
        return;
    }

    const jointDebts = debts.filter(d => d.billType === 'joint');
    const individualDebts = debts.filter(d => d.billType === 'individual');

    if (jointDebts.length > 0) {
        const jointGroup = document.createElement('div');
        jointGroup.className = 'bills-group';
        jointGroup.innerHTML = '<div class="bills-group-header">Joint Debts</div>';
       
        jointDebts.forEach(debt => {
            jointGroup.appendChild(createDebtItem(debt));
        });
       
        debtsList.appendChild(jointGroup);
    }

    const peopleWithDebts = data.people.filter(person =>
        individualDebts.some(debt => debt.payer === person.id)
    );

    peopleWithDebts.forEach(person => {
        const personDebts = individualDebts.filter(debt => debt.payer === person.id);
       
        if (personDebts.length > 0) {
            const personGroup = document.createElement('div');
            personGroup.className = 'bills-group';
            personGroup.innerHTML = `<div class="bills-group-header">${person.name}'s Debts</div>`;
           
            personDebts.forEach(debt => {
                personGroup.appendChild(createDebtItem(debt));
            });
           
            debtsList.appendChild(personGroup);
        }
    });
}

function createDebtItem(debt) {
    const monthlyPayment = frequencyToMonthly(debt.amount, debt.frequency);
    const totalWithOverpayment = monthlyPayment + (debt.overpayment || 0);
    const debtCalc = calculateDebtInfo(debt);

    const debtItem = document.createElement('div');
    debtItem.className = 'debt-item';
    debtItem.innerHTML = `
        <div class="info-item">
            <span class="info-label">${debt.name}</span>
            <span class="info-value">${formatCurrency(debt.totalDebt)}${debt.interestRate > 0 ? ` @ ${debt.interestRate}%` : ''}</span>
        </div>
        <div class="info-item">
            <span class="info-label">Monthly Payment</span>
            <span class="info-value">${formatCurrency(totalWithOverpayment)}</span>
        </div>
        ${debtCalc && debtCalc.monthlyInterest ? `
            <div class="info-item">
                <span class="info-label">Est. Monthly Interest</span>
                <span class="info-value">${formatCurrency(debtCalc.monthlyInterest)} (estimate)</span>
            </div>
        ` : ''}
        ${debtCalc && debtCalc.payoffMonths ? `
            <div class="info-item">
                <span class="info-label">Est. Payoff Time</span>
                <span class="info-value">${Math.floor(debtCalc.payoffMonths / 12)} years ${debtCalc.payoffMonths % 12} months</span>
            </div>
        ` : ''}
        ${debtCalc && debtCalc.overpaymentSavings > 0 && debtCalc.termReduction > 0 ? `
            <div class="info-item">
                <span class="info-label">Overpayment Benefit</span>
                <span class="info-value">Saves ${Math.floor(debtCalc.termReduction / 12)} years ${debtCalc.termReduction % 12} months, ${formatCurrency(debtCalc.interestSaved)} interest</span>
            </div>
        ` : ''}
    `;

    return debtItem;
}

function updateTransfersOverview() {
    const transfersOverview = $('transfersOverview');
    const transfers = calculateJointBillTransfers();
   
    if (transfers.length === 0 || data.people.length <= 1 || !data.bills.some(b => b.billType === 'joint' && !b.isDeleted)) {
        transfersOverview.style.display = 'none';
        return;
    }
   
    transfersOverview.style.display = 'grid';
    transfersOverview.innerHTML = '';
   
    if (data.people.length === 2) {
        data.people.forEach(person => {
            const personTransfers = transfers.filter(t => t.from === person.name);
            const card = document.createElement('div');
            card.className = 'payment-transfers';
            card.innerHTML = `<h3>${person.name}'s Monthly Transfers</h3>`;
           
            if (personTransfers.length === 0) {
                card.innerHTML += '<p>No transfers required this month.</p>';
            } else {
                let totalAmount = 0;
               
                personTransfers.forEach(t => {
                    const transferItem = document.createElement('div');
                    transferItem.className = 'transfer-item';
                    transferItem.innerHTML = `
                        <span>Send to ${t.to}</span>
                        <span>${formatCurrency(t.amount)}</span>
                    `;
                    card.appendChild(transferItem);
                    totalAmount += t.amount;
                });
               
                if (personTransfers.length > 1) {
                    const totalItem = document.createElement('div');
                    totalItem.className = 'transfer-item';
                    totalItem.style.fontWeight = '600';
                    totalItem.innerHTML = `
                        <span>Total</span>
                        <span>${formatCurrency(totalAmount)}</span>
                    `;
                    card.appendChild(totalItem);
                }
            }
           
            transfersOverview.appendChild(card);
        });
    } else {
        const card = document.createElement('div');
        card.className = 'payment-transfers';
        card.innerHTML = '<h3>Monthly Required Transfers</h3>';
       
        const transfersByPerson = {};
       
        transfers.forEach(t => {
            if (!transfersByPerson[t.from]) {
                transfersByPerson[t.from] = [];
            }
            transfersByPerson[t.from].push(t);
        });
       
        Object.keys(transfersByPerson).forEach(fromPerson => {
            const personTransfers = transfersByPerson[fromPerson];
            let totalAmount = 0;
           
            personTransfers.forEach(t => {
                const transferItem = document.createElement('div');
                transferItem.className = 'transfer-item';
                transferItem.innerHTML = `
                    <span>${t.from} sends to ${t.to}</span>
                    <span>${formatCurrency(t.amount)}</span>
                `;
                card.appendChild(transferItem);
                totalAmount += t.amount;
            });
           
            if (personTransfers.length > 1) {
                const totalItem = document.createElement('div');
                totalItem.className = 'transfer-item';
                totalItem.style.fontWeight = '600';
                totalItem.innerHTML = `
                    <span>${fromPerson} Total</span>
                    <span>${formatCurrency(totalAmount)}</span>
                `;
                card.appendChild(totalItem);
            }
           
            if (Object.keys(transfersByPerson).length > 1 && fromPerson !== Object.keys(transfersByPerson)[Object.keys(transfersByPerson).length - 1]) {
                const spacerItem = document.createElement('div');
                spacerItem.style.height = '16px';
                card.appendChild(spacerItem);
            }
        });
       
        transfersOverview.appendChild(card);
    }
}

function createPersonTab(person) {
    if (!person || !person.id || !person.name) return;
   
    const existingTab = document.querySelector(`button.tab[data-person-id="${person.id}"]`);
    if (existingTab) return;
   
    const tabsContainer = $('tabsContainer');
    const historyTab = document.querySelector('.tab[data-tab="history"]');
   
    const tab = document.createElement('button');
    tab.className = 'tab';
    tab.textContent = person.name;
    tab.dataset.personId = person.id;
    tab.addEventListener('click', () => showTab(`person-${person.id}`));
   
    tabsContainer.insertBefore(tab, historyTab);
   
    const content = document.createElement('div');
    content.id = `person-${person.id}`;
    content.className = 'tab-content';
   
    const userSettingsHTML = `
        <div class="card">
            <h3>${person.name} - User Settings</h3>
            <div class="form-group">
                <label for="name-${person.id}">Name</label>
                <input type="text" id="name-${person.id}" value="${person.name}">
            </div>
            <div style="display:flex;gap:10px;margin-top:20px;">
                <button onclick="updatePersonBasic(${person.id})" style="flex:1;">Update Name</button>
                <button onclick="showColorModal(${person.id})" style="flex:1; background-color: ${person.color || colorPalette[0].value}; color: #ffffff;">Change Colour</button>
                <button onclick="deletePerson(${person.id})" class="btn-danger" style="flex:1;">Delete</button>
            </div>
        </div>
    `;
   
    const incomeHTML = `
		<div class="card">
			<h3>${person.name} - Income</h3>
			<div class="form-group">
				<label for="income-${person.id}">Income Amount</label>
				<input type="number" id="income-${person.id}" value="${person.income || 0}" placeholder="0.00" step="0.01">
			</div>
			<div class="form-group">
				<label for="frequency-${person.id}">Payment Frequency</label>
				<select id="frequency-${person.id}">
					<option value="biweekly"${person.frequency === 'biweekly' ? ' selected' : ''}>Biweekly</option>
					<option value="monthly"${person.frequency === 'monthly' ? ' selected' : ''}>Monthly</option>
					<option value="quarterly"${person.frequency === 'quarterly' ? ' selected' : ''}>Quarterly</option>
					<option value="yearly"${person.frequency === 'yearly' ? ' selected' : ''}>Yearly</option>
				</select>
			</div>
			<div class="form-group">
				<label for="paymentDate-${person.id}">Payment Start Date</label>
				<input type="date" id="paymentDate-${person.id}" value="${person.paymentDate || ''}"
					   onchange="validateIncomeDate(this)">
			</div>
			<div class="form-group">
				<label for="employer-${person.id}">Employer (Optional)</label>
				<input type="text" id="employer-${person.id}" value="${person.employer || ''}" placeholder="Company name">
			</div>
			<button onclick="updatePersonIncome(${person.id})">Update Income</button>
			<p style="font-size:12px;color:#666;margin-top:10px;">
				Set a future start date to change your income from that date forward. Past payments will remain unchanged.
			</p>
		</div>
	`;
   
    const savingsExpensesHTML = `
        <div class="card">
            <h3>${person.name} - Ongoing Monthly Goals</h3>
            <div class="form-group">
                <label for="savings-${person.id}">Monthly Savings Goal</label>
                <input type="number" id="savings-${person.id}" value="${person.savings || 0}" placeholder="0.00" step="0.01">
            </div>
            <div class="form-group">
                <label for="expenses-${person.id}">Monthly Expenses</label>
                <p style="font-size:12px;color:#666;margin-top:10px;">This is how much you should leave in your main account to spend on Food, Petrol, Clothes etc.</p>
                <div style="height:10px;"></div>
                <input type="number" id="expenses-${person.id}" value="${person.expenses || 0}" placeholder="0.00" step="0.01">
            </div>
            <button onclick="updatePersonSavingsExpenses(${person.id})">Update Monthly Goals</button>
            <p style="font-size:12px;color:#666;margin-top:10px;">These goals will continue each month unless you update them.</p>
        </div>
    `;
   
    const paycheckHTML = `
        <div class="card">
            <h3>${person.name} - Add Historical Salary</h3>
            <div class="form-group">
                <label for="paycheckAmount-${person.id}">Paycheck Amount</label>
                <input type="number" id="paycheckAmount-${person.id}" placeholder="0.00" step="0.01">
            </div>
            <div class="form-group">
                <label for="paycheckDate-${person.id}">Date</label>
                <input type="date" id="paycheckDate-${person.id}" max="${new Date().toISOString().split('T')[0]}">
            </div>
            <div class="form-group">
                <label for="paycheckEmployer-${person.id}">Employer (Optional)</label>
                <input type="text" id="paycheckEmployer-${person.id}" placeholder="Company name">
            </div>
            <button onclick="addPaycheck(${person.id})" class="add-paycheck-btn">Add Salary Entry</button>
            <p style="font-size:12px;color:#666;margin-top:10px;">These are stored in the Income History below and the History tab.</p>
        </div>
    `;
   
    const bonusHTML = `
        <div class="card">
            <h3>${person.name} - Add One-time Bonus</h3>
            <div class="form-group">
                <label for="bonusAmount-${person.id}">Bonus Amount</label>
                <input type="number" id="bonusAmount-${person.id}" placeholder="0.00" step="0.01">
            </div>
            <div class="form-group">
                <label for="bonusDate-${person.id}">Date Received</label>
                <input type="date" id="bonusDate-${person.id}" max="${new Date().toISOString().split('T')[0]}">
            </div>
            <div class="form-group">
                <label for="bonusEmployer-${person.id}">Source (Optional)</label>
                <input type="text" id="bonusEmployer-${person.id}" placeholder="Company or source">
            </div>
            <button onclick="addBonus(${person.id})" class="add-bonus-btn">Add One-time Bonus</button>
            <p style="font-size:12px;color:#666;margin-top:10px;">Bonuses are a one-time addition and will affect the total income for the month they were received.</p>
        </div>
    `;
   
    content.innerHTML = userSettingsHTML + incomeHTML + savingsExpensesHTML + paycheckHTML + bonusHTML + createYearlyIncomeView(person.id);
    document.querySelector('.container').appendChild(content);
   
    const changeColorBtn = content.querySelector(`button[onclick*="showColorModal"]`);
    if (changeColorBtn && person.color) {
        changeColorBtn.style.backgroundColor = person.color;
        changeColorBtn.style.color = '#ffffff';
    }
   
    const personTab = document.querySelector(`button.tab[data-person-id="${person.id}"]`);
    if (personTab && person.color) {
        if (personTab.classList.contains('active')) {
            personTab.style.backgroundColor = person.color;
            personTab.style.color = '#ffffff';
        } else {
            personTab.style.backgroundColor = '';
            personTab.style.color = '';
        }
    }
   
    updatePersonOverview(person.id);
}

function validateIncomeDate(input) {
    return true;
}

function updatePersonBasic(personId) {
    const person = data.people.find(p => p.id === personId);
    if (!person) return;
   
    const oldName = person.name;
    const name = $(`name-${personId}`).value.trim();
   
    if (!name) {
        alert('Name is required');
        return;
    }
   
    if (data.people.some(p => p.id !== personId && p.name.toLowerCase() === name.toLowerCase())) {
        alert('A person with this name already exists!');
        return;
    }
   
    person.name = name;
   
    data.eventHistory.push({
        id: nextEventId++,
        date: new Date().toISOString().split('T')[0],
        event: 'Person Updated',
        description: `Updated ${name}'s basic settings`
    });
   
    saveDataToLocalStorage();
    updateGreeting();
    updateBillPayerOptions();
    updateHistoryDisplay();
    updateOverview();
   
    const personalTab = document.querySelector(`button.tab[data-person-id="${personId}"]`);
    if (personalTab) personalTab.textContent = name;
   
    const h3Elements = document.querySelectorAll(`#person-${personId} h3`);
    h3Elements.forEach(h3 => {
        if (h3.textContent.includes(' - ')) {
            const parts = h3.textContent.split(' - ');
            h3.textContent = `${name} - ${parts[1]}`;
        }
    });
}

function attachPersonEventListeners() {
    document.querySelectorAll('.tab[data-person-id]').forEach(tab => {
        if (!tab.onclick && !tab.hasEventListener) {
            const personId = tab.dataset.personId;
            tab.addEventListener('click', () => showTab(`person-${personId}`));
            tab.hasEventListener = true;
        }
    });
   
    data.people.forEach(person => {
        const personId = person.id;
       
        const updateBasicBtn = $(`updateBasicBtn${personId}`);
        if (updateBasicBtn && !updateBasicBtn.onclick) {
            updateBasicBtn.onclick = () => updatePersonBasic(personId);
        }
       
        const updateIncomeBtn = $(`updateIncomeBtn${personId}`);
        if (updateIncomeBtn && !updateIncomeBtn.onclick) {
            updateIncomeBtn.onclick = () => updatePersonIncome(personId);
        }
       
        const updateSavingsExpensesBtn = $(`updateSavingsExpensesBtn${personId}`);
        if (updateSavingsExpensesBtn && !updateSavingsExpensesBtn.onclick) {
            updateSavingsExpensesBtn.onclick = () => updatePersonSavingsExpenses(personId);
        }
       
        const deletePersonBtn = $(`deletePersonBtn${personId}`);
        if (deletePersonBtn && !deletePersonBtn.onclick) {
            deletePersonBtn.onclick = () => deletePerson(personId);
        }
       
        const addPaycheckBtn = $(`addPaycheckBtn${personId}`);
        if (addPaycheckBtn && !addPaycheckBtn.onclick) {
            addPaycheckBtn.onclick = () => addPaycheck(personId);
        }
       
        const addBonusBtn = $(`addBonusBtn${personId}`);
        if (addBonusBtn && !addBonusBtn.onclick) {
            addBonusBtn.onclick = () => addBonus(personId);
        }
    });
}

function updateOneOffOverview() {
    const oneOffList = $('oneOffList');
    const oneOffOverview = $('oneOffOverview');
    const today = new Date();
    const currentMonth = today.getMonth();
    const currentYear = today.getFullYear();
   
    const oneOffExpenses = data.bills.filter(b =>
        b.isOneOff &&
        !b.isDeleted &&
        (() => {
            const billDate = new Date(b.date);
            return billDate.getMonth() === currentMonth && billDate.getFullYear() === currentYear;
        })()
    );

    if (oneOffExpenses.length === 0) {
        oneOffOverview.style.display = 'none';
        return;
    }

    oneOffOverview.style.display = 'block';
    oneOffList.innerHTML = '';

    if (data.people.length <= 1) {
        oneOffExpenses.forEach(expense => {
            oneOffList.appendChild(createOneOffItem(expense));
        });
        return;
    }

    const jointOneOffs = oneOffExpenses.filter(e => e.billType === 'joint');
    const individualOneOffs = oneOffExpenses.filter(e => e.billType === 'individual');

    if (jointOneOffs.length > 0) {
        const jointGroup = document.createElement('div');
        jointGroup.className = 'bills-group';
        jointGroup.innerHTML = '<div class="bills-group-header">Joint One-off Expenses</div>';
       
        jointOneOffs.forEach(expense => {
            jointGroup.appendChild(createOneOffItem(expense));
        });
       
        oneOffList.appendChild(jointGroup);
    }

    const peopleWithOneOffs = data.people.filter(person =>
        individualOneOffs.some(expense => expense.payer === person.id)
    );

    peopleWithOneOffs.forEach(person => {
        const personOneOffs = individualOneOffs.filter(expense => expense.payer === person.id);
       
        if (personOneOffs.length > 0) {
            const personGroup = document.createElement('div');
            personGroup.className = 'bills-group';
            personGroup.innerHTML = `<div class="bills-group-header">${person.name}'s One-off Expenses</div>`;
           
            personOneOffs.forEach(expense => {
                personGroup.appendChild(createOneOffItem(expense));
            });
           
            oneOffList.appendChild(personGroup);
        }
    });
}

function initializePersonHistoryTracking() {
    data.people.forEach(person => {
        if (!person.savingsHistory) person.savingsHistory = [];
        if (!person.expensesHistory) person.expensesHistory = [];
        if (!person.incomeChangeHistory) person.incomeChangeHistory = [];
        if (!person.employerHistory) person.employerHistory = [];
        if (!person.colorHistory) person.colorHistory = [];
    });
   
    if (!data.billHistory) data.billHistory = [];
    if (!data.billHistoryId) data.billHistoryId = 1;
    if (!data.uiPreferences) {
        data.uiPreferences = {
            lastViewedTab: "overview",
            lastViewedMonth: new Date().getMonth(),
            lastViewedYear: new Date().getFullYear(),
            collapsedSections: [],
            preferredDateFormat: "DD/MM/YYYY"
        };
    }
    if (!data.dataVersion) data.dataVersion = "1.0";
}

function recordBillHistoryEntry(bill, action, details = {}) {
    const historyEntry = {
        id: data.billHistoryId++,
        billId: bill.id,
        billName: bill.name,
        action: action,
        date: new Date().toISOString().split('T')[0],
        timestamp: new Date().toISOString(),
        previousData: details.previousData || null,
        newData: details.newData || null,
        amount: details.amount || bill.amount,
        payerName: details.payerName || (bill.payer === 'joint' ? 'Joint Account' : data.people.find(p => p.id === bill.payer)?.name),
        category: bill.category,
        frequency: bill.frequency,
        billType: bill.billType,
        notes: details.notes || '',
        debtBalance: bill.isDebt ? bill.totalDebt : null,
        interestPaid: details.interestPaid || null,
        principalPaid: details.principalPaid || null
    };
   
    data.billHistory.push(historyEntry);
    saveDataToLocalStorage();
}

function getBillHistory(billId = null, action = null, startDate = null, endDate = null) {
    let filtered = data.billHistory || [];
   
    if (billId) filtered = filtered.filter(h => h.billId === billId);
    if (action) filtered = filtered.filter(h => h.action === action);
    if (startDate) filtered = filtered.filter(h => h.date >= startDate);
    if (endDate) filtered = filtered.filter(h => h.date <= endDate);
   
    return filtered.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
}

function recordSavingsChange(personId, previousAmount, newAmount, reason = 'Manual update') {
    const person = data.people.find(p => p.id === personId);
    if (!person) return;
   
    if (!person.savingsHistory) person.savingsHistory = [];
   
    const historyEntry = {
        id: (person.savingsHistory.length > 0 ? Math.max(...person.savingsHistory.map(h => h.id)) + 1 : 1),
        date: new Date().toISOString().split('T')[0],
        timestamp: new Date().toISOString(),
        previousAmount: previousAmount,
        newAmount: newAmount,
        difference: newAmount - previousAmount,
        reason: reason,
        effectiveMonth: new Date().toISOString().substring(0, 7),
        percentageChange: previousAmount > 0 ? ((newAmount - previousAmount) / previousAmount * 100) : 0
    };
   
    person.savingsHistory.push(historyEntry);
    saveDataToLocalStorage();
}

function recordExpensesChange(personId, previousAmount, newAmount, reason = 'Manual update') {
    const person = data.people.find(p => p.id === personId);
    if (!person) return;
   
    if (!person.expensesHistory) person.expensesHistory = [];
   
    const historyEntry = {
        id: (person.expensesHistory.length > 0 ? Math.max(...person.expensesHistory.map(h => h.id)) + 1 : 1),
        date: new Date().toISOString().split('T')[0],
        timestamp: new Date().toISOString(),
        previousAmount: previousAmount,
        newAmount: newAmount,
        difference: newAmount - previousAmount,
        reason: reason,
        effectiveMonth: new Date().toISOString().substring(0, 7),
        percentageChange: previousAmount > 0 ? ((newAmount - previousAmount) / previousAmount * 100) : 0
    };
   
    person.expensesHistory.push(historyEntry);
    saveDataToLocalStorage();
}

function getSavingsHistory(personId, startDate = null, endDate = null) {
    const person = data.people.find(p => p.id === personId);
    if (!person || !person.savingsHistory) return [];
   
    let filtered = person.savingsHistory;
    if (startDate) filtered = filtered.filter(h => h.date >= startDate);
    if (endDate) filtered = filtered.filter(h => h.date <= endDate);
   
    return filtered.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
}

function getExpensesHistory(personId, startDate = null, endDate = null) {
    const person = data.people.find(p => p.id === personId);
    if (!person || !person.expensesHistory) return [];
   
    let filtered = person.expensesHistory;
    if (startDate) filtered = filtered.filter(h => h.date >= startDate);
    if (endDate) filtered = filtered.filter(h => h.date <= endDate);
   
    return filtered.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
}

function recordIncomeChange(personId, previousIncome, newIncome, previousFrequency, newFrequency, previousPaymentDate, newPaymentDate, reason = 'Manual update') {
    const person = data.people.find(p => p.id === personId);
    if (!person) return;
   
    if (!person.incomeChangeHistory) person.incomeChangeHistory = [];
   
    const previousMonthly = frequencyToMonthly(previousIncome || 0, previousFrequency);
    const newMonthly = frequencyToMonthly(newIncome || 0, newFrequency);
   
    const historyEntry = {
        id: (person.incomeChangeHistory.length > 0 ? Math.max(...person.incomeChangeHistory.map(h => h.id)) + 1 : 1),
        date: new Date().toISOString().split('T')[0],
        timestamp: new Date().toISOString(),
        previousIncome: previousIncome,
        newIncome: newIncome,
        previousFrequency: previousFrequency,
        newFrequency: newFrequency,
        previousPaymentDate: previousPaymentDate,
        newPaymentDate: newPaymentDate,
        previousMonthlyEquivalent: previousMonthly,
        newMonthlyEquivalent: newMonthly,
        monthlyDifference: newMonthly - previousMonthly,
        percentageChange: previousMonthly > 0 ? ((newMonthly - previousMonthly) / previousMonthly * 100) : 0,
        reason: reason,
        effectiveMonth: new Date().toISOString().substring(0, 7),
        annualImpact: (newMonthly - previousMonthly) * 12
    };
   
    person.incomeChangeHistory.push(historyEntry);
    saveDataToLocalStorage();
}

function recordEmployerChange(personId, previousEmployer, newEmployer, reason = 'Manual update') {
    const person = data.people.find(p => p.id === personId);
    if (!person) return;
   
    if (!person.employerHistory) person.employerHistory = [];
   
    const historyEntry = {
        id: (person.employerHistory.length > 0 ? Math.max(...person.employerHistory.map(h => h.id)) + 1 : 1),
        date: new Date().toISOString().split('T')[0],
        timestamp: new Date().toISOString(),
        previousEmployer: previousEmployer || '',
        newEmployer: newEmployer || '',
        reason: reason,
        isNewJob: !previousEmployer && newEmployer,
        isJobLoss: previousEmployer && !newEmployer,
        isJobChange: previousEmployer && newEmployer && previousEmployer !== newEmployer
    };
   
    person.employerHistory.push(historyEntry);
    saveDataToLocalStorage();
}

function getIncomeHistory(personId, startDate = null, endDate = null) {
    const person = data.people.find(p => p.id === personId);
    if (!person || !person.incomeChangeHistory) return [];
   
    let filtered = person.incomeChangeHistory;
    if (startDate) filtered = filtered.filter(h => h.date >= startDate);
    if (endDate) filtered = filtered.filter(h => h.date <= endDate);
   
    return filtered.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
}

function getEmployerHistory(personId, startDate = null, endDate = null) {
    const person = data.people.find(p => p.id === personId);
    if (!person || !person.employerHistory) return [];
   
    let filtered = person.employerHistory;
    if (startDate) filtered = filtered.filter(h => h.date >= startDate);
    if (endDate) filtered = filtered.filter(h => h.date <= endDate);
   
    return filtered.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
}

function recordColorChange(personId, previousColor, newColor, reason = 'Manual update') {
    const person = data.people.find(p => p.id === personId);
    if (!person) return;
   
    if (!person.colorHistory) person.colorHistory = [];
   
    const historyEntry = {
        id: (person.colorHistory.length > 0 ? Math.max(...person.colorHistory.map(h => h.id)) + 1 : 1),
        date: new Date().toISOString().split('T')[0],
        timestamp: new Date().toISOString(),
        previousColor: previousColor || '',
        newColor: newColor || '',
        reason: reason,
        colorName: colorPalette.find(c => c.value === newColor)?.name || 'Custom'
    };
   
    person.colorHistory.push(historyEntry);
    saveDataToLocalStorage();
}

function updateUIPreferences(preferences) {
    if (isImporting) return;
   
    if (!data.uiPreferences) {
        data.uiPreferences = {
            lastViewedTab: "overview",
            lastViewedMonth: new Date().getMonth(),
            lastViewedYear: new Date().getFullYear()
        };
    }
   
    Object.keys(preferences).forEach(key => {
        data.uiPreferences[key] = preferences[key];
    });
   
    data.uiPreferences.lastUpdated = new Date().toISOString();
   
    try {
        saveDataToLocalStorage();
    } catch (e) {
        console.warn('Failed to save UI preferences, continuing without save');
    }
}

function recordUIAction(action, details = {}) {
    if (isImporting) return;
   
    if (!data.uiActionHistory) data.uiActionHistory = [];
   
    const actionEntry = {
        id: (data.uiActionHistory.length > 0 ? Math.max(...data.uiActionHistory.map(h => h.id)) + 1 : 1),
        action: action,
        timestamp: new Date().toISOString(),
        details: typeof details === 'string' ? details : JSON.stringify(details).substring(0, 100),
        sessionId: data.sessionId || 'unknown'
    };
   
    data.uiActionHistory.push(actionEntry);
   
    if (data.uiActionHistory.length > 200) {
        data.uiActionHistory = data.uiActionHistory.slice(-100);
    }
   
    try {
        saveDataToLocalStorage();
    } catch (e) {
        console.warn('Failed to save UI action, continuing without save');
    }
}

function getColorHistory(personId, startDate = null, endDate = null) {
    const person = data.people.find(p => p.id === personId);
    if (!person || !person.colorHistory) return [];
   
    let filtered = person.colorHistory;
    if (startDate) filtered = filtered.filter(h => h.date >= startDate);
    if (endDate) filtered = filtered.filter(h => h.date <= endDate);
   
    return filtered.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
}

function recordDebtPayment(bill, paymentAmount, interestPaid, principalPaid, previousBalance, newBalance) {
    recordBillHistoryEntry(bill, 'debt_payment_processed', {
        amount: paymentAmount,
        interestPaid: interestPaid,
        principalPaid: principalPaid,
        previousData: { totalDebt: previousBalance },
        newData: { totalDebt: newBalance },
        notes: `Interest: ${formatCurrency(interestPaid)}, Principal: ${formatCurrency(principalPaid)}`
    });
   
    if (!bill.debtPaymentHistory) bill.debtPaymentHistory = [];
   
    const paymentEntry = {
        id: (bill.debtPaymentHistory.length > 0 ? Math.max(...bill.debtPaymentHistory.map(h => h.id)) + 1 : 1),
        date: new Date().toISOString().split('T')[0],
        timestamp: new Date().toISOString(),
        paymentAmount: paymentAmount,
        interestPaid: interestPaid,
        principalPaid: principalPaid,
        previousBalance: previousBalance,
        newBalance: newBalance,
        balanceReduction: previousBalance - newBalance,
        interestRate: bill.interestRate,
        overpayment: bill.overpayment || 0,
        monthlyPayment: bill.amount,
        remainingMonths: calculateRemainingMonths(newBalance, bill.amount + (bill.overpayment || 0), bill.interestRate),
        totalInterestPaidToDate: bill.debtPaymentHistory.reduce((sum, p) => sum + (p.interestPaid || 0), 0) + interestPaid
    };
   
    bill.debtPaymentHistory.push(paymentEntry);
    saveDataToLocalStorage();
}

function calculateRemainingMonths(balance, monthlyPayment, interestRate) {
    if (!interestRate || interestRate <= 0) {
        return Math.ceil(balance / monthlyPayment);
    }
   
    const monthlyRate = interestRate / 100 / 12;
    if (monthlyPayment <= balance * monthlyRate) {
        return Infinity;
    }
   
    return Math.ceil(-Math.log(1 - (balance * monthlyRate) / monthlyPayment) / Math.log(1 + monthlyRate));
}

function recordDebtCreation(bill) {
    recordBillHistoryEntry(bill, 'debt_created', {
        amount: bill.totalDebt,
        notes: `Initial debt: ${formatCurrency(bill.totalDebt)} @ ${bill.interestRate}% interest`,
        newData: {
            totalDebt: bill.totalDebt,
            interestRate: bill.interestRate,
            monthlyPayment: bill.amount,
            overpayment: bill.overpayment || 0
        }
    });
}

function recordDebtPaidOff(bill, finalPayment) {
    recordBillHistoryEntry(bill, 'debt_paid_off', {
        amount: finalPayment,
        notes: `Debt fully paid off with final payment of ${formatCurrency(finalPayment)}`,
        previousData: { totalDebt: finalPayment },
        newData: { totalDebt: 0 }
    });
   
    data.eventHistory.push({
        id: nextEventId++,
        date: new Date().toISOString().split('T')[0],
        event: 'Debt Paid Off',
        description: `${bill.name} debt fully paid off! Final payment: ${formatCurrency(finalPayment)}`
    });
}

function getDebtPaymentHistory(billId, startDate = null, endDate = null) {
    const bill = data.bills.find(b => b.id === billId);
    if (!bill || !bill.debtPaymentHistory) return [];
   
    let filtered = bill.debtPaymentHistory;
    if (startDate) filtered = filtered.filter(h => h.date >= startDate);
    if (endDate) filtered = filtered.filter(h => h.date <= endDate);
   
    return filtered.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
}

function generatePersonHistoryReport(personId, startDate = null, endDate = null) {
    const person = data.people.find(p => p.id === personId);
    if (!person) return null;
   
    return {
        personName: person.name,
        reportPeriod: {
            startDate: startDate || 'Beginning',
            endDate: endDate || 'Present'
        },
        incomeChanges: getIncomeHistory(personId, startDate, endDate),
        savingsChanges: getSavingsHistory(personId, startDate, endDate),
        expensesChanges: getExpensesHistory(personId, startDate, endDate),
        employerChanges: getEmployerHistory(personId, startDate, endDate),
        colorChanges: getColorHistory(personId, startDate, endDate),
        payrollHistory: data.paycheckHistory.filter(p => p.personId === personId &&
            (!startDate || p.date >= startDate) &&
            (!endDate || p.date <= endDate)
        ).sort((a, b) => new Date(b.date) - new Date(a.date)),
        summary: {
            totalIncomeChanges: getIncomeHistory(personId, startDate, endDate).length,
            totalSavingsChanges: getSavingsHistory(personId, startDate, endDate).length,
            totalExpensesChanges: getExpensesHistory(personId, startDate, endDate).length,
            totalPaychecks: data.paycheckHistory.filter(p => p.personId === personId &&
                (!startDate || p.date >= startDate) &&
                (!endDate || p.date <= endDate)).length,
            totalEarnedInPeriod: data.paycheckHistory.filter(p => p.personId === personId &&
                (!startDate || p.date >= startDate) &&
                (!endDate || p.date <= endDate))
                .reduce((sum, p) => sum + p.amount, 0)
        }
    };
}

function generateBillHistoryReport(billId = null, startDate = null, endDate = null) {
    const bills = billId ? [data.bills.find(b => b.id === billId)].filter(Boolean) : data.bills;
   
    return bills.map(bill => ({
        billName: bill.name,
        billId: bill.id,
        category: bill.category,
        isDebt: bill.isDebt,
        currentAmount: bill.amount,
        currentBalance: bill.totalDebt || null,
        history: getBillHistory(bill.id, null, startDate, endDate),
        debtPayments: bill.isDebt ? getDebtPaymentHistory(bill.id, startDate, endDate) : [],
        summary: {
            totalHistoryEntries: getBillHistory(bill.id, null, startDate, endDate).length,
            totalPayments: getBillHistory(bill.id, 'payment_processed', startDate, endDate).length,
            totalPaidAmount: data.billPayments.filter(p => p.billId === bill.id &&
                (!startDate || p.date >= startDate) &&
                (!endDate || p.date <= endDate))
                .reduce((sum, p) => sum + p.amount, 0),
            debtReduction: bill.isDebt && bill.debtPaymentHistory ?
                bill.debtPaymentHistory.filter(p =>
                    (!startDate || p.date >= startDate) &&
                    (!endDate || p.date <= endDate))
                .reduce((sum, p) => sum + (p.principalPaid || 0), 0) : 0
        }
    }));
}

function generateComprehensiveReport(startDate = null, endDate = null) {
    const peopleReports = data.people.map(person => generatePersonHistoryReport(person.id, startDate, endDate));
    const billReports = generateBillHistoryReport(null, startDate, endDate);
   
    const totalIncome = peopleReports.reduce((sum, report) => sum + report.summary.totalEarnedInPeriod, 0);
    const totalBillPayments = billReports.reduce((sum, report) => sum + report.summary.totalPaidAmount, 0);
    const totalDebtReduction = billReports.reduce((sum, report) => sum + report.summary.debtReduction, 0);
   
    return {
        reportMetadata: {
            generatedDate: new Date().toISOString(),
            periodStart: startDate || 'Beginning',
            periodEnd: endDate || 'Present',
            dataVersion: data.dataVersion,
            totalPeople: data.people.length,
            totalBills: data.bills.filter(b => !b.isDeleted).length
        },
        overallSummary: {
            totalIncomeInPeriod: totalIncome,
            totalBillPaymentsInPeriod: totalBillPayments,
            totalDebtReductionInPeriod: totalDebtReduction,
            netCashFlowInPeriod: totalIncome - totalBillPayments,
            savingsRate: totalIncome > 0 ? ((totalIncome - totalBillPayments) / totalIncome * 100) : 0
        },
        peopleReports: peopleReports,
        billReports: billReports,
        systemEvents: data.eventHistory.filter(e =>
            (!startDate || e.date >= startDate) &&
            (!endDate || e.date <= endDate)
        ).sort((a, b) => new Date(b.date) - new Date(a.date))
    };
}

function exportHistoryReport(reportData, filename = null) {
    const defaultFilename = `budget_history_report_${new Date().toISOString().split('T')[0]}.json`;
    const exportFilename = filename || defaultFilename;
   
    const reportString = JSON.stringify(reportData, null, 2);
    const blob = new Blob([reportString], { type: 'application/json' });
   
    if ('showSaveFilePicker' in window) {
        async function saveReport() {
            try {
                const handle = await window.showSaveFilePicker({
                    suggestedName: exportFilename,
                    types: [{
                        description: 'JSON Reports',
                        accept: { 'application/json': ['.json'] }
                    }]
                });
               
                const writable = await handle.createWritable();
                await writable.write(reportString);
                await writable.close();
               
                alert('History report saved successfully!');
            } catch (err) {
                if (err.name !== 'AbortError') {
                    console.error('Error saving report:', err);
                    alert('Error saving report. Please try again.');
                }
            }
        }
        saveReport();
    } else {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = exportFilename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        alert('History report downloaded successfully!');
    }
}

function updateExistingFunctionsWithTracking() {
    const originalAddBill = addBill;
    addBill = function() {
        const result = originalAddBill.apply(this, arguments);
        const lastBill = data.bills[data.bills.length - 1];
        if (lastBill) {
            recordBillHistoryEntry(lastBill, 'created', {
                notes: 'Bill created via form submission'
            });
            if (lastBill.isDebt) {
                recordDebtCreation(lastBill);
            }
        }
        return result;
    };

    const originalUpdatePersonSavingsExpenses = updatePersonSavingsExpenses;
    updatePersonSavingsExpenses = function(personId) {
        const person = data.people.find(p => p.id === personId);
        if (!person) return;
       
        const oldSavings = person.savings || 0;
        const oldExpenses = person.expenses || 0;
       
        const result = originalUpdatePersonSavingsExpenses.apply(this, arguments);
       
        const newSavings = person.savings || 0;
        const newExpenses = person.expenses || 0;
       
        if (oldSavings !== newSavings) {
            recordSavingsChange(personId, oldSavings, newSavings, 'Manual update via form');
        }
       
        if (oldExpenses !== newExpenses) {
            recordExpensesChange(personId, oldExpenses, newExpenses, 'Manual update via form');
        }
       
        return result;
    };

    const originalUpdatePersonIncome = updatePersonIncome;
    updatePersonIncome = function(personId) {
        const person = data.people.find(p => p.id === personId);
        if (!person) return;
       
        const oldIncome = person.income || 0;
        const oldFrequency = person.frequency;
        const oldPaymentDate = person.paymentDate;
        const oldEmployer = person.employer || '';
       
        const result = originalUpdatePersonIncome.apply(this, arguments);
       
        const newIncome = person.income || 0;
        const newFrequency = person.frequency;
        const newPaymentDate = person.paymentDate;
        const newEmployer = person.employer || '';
       
        if (oldIncome !== newIncome || oldFrequency !== newFrequency || oldPaymentDate !== newPaymentDate) {
            recordIncomeChange(personId, oldIncome, newIncome, oldFrequency, newFrequency, oldPaymentDate, newPaymentDate, 'Manual update via form');
        }
       
        if (oldEmployer !== newEmployer) {
            recordEmployerChange(personId, oldEmployer, newEmployer, 'Manual update via form');
        }
       
        return result;
    };

    const originalUpdatePersonColor = updatePersonColor;
    updatePersonColor = function(personId, colorValue) {
        const person = data.people.find(p => p.id === personId);
        if (!person) return;
       
        const oldColor = person.color;
        const result = originalUpdatePersonColor.apply(this, arguments);
       
        if (person.color !== oldColor) {
            recordColorChange(personId, oldColor, person.color, 'Manual color change');
        }
       
        return result;
    };

    const originalShowTab = showTab;
    showTab = function(tabId) {
        updateUIPreferences({
            lastViewedTab: tabId,
            lastViewedTime: new Date().toISOString()
        });
       
        recordUIAction('tab_switched', {
            newTab: tabId,
            previousTab: document.querySelector('.tab.active')?.dataset?.tab
        });
       
        return originalShowTab.apply(this, arguments);
    };

    const originalProcessElapsedBills = processElapsedBills;
    processElapsedBills = function() {
        const billsBefore = JSON.parse(JSON.stringify(data.bills));
        const result = originalProcessElapsedBills.apply(this, arguments);
       
        data.bills.forEach(bill => {
            const billBefore = billsBefore.find(b => b.id === bill.id);
            if (billBefore && bill.isDebt && billBefore.totalDebt !== bill.totalDebt) {
                const interestPaid = billBefore.totalDebt * ((bill.interestRate || 0) / 100 / 12);
                const principalPaid = billBefore.totalDebt - bill.totalDebt;
                const paymentAmount = bill.amount + (bill.overpayment || 0);
               
                recordDebtPayment(bill, paymentAmount, interestPaid, principalPaid, billBefore.totalDebt, bill.totalDebt);
               
                if (bill.totalDebt <= 0.01) {
                    recordDebtPaidOff(bill, principalPaid);
                }
            }
        });
       
        return result;
    };
}

function initializeSession() {
    if (!data.sessionId) {
        data.sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }
   
    data.sessionStartTime = new Date().toISOString();
   
    recordUIAction('session_started', {
        userAgent: navigator.userAgent,
        viewport: `${window.innerWidth}x${window.innerHeight}`,
        darkMode: document.body.classList.contains('dark-mode')
    });
   
    initializePersonHistoryTracking();
    updateExistingFunctionsWithTracking();
}

function finalizeSession() {
    recordUIAction('session_ended', {
        sessionDuration: new Date() - new Date(data.sessionStartTime),
        totalActions: data.uiActionHistory ? data.uiActionHistory.length : 0
    });
   
    data.lastSessionEndTime = new Date().toISOString();
    saveDataToLocalStorage();
}

function mergeImportBaselineWithChanges() {
   if (!isPostImport || Object.keys(importBaseline).length === 0) {
       return null;
   }

   const storedData = localStorage.getItem(STORAGE_KEY);
   let changes = {};
   
   if (storedData) {
       try {
           const parsed = JSON.parse(storedData);
           if (parsed.isPostImport && parsed.changes) {
               changes = parsed.changes;
           }
       } catch (e) {
           console.warn('Could not parse localStorage changes:', e);
       }
   }

   const mergedData = JSON.parse(JSON.stringify(importBaseline));

   mergedData.people = JSON.parse(JSON.stringify(data.people));
   mergedData.bills = JSON.parse(JSON.stringify(data.bills));
   mergedData.paycheckHistory = JSON.parse(JSON.stringify(data.paycheckHistory));
   mergedData.eventHistory = JSON.parse(JSON.stringify(data.eventHistory));
   mergedData.billPayments = JSON.parse(JSON.stringify(data.billPayments));
   mergedData.billHistory = JSON.parse(JSON.stringify(data.billHistory || []));
   mergedData.peopleIncomeSettings = JSON.parse(JSON.stringify(data.peopleIncomeSettings));
   mergedData.uiPreferences = JSON.parse(JSON.stringify(data.uiPreferences || {}));

   if (changes.currency !== undefined) {
       mergedData.currency = changes.currency;
   }

   if (changes.darkMode !== undefined) {
       mergedData.darkMode = changes.darkMode;
   }

   if (changes.weightedBills !== undefined) {
       mergedData.weightedBills = changes.weightedBills;
   }

   if (changes.lastProcessedDate) {
       mergedData.lastProcessedDate = changes.lastProcessedDate;
   }

   const currentCounters = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
   if (currentCounters.counters) {
       mergedData.nextPersonId = currentCounters.counters.nextPersonId || nextPersonId;
       mergedData.nextBillId = currentCounters.counters.nextBillId || nextBillId;
       mergedData.nextIncomeId = currentCounters.counters.nextIncomeId || nextIncomeId;
       mergedData.nextEventId = currentCounters.counters.nextEventId || nextEventId;
       mergedData.nextPaycheckId = currentCounters.counters.nextPaycheckId || nextPaycheckId;
   } else {
       mergedData.nextPersonId = nextPersonId;
       mergedData.nextBillId = nextBillId;
       mergedData.nextIncomeId = nextIncomeId;
       mergedData.nextEventId = nextEventId;
       mergedData.nextPaycheckId = nextPaycheckId;
   }

   mergedData.currency = data.currency;
   mergedData.darkMode = data.darkMode;
   mergedData.weightedBills = data.weightedBills;
   mergedData.lastProcessedDate = data.lastProcessedDate;
   mergedData.lastExportDate = new Date().toISOString();
   mergedData.dataVersion = mergedData.dataVersion || "1.0";
   
   return mergedData;
}

function updateEnhancedExportData() {
    const originalShowImportExportModal = showImportExportModal;
   
    window.showImportExportModal = function() {
        let modal = document.getElementById('editModal');
        let modalContent;
       
        if (!modal) {
            const modalData = createModal();
            modal = modalData.modal;
            modalContent = modalData.modalContent;
        } else {
            modalContent = document.getElementById('modalContent');
        }
       
        modalContent.innerHTML = `
            <h3 style="margin-bottom:10px;color:${document.body.classList.contains('dark-mode') ? '#fff' : '#000'};text-align:center;">SAVE/IMPORT</h3>
           
            <p style="text-align:center;margin-bottom:25px;padding:10px;background-color:${document.body.classList.contains('dark-mode') ? '#333' : '#f5f5f5'};border-radius:5px;font-size:14px;color:${document.body.classList.contains('dark-mode') ? '#ff9' : '#800'};">
                Enhanced tracking now includes complete history of all changes, debt payments, and user interactions.
            </p>
           
            <div style="display:flex;flex-direction:column;gap:20px;margin-bottom:20px;">
                <div>
                    <button id="importBtn" style="width:100%;height:60px;font-size:16px;font-weight:bold;">IMPORT</button>
                    <p style="margin-top:5px;font-size:13px;color:${document.body.classList.contains('dark-mode') ? '#ccc' : '#666'};">
                        Load your previously exported .txt file with full history tracking.
                    </p>
                </div>
               
                <div>
                    <button id="exportBtn" style="width:100%;height:60px;font-size:16px;font-weight:bold;">EXPORT</button>
                    <p style="margin-top:5px;font-size:13px;color:${document.body.classList.contains('dark-mode') ? '#ccc' : '#666'};">
                        Create enhanced .txt file with comprehensive tracking data.
                    </p>
                </div>
               
                <div>
                    <button id="exportHistoryReportBtn" style="width:100%;height:60px;font-size:16px;font-weight:bold;background:#4CAF50;">EXPORT HISTORY REPORT</button>
                    <p style="margin-top:5px;font-size:13px;color:${document.body.classList.contains('dark-mode') ? '#ccc' : '#666'};">
                        Generate detailed JSON report of all historical data and changes.
                    </p>
                </div>
            </div>
           
            <div style="margin-top:20px;text-align:center;">
                <button id="closeModalBtn" style="background:#666;width:150px;">Close</button>
            </div>
        `;
       
        document.getElementById('exportHistoryReportBtn').addEventListener('click', () => {
            const report = generateComprehensiveReport();
            exportHistoryReport(report);
        });
       
        document.getElementById('exportBtn').addEventListener('click', () => {
            const exportData = {
                people: JSON.parse(JSON.stringify(data.people)),
                bills: JSON.parse(JSON.stringify(data.bills)),
                currency: data.currency,
                darkMode: data.darkMode,
                weightedBills: data.weightedBills,
                paycheckHistory: JSON.parse(JSON.stringify(data.paycheckHistory)),
                billHistory: JSON.parse(JSON.stringify(data.billHistory || [])),
                eventHistory: JSON.parse(JSON.stringify(data.eventHistory)),
                billPayments: JSON.parse(JSON.stringify(data.billPayments)),
                lastProcessedDate: data.lastProcessedDate,
                peopleIncomeSettings: JSON.parse(JSON.stringify(data.peopleIncomeSettings)),
                uiPreferences: JSON.parse(JSON.stringify(data.uiPreferences || {})),
                dataVersion: data.dataVersion || "1.0",
                lastExportDate: new Date().toISOString(),
                billHistoryId: data.billHistoryId || 1
            };
           
            const exportString = btoa(JSON.stringify(exportData));
            const blob = new Blob([exportString], { type: 'text/plain' });
           
            if ('showSaveFilePicker' in window) {
                async function saveWithFilePicker() {
                    try {
                        const handle = await window.showSaveFilePicker({
                            suggestedName: 'budget_data_enhanced.txt',
                            types: [{
                                description: 'Text Files',
                                accept: { 'text/plain': ['.txt'] }
                            }]
                        });
                       
                        const writable = await handle.createWritable();
                        await writable.write(exportString);
                        await writable.close();
                       
                        recordUIAction('data_exported', { method: 'file_picker', enhanced: true });
                        alert('Enhanced data exported successfully!');
                    } catch (err) {
                        if (err.name !== 'AbortError') {
                            console.error('Error saving file:', err);
                            alert('Error saving file. Please try again.');
                        }
                    }
                }
                saveWithFilePicker();
            } else {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'budget_data_enhanced.txt';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
               
                recordUIAction('data_exported', { method: 'download', enhanced: true });
                alert('Enhanced data exported successfully!');
            }
        });
       
        return originalShowImportExportModal.apply(this, arguments);
    };
}

function validateExportData(exportData) {
    const billIds = exportData.bills.map(b => b.id);
    if (billIds.length !== new Set(billIds).size) {
        throw new Error('Duplicate bill IDs detected');
    }
    
    const maxBillId = Math.max(...exportData.bills.map(b => b.id), 0);
    if (exportData.nextBillId <= maxBillId) {
        exportData.nextBillId = maxBillId + 1;
    }
    
    const maxPersonId = Math.max(...exportData.people.map(p => p.id), 0);
    if (exportData.nextPersonId <= maxPersonId) {
        exportData.nextPersonId = maxPersonId + 1;
    }
    
    if (!exportData.people || !exportData.bills) {
        throw new Error('Missing required data arrays');
    }
    
    return true;
}



function createOneOffItem(expense) {
    const payerName = expense.payer === 'joint' ? 'Joint' :
                     data.people.find(p => p.id === expense.payer)?.name || 'Unknown';
   
    const oneOffItem = document.createElement('div');
    oneOffItem.className = 'debt-item';
   
    let itemContent = `
        <div class="info-item">
            <span class="info-label">${expense.name}</span>
            <span class="info-value">${formatCurrency(expense.amount)}</span>
        </div>
    `;
   
    if (data.people.length > 1) {
        itemContent += `
            <div class="info-item">
                <span class="info-label">Paid by</span>
                <span class="info-value">${payerName}</span>
            </div>
        `;
    }
   
    oneOffItem.innerHTML = itemContent;
    return oneOffItem;
}

function attachEventListeners() {
    loadData();
    initializeSession();
    updateGreeting();
    updateBillPayerOptions();
    updateBillsList();
    updateHistoryDisplay();
    updateOverview();
    toggleBillTypeVisibility();
   
    data.people.forEach(person => createPersonTab(person));
   
    $('hamburgerBtn').addEventListener('click', toggleSidebar);
    $('addNewPersonBtn').addEventListener('click', addNewPerson);
    $('toggleDarkModeBtn').addEventListener('click', toggleDarkMode);
    $('currencySelect').addEventListener('change', updateCurrency);
    $('weightedBillsSidebar').addEventListener('change', updateWeightedBills);
    $('addBillBtn').addEventListener('click', addBill);
    $('isDebt').addEventListener('change', toggleDebtFields);
    $('billType').addEventListener('change', toggleBillPayerVisibility);
    $('billFrequency').addEventListener('change', toggleBillFrequencyOptions);
    $('fullResetBtn').addEventListener('click', fullReset);
    $('clearHistoryFiltersBtn').addEventListener('click', clearHistoryFilters);
    $('historyPersonFilter').addEventListener('change', updateHistoryDisplay);
    $('historyStartDate').addEventListener('change', updateHistoryDisplay);
    $('historyEndDate').addEventListener('change', updateHistoryDisplay);
    $('isOneOff').addEventListener('change', toggleOneOffFields);
   
    updateEnhancedExportData();
   
    document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
            if (tab.dataset.tab === 'add-person') {
                addNewPerson();
                return;
            }
            const tabId = tab.dataset.tab || `person-${tab.dataset.personId}`;
            showTab(tabId);
        });
    });
   
    document.addEventListener('click', function(event) {
        const sidebar = $('sidebar');
        const hamburgerBtn = $('hamburgerBtn');
       
        if (sidebar.classList.contains('open')) {
            const isClickInsideSidebar = sidebar.contains(event.target);
            const isClickOnHamburgerBtn = hamburgerBtn.contains(event.target);
           
            if (!isClickInsideSidebar && !isClickOnHamburgerBtn) {
                sidebar.classList.remove('open');
            }
        }
    });
   
    window.addEventListener('beforeunload', finalizeSession);
   
    updateTabsVisibility();
}

document.addEventListener('DOMContentLoaded', attachEventListeners);

const BUDGET_DATA_KEY = 'budget_app_data';
const DARK_MODE_KEY = 'budget_app_dark_mode';

function saveAppData() {
  try {
    data.nextPersonId = nextPersonId;
    data.nextBillId = nextBillId;
    data.nextIncomeId = nextIncomeId;
    data.nextEventId = nextEventId;
    data.nextPaycheckId = nextPaycheckId;
    
    localStorage.setItem(BUDGET_DATA_KEY, JSON.stringify(data));
    localStorage.setItem(DARK_MODE_KEY, document.body.classList.contains('dark-mode'));
    
    return true;
  } catch (e) {
    console.error("Failed to save app data:", e);
    return false;
  }
}

function loadAppData() {
  try {
    const darkMode = localStorage.getItem(DARK_MODE_KEY);
    if (darkMode === 'true') {
      document.body.classList.add('dark-mode');
    } else if (darkMode === 'false') {
      document.body.classList.remove('dark-mode');
    }
    
    const savedData = localStorage.getItem(BUDGET_DATA_KEY);
    if (savedData) {
      const parsedData = JSON.parse(savedData);
      
      data = parsedData;
      
      nextPersonId = data.nextPersonId || 1;
      nextBillId = data.nextBillId || 1;
      nextIncomeId = data.nextIncomeId || 1;
      nextEventId = data.nextEventId || 1;
      nextPaycheckId = data.nextPaycheckId || 1;
      
      document.querySelectorAll('.tab[data-person-id]').forEach(tab => tab.remove());
      document.querySelectorAll('.tab-content[id^="person-"]').forEach(content => content.remove());
      
      if (darkMode === 'true') {
        document.body.classList.add('dark-mode');
        data.darkMode = true;
      } else if (darkMode === 'false') {
        document.body.classList.remove('dark-mode');
        data.darkMode = false;
      }
      
      document.getElementById('currencySelect').value = data.currency;
      document.getElementById('weightedBillsSidebar').checked = data.weightedBills;
      
      data.people.forEach(person => createPersonTab(person));
      
      updateGreeting();
      updateBillPayerOptions();
      updateBillsList();
      updateHistoryDisplay();
      updateOverview();
      toggleBillTypeVisibility();
      updateTabsVisibility();
      
      if (typeof attachPersonEventListeners === 'function') {
        attachPersonEventListeners();
      }
      
      return true;
    }
  } catch (e) {
    console.error("Failed to load app data:", e);
  }
  
  return false;
}

document.addEventListener('click', function(e) {
  if (!e.target) return;
  
  const actionButtons = [
    'addBillBtn', 'saveEditBtn', 'updatePersonBasic', 'updatePersonIncome', 
    'updatePersonSavingsExpenses', 'addPaycheckBtn', 'addBonusBtn', 
    'savePaycheckEditBtn', 'savePaymentEditBtn', 'deletePaymentFromModalBtn',
    'deletePaycheckFromModalBtn', 'fullResetBtn', 'addNewPersonBtn'
  ];
  
  if (e.target.tagName === 'BUTTON') {
    if (actionButtons.includes(e.target.id) || 
        e.target.classList.contains('btn-danger') || 
        e.target.onclick?.toString().includes('deleteBill') ||
        e.target.onclick?.toString().includes('deleteEvent') ||
        e.target.onclick?.toString().includes('deletePaycheck') ||
        e.target.onclick?.toString().includes('deletePerson') ||
        e.target.onclick?.toString().includes('addNewPerson')) {
      
      setTimeout(saveAppData, 50);
    }
  }
});

const originalUpdatePersonColor = window.updatePersonColor;
if (originalUpdatePersonColor) {
  window.updatePersonColor = function() {
    const result = originalUpdatePersonColor.apply(this, arguments);
    saveAppData();
    return result;
  };
}

const originalToggleDarkMode = window.toggleDarkMode;
if (originalToggleDarkMode) {
  window.toggleDarkMode = function() {
    const result = originalToggleDarkMode.apply(this, arguments);
    localStorage.setItem(DARK_MODE_KEY, document.body.classList.contains('dark-mode'));
    return result;
  };
}

const originalUpdateCurrency = window.updateCurrency;
if (originalUpdateCurrency) {
  window.updateCurrency = function() {
    const result = originalUpdateCurrency.apply(this, arguments);
    saveAppData();
    return result;
  };
}

const originalUpdateWeightedBills = window.updateWeightedBills;
if (originalUpdateWeightedBills) {
  window.updateWeightedBills = function() {
    const result = originalUpdateWeightedBills.apply(this, arguments);
    saveAppData();
    return result;
  };
}

const originalAddNewPerson = window.addNewPerson;
if (originalAddNewPerson) {
  window.addNewPerson = function() {
    const result = originalAddNewPerson.apply(this, arguments);
    saveAppData();
    return result;
  };
}

const originalProcessImportData = window.processImportData;
if (originalProcessImportData) {
  window.processImportData = function() {
    const wasDarkMode = document.body.classList.contains('dark-mode');
    const result = originalProcessImportData.apply(this, arguments);
    
    if (result) {
      if (wasDarkMode) {
        document.body.classList.add('dark-mode');
      } else {
        document.body.classList.remove('dark-mode');
      }
      data.darkMode = wasDarkMode;
      
      saveAppData();
    }
    
    return result;
  };
}

window.addEventListener('beforeunload', saveAppData);
window.addEventListener('pagehide', saveAppData);
document.addEventListener('pause', saveAppData);

document.getElementById('currencySelect').addEventListener('change', saveAppData);
document.getElementById('weightedBillsSidebar').addEventListener('change', saveAppData);

window.budgetAppPersistence = {
  save: saveAppData,
  load: loadAppData
};

if (document.readyState === 'complete' || document.readyState === 'interactive') {
  loadAppData();
} else {
  document.addEventListener('DOMContentLoaded', loadAppData);
}
</script>


<script>
                if ('serviceWorker' in navigator) {
                    window.addEventListener('load', function() {
                        navigator.serviceWorker.register('./sw.js')
                            .then(function(registration) {
                                console.log('ServiceWorker registration successful for scope:', registration.scope);
                            })
                            .catch(function(err) {
                                console.log('ServiceWorker registration failed: ', err);
                            });
                    });
                }

                window.addEventListener('beforeinstallprompt', (e) => {
                    console.log('PWA install prompt available');
                });

                window.addEventListener('appinstalled', () => {
                    console.log('PWA installed successfully');
                });

                function showSplashScreen() {
                    const isDarkMode = document.body.classList.contains('dark-mode') || 
                                     window.matchMedia('(prefers-color-scheme: dark)').matches;
                    
                    const splash = document.createElement('div');
                    splash.id = 'pwa-splash';
                    splash.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100vw;
                        height: 100vh;
                        background: ${isDarkMode ? '#000000' : '#ffffff'};
                        display: flex;
                        flex-direction: column;
                        justify-content: center;
                        align-items: center;
                        z-index: 10000;
                        transition: opacity 0.5s ease-out;
                    `;
                    
                    const textColor = isDarkMode ? '#ffffff' : '#333333';
                    const subTextColor = isDarkMode ? '#cccccc' : '#666666';
                    
                    const splashImageSrc = isDarkMode ? "./splash-screen-dark.png" : "./splash-screen.png";
                    
                    splash.innerHTML = `
                        <img src="${splashImageSrc}" style="max-width: 90vw; max-height: 60vh; object-fit: contain;" 
                             onerror="this.style.display='none'; document.getElementById('fallback-splash').style.display='block';">
                        <div id="fallback-splash" style="display: none; text-align: center;">
                            <div style="width: 100px; height: 100px; background: #4facfe; border-radius: 20px; margin: 0 auto 20px;"></div>
                            <h2 style="color: ${textColor}; margin-bottom: 10px;">Budget Base</h2>
                            <p style="color: ${subTextColor};">Loading...</p>
                        </div>
                    `;
                    
                    document.body.appendChild(splash);
                    
                    setTimeout(() => {
                        splash.style.opacity = '0';
                        setTimeout(() => {
                            if (splash.parentNode) {
                                splash.parentNode.removeChild(splash);
                            }
                        }, 500);
                    }, 3000);
                }

                function initializeSplash() {
                    const isStandalone = window.matchMedia && window.matchMedia('(display-mode: standalone)').matches;
                    const isIOSStandalone = window.navigator.standalone === true;
                    const isAndroidApp = document.referrer.includes('android-app://');
                    
                    if (isStandalone || isIOSStandalone || isAndroidApp) {
                        if (document.readyState === 'loading') {
                            showSplashScreen();
                        } else {
                            requestAnimationFrame(showSplashScreen);
                        }
                    }
                }
                
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', initializeSplash);
                } else {
                    initializeSplash();
                }
            </script>
<script>
                if ('serviceWorker' in navigator) {
                    window.addEventListener('load', function() {
                        navigator.serviceWorker.register('./sw.js')
                            .then(function(registration) {
                                console.log('ServiceWorker registration successful for scope:', registration.scope);
                            })
                            .catch(function(err) {
                                console.log('ServiceWorker registration failed: ', err);
                            });
                    });
                }

                window.addEventListener('beforeinstallprompt', (e) => {
                    console.log('PWA install prompt available');
                });

                window.addEventListener('appinstalled', () => {
                    console.log('PWA installed successfully');
                });

                function showSplashScreen() {
                    const isDarkMode = document.body.classList.contains('dark-mode') || 
                                     window.matchMedia('(prefers-color-scheme: dark)').matches;
                    
                    const splash = document.createElement('div');
                    splash.id = 'pwa-splash';
                    splash.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100vw;
                        height: 100vh;
                        background: ${isDarkMode ? '#000000' : '#ffffff'};
                        display: flex;
                        flex-direction: column;
                        justify-content: center;
                        align-items: center;
                        z-index: 10000;
                        transition: opacity 0.5s ease-out;
                    `;
                    
                    const textColor = isDarkMode ? '#ffffff' : '#333333';
                    const subTextColor = isDarkMode ? '#cccccc' : '#666666';
                    
                    const splashImageSrc = isDarkMode ? "./splash-screen-dark.png" : "./splash-screen.png";
                    
                    splash.innerHTML = `
                        <img src="${splashImageSrc}" style="max-width: 90vw; max-height: 60vh; object-fit: contain;" 
                             onerror="this.style.display='none'; document.getElementById('fallback-splash').style.display='block';">
                        <div id="fallback-splash" style="display: none; text-align: center;">
                            <div style="width: 100px; height: 100px; background: #4facfe; border-radius: 20px; margin: 0 auto 20px;"></div>
                            <h2 style="color: ${textColor}; margin-bottom: 10px;">Budget Base</h2>
                            <p style="color: ${subTextColor};">Loading...</p>
                        </div>
                    `;
                    
                    document.body.appendChild(splash);
                    
                    setTimeout(() => {
                        splash.style.opacity = '0';
                        setTimeout(() => {
                            if (splash.parentNode) {
                                splash.parentNode.removeChild(splash);
                            }
                        }, 500);
                    }, 3000);
                }

                function initializeSplash() {
                    const isStandalone = window.matchMedia && window.matchMedia('(display-mode: standalone)').matches;
                    const isIOSStandalone = window.navigator.standalone === true;
                    const isAndroidApp = document.referrer.includes('android-app://');
                    
                    if (isStandalone || isIOSStandalone || isAndroidApp) {
                        if (document.readyState === 'loading') {
                            showSplashScreen();
                        } else {
                            requestAnimationFrame(showSplashScreen);
                        }
                    }
                }
                
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', initializeSplash);
                } else {
                    initializeSplash();
                }
				
				document.addEventListener('click', function(event) {
				  let anchor = event.target.closest('a');
				  if (!anchor) return;
				  
				  const href = anchor.getAttribute('href');
				  if (!href) return;
				  
				  if (
					href.indexOf('://') !== -1 || 
					href.startsWith('#') || 
					anchor.getAttribute('download') || 
					anchor.getAttribute('target') === '_blank'
				  ) {
					return;
				  }
				  
				  event.preventDefault();
				  history.pushState({}, '', href);
				  window.dispatchEvent(new PopStateEvent('popstate'));
				});

				window.addEventListener('popstate', function() {
				  console.log('Navigation handled by PWA:', location.pathname);
				});

	function showCustomPrompt(config) {
	    let modal = document.getElementById('editModal');
	    let modalContent;
	    
	    if (!modal) {
	        const modalData = createModal();
	        modal = modalData.modal;
	        modalContent = modalData.modalContent;
	    } else {
	        modalContent = document.getElementById('modalContent');
	    }
	
	    const inputId = 'customPromptInput';
	    
	    modalContent.innerHTML = `
	        <h3 style="margin-bottom:20px;color:${document.body.classList.contains('dark-mode') ? '#fff' : '#000'};text-align:center;">${config.title}</h3>
	        <p style="margin-bottom:20px;color:${document.body.classList.contains('dark-mode') ? '#ccc' : '#666'};text-align:center;font-size:14px;line-height:1.5;">
	            ${config.message}
	        </p>
	        <div class="form-group">
	            <input type="text" id="${inputId}" placeholder="${config.placeholder || ''}" value="${config.defaultValue || ''}" style="width:100%;">
	        </div>
	        <div style="display:flex;gap:10px;margin-top:20px;">
	            <button id="confirmPromptBtn" style="flex:1;">${config.confirmText || 'OK'}</button>
	            <button id="cancelPromptBtn" style="flex:1;background:#666;">Cancel</button>
	        </div>
	    `;
	
	    const input = document.getElementById(inputId);
	    const confirmBtn = document.getElementById('confirmPromptBtn');
	    const cancelBtn = document.getElementById('cancelPromptBtn');
	
	    const cleanup = () => {
	        hideModal();
	    };
	
	    confirmBtn.addEventListener('click', () => {
	        const value = input.value.trim();
	        cleanup();
	        if (config.onConfirm) {
	            config.onConfirm(value);
	        }
	    });
	
	    cancelBtn.addEventListener('click', () => {
	        cleanup();
	        if (config.onCancel) {
	            config.onCancel();
	        }
	    });
	
	    input.addEventListener('keypress', (e) => {
	        if (e.key === 'Enter') {
	            confirmBtn.click();
	        }
	    });
	
	    showModal();
	    
	    setTimeout(() => {
	        input.focus();
	        input.select();
	    }, 100);
	}
	
	function showCustomConfirm(config) {
	    let modal = document.getElementById('editModal');
	    let modalContent;
	    
	    if (!modal) {
	        const modalData = createModal();
	        modal = modalData.modal;
	        modalContent = modalData.modalContent;
	    } else {
	        modalContent = document.getElementById('modalContent');
	    }
	
	    const buttonStyle = config.isDangerous ? 'background:#8e1600;color:#ffffff;' : '';
	    
	    modalContent.innerHTML = `
	        <h3 style="margin-bottom:20px;color:${document.body.classList.contains('dark-mode') ? '#fff' : '#000'};text-align:center;">${config.title}</h3>
	        <p style="margin-bottom:30px;color:${document.body.classList.contains('dark-mode') ? '#ccc' : '#666'};text-align:center;font-size:14px;line-height:1.5;">
	            ${config.message}
	        </p>
	        <div style="display:flex;gap:10px;justify-content:center;">
	            <button id="confirmActionBtn" style="${buttonStyle}">${config.confirmText || 'OK'}</button>
	            <button id="cancelActionBtn" style="background:#666;">Cancel</button>
	        </div>
	    `;
	
	    document.getElementById('confirmActionBtn').addEventListener('click', () => {
	        hideModal();
	        if (config.onConfirm) {
	            config.onConfirm();
	        }
	    });
	
	    document.getElementById('cancelActionBtn').addEventListener('click', () => {
	        hideModal();
	        if (config.onCancel) {
	            config.onCancel();
	        }
	    });
	
	    showModal();
	}
	
	function showCustomAlert(config) {
	    let modal = document.getElementById('editModal');
	    let modalContent;
	    
	    if (!modal) {
	        const modalData = createModal();
	        modal = modalData.modal;
	        modalContent = modalData.modalContent;
	    } else {
	        modalContent = document.getElementById('modalContent');
	    }
	
	    modalContent.innerHTML = `
	        <h3 style="margin-bottom:20px;color:${document.body.classList.contains('dark-mode') ? '#fff' : '#000'};text-align:center;">${config.title}</h3>
	        <p style="margin-bottom:30px;color:${document.body.classList.contains('dark-mode') ? '#ccc' : '#666'};text-align:center;font-size:14px;line-height:1.5;">
	            ${config.message}
	        </p>
	        <div style="text-align:center;">
	            <button id="alertOkBtn">${config.confirmText || 'OK'}</button>
	        </div>
	    `;
	
	    document.getElementById('alertOkBtn').addEventListener('click', () => {
	        hideModal();
	        if (config.onConfirm) {
	            config.onConfirm();
	        }
	    });
	
	    showModal();
	}
	
	function customAddNewPerson() {
	    showCustomPrompt({
	        title: 'Add New User',
	        message: 'Enter the name for the new user. You can add more users using the sidemenu ☰',
	        placeholder: 'Enter user name...',
	        confirmText: 'Add User',
	        onConfirm: (name) => {
	            if (!name) {
	                showCustomAlert({
	                    title: 'Invalid Input',
	                    message: 'Please enter a valid name.',
	                    onConfirm: () => customAddNewPerson()
	                });
	                return;
	            }
	
	            if (data.people.some(p => p.name.toLowerCase() === name.toLowerCase())) {
	                showCustomAlert({
	                    title: 'Duplicate Name',
	                    message: 'A person with this name already exists!',
	                    onConfirm: () => customAddNewPerson()
	                });
	                return;
	            }
	
	            const newPerson = {
	                id: nextPersonId++,
	                name: name,
	                income: 0,
	                frequency: 'monthly',
	                paymentDate: '',
	                savings: 0,
	                expenses: 0,
	                employer: '',
	                color: colorPalette[data.people.length % colorPalette.length].value
	            };
	
	            data.people.push(newPerson);
	            recordEvent('Person Added', `Added ${name} to budget tracker`);
	
	            saveDataToLocalStorage();
	            createPersonTab(newPerson);
	            attachPersonEventListeners();
	            updateGreeting();
	            updateBillPayerOptions();
	            updateHistoryDisplay();
	            updateOverview();
	            toggleBillTypeVisibility();
	            updateTabsVisibility();
	
	            const sidebar = document.getElementById('sidebar');
	            if (sidebar.classList.contains('open')) {
	                sidebar.classList.remove('open');
	            }
	
	            showTab(`person-${newPerson.id}`);
	        },
	        onCancel: () => {}
	    });
	}
	
	function customDeleteBill(billId) {
	    const bill = data.bills.find(b => b.id === billId);
	    if (!bill) return;
	
	    const title = bill.isOneOff ? 'Delete One-Off Expense' : 'Delete Bill';
	    const message = bill.isOneOff ? 
	        'Delete this one-off expense? This will remove it completely from all records and history.' :
	        'Are you sure you want to stop this bill? This will prevent future payments but keep the payment history.';
	
	    showCustomConfirm({
	        title: title,
	        message: message,
	        confirmText: 'Delete',
	        isDangerous: true,
	        onConfirm: () => {
	            const today = getDateString();
	
	            bill.isDeleted = true;
	            bill.deletedDate = today;
	
	            if (bill.isOneOff) {
	                const relatedPayments = data.billPayments.filter(payment => payment.billId === bill.id);
	                
	                if (relatedPayments.length > 0) {
	                    data.billPayments = data.billPayments.filter(payment => payment.billId !== bill.id);
	                }
	                
	                recordEvent('One Off Expense Deleted', `Deleted one-off expense: ${bill.name} - ${formatCurrency(bill.amount + (bill.overpayment || 0))}. All records removed.`);
	            } else {
	                const futurePayments = data.billPayments.filter(payment =>
	                    payment.billId === bill.id &&
	                    payment.date > today
	                );
	
	                if (futurePayments.length > 0) {
	                    data.billPayments = data.billPayments.filter(payment =>
	                        !(payment.billId === bill.id && payment.date > today)
	                    );
	                }
	            }
	
	            if (bill.isDebt) {
	                bill.isDebt = false;
	                bill.totalDebt = 0;
	                bill.interestRate = 0;
	                bill.termYears = 0;
	                bill.termMonths = 0;
	                bill.overpayment = 0;
	            }
	
	            saveDataToLocalStorage();
	            updateBillsList();
	            updateHistoryDisplay();
	            updateOverview();
	            updateOneOffOverview();
	            resetCalendarToCurrentMonth();
	            toggleBillTypeVisibility();
	            ensureDataConsistency();
	        }
	    });
	}
	
	function customDeletePerson(personId) {
	    const person = data.people.find(p => p.id === personId);
	    if (!person) return;
	
	    if (data.bills.some(b => b.payer === person.id)) {
	        showCustomAlert({
	            title: 'Cannot Delete User',
	            message: 'Cannot delete person with associated bills. Please reassign or delete their bills first.'
	        });
	        return;
	    }
	
	    showCustomConfirm({
	        title: 'Delete User',
	        message: `Are you sure you want to delete ${person.name} and their associated data? This cannot be undone.`,
	        confirmText: 'Delete',
	        isDangerous: true,
	        onConfirm: () => {
	            data.people = data.people.filter(p => p.id !== personId);
	            data.paycheckHistory = data.paycheckHistory.filter(p => p.personId !== personId);
	            
	            recordEvent('Person Deleted', `Deleted ${person.name} from budget tracker`);
	            
	            saveDataToLocalStorage();
	            
	            const tab = document.querySelector(`button.tab[data-person-id="${personId}"]`);
	            if (tab) tab.remove();
	            
	            const content = document.getElementById(`person-${personId}`);
	            if (content) content.remove();
	            
	            updateGreeting();
	            updateBillPayerOptions();
	            updateHistoryDisplay();
	            updateOverview();
	            toggleBillTypeVisibility();
	            updateTabsVisibility();
	            
	            showTab('overview');
	        }
	    });
	}
	
	function customFullReset() {
	    showCustomConfirm({
	        title: 'Full Reset',
	        message: 'Are you sure you want to reset all data? This will permanently delete all users, bills, income history, and settings. This cannot be undone.',
	        confirmText: 'Reset All Data',
	        isDangerous: true,
	        onConfirm: () => {
	            data = {
	                people: [],
	                bills: [],
	                currency: "USD",
	                darkMode: document.body.classList.contains('dark-mode'),
	                weightedBills: false,
	                nextPersonId: 1,
	                nextBillId: 1,
	                nextIncomeId: 1,
	                nextEventId: 1,
	                nextPaycheckId: 1,
	                paycheckHistory: [],
	                billHistory: [],
	                eventHistory: [],
	                billPayments: [],
	                lastProcessedDate: null,
	                peopleIncomeSettings: {},
	                uiPreferences: {},
	                savedFileHandle: null,
	                billHistoryId: 1,
	                dataVersion: "1.0"
	            };
	            
	            nextPersonId = 1;
	            nextBillId = 1;
	            nextIncomeId = 1;
	            nextEventId = 1;
	            nextPaycheckId = 1;
	            savedFileHandle = null;
	            
	            localStorage.removeItem('budgetTrackerData');
	            isPostImport = false;
	            importBaseline = {};
	            
	            document.querySelectorAll('.tab[data-person-id]').forEach(tab => tab.remove());
	            document.querySelectorAll('.tab-content[id^="person-"]').forEach(content => content.remove());
	            
	            updateGreeting();
	            updateBillPayerOptions();
	            updateBillsList();
	            updateHistoryDisplay();
	            updateOverview();
	            toggleBillTypeVisibility();
	            showTab('overview');
	        }
	    });
	}
	
	function customDeleteEvent(eventId) {
	    const event = data.eventHistory.find(e => e.id === eventId);
	    if (!event) return;
	
	    showCustomConfirm({
	        title: 'Delete Event',
	        message: `Are you sure you want to delete this event? This cannot be undone.\n\nEvent: ${event.event}\nDate: ${event.date}`,
	        confirmText: 'Delete',
	        isDangerous: true,
	        onConfirm: () => {
	            data.eventHistory = data.eventHistory.filter(e => e.id !== eventId);
	            saveDataToLocalStorage();
	            updateHistoryDisplay();
	        }
	    });
	}
	
	function customDeletePaycheck(paycheckId, personId) {
	    const paycheck = data.paycheckHistory.find(p => p.id === paycheckId);
	    if (!paycheck) return;
	
	    showCustomConfirm({
	        title: 'Delete Income Entry',
	        message: `Are you sure you want to delete this income entry? This cannot be undone.\n\n${paycheck.personName}: ${formatCurrency(paycheck.amount)} on ${paycheck.date}`,
	        confirmText: 'Delete',
	        isDangerous: true,
	        onConfirm: () => {
	            data.paycheckHistory = data.paycheckHistory.filter(p => p.id !== paycheckId);
	            
	            data.eventHistory.push({
	                id: nextEventId++,
	                date: getDateString(),
	                event: 'Paycheck Deleted',
	                description: `Deleted ${formatCurrency(paycheck.amount)} ${paycheck.type} for ${paycheck.personName} on ${paycheck.date}`
	            });
	            
	            saveDataToLocalStorage();
	            updatePersonOverview(personId);
	            updateHistoryDisplay();
	            updateOverview();
	            ensureDataConsistency();
	        }
	    });
	}
	
	function customDeletePaycheckFromModal(paycheckId) {
	    const paycheck = data.paycheckHistory.find(p => p.id === paycheckId);
	    if (!paycheck) return;
	
	    showCustomConfirm({
	        title: 'Delete Income Entry',
	        message: `Are you sure you want to delete this income entry? This cannot be undone.\n\n${paycheck.personName}: ${formatCurrency(paycheck.amount)} on ${paycheck.date}`,
	        confirmText: 'Delete',
	        isDangerous: true,
	        onConfirm: () => {
	            hideModal();
	            deletePaycheck(paycheckId, paycheck.personId);
	        }
	    });
	}
	
	function customDeleteBillPaymentFromModal(paymentId) {
	    const payment = data.billPayments.find(p => p.id === paymentId);
	    if (!payment) return;
	
	    const originalBill = data.bills.find(b => b.id === payment.billId);
	
	    showCustomConfirm({
	        title: 'Delete Payment Record',
	        message: `Are you sure you want to delete this payment record? This cannot be undone.\n\n${payment.billName}: ${formatCurrency(payment.amount)} on ${payment.date}`,
	        confirmText: 'Delete',
	        isDangerous: true,
	        onConfirm: () => {
	            data.billPayments = data.billPayments.filter(p => p.id !== paymentId);
	            
	            if (originalBill && originalBill.isOneOff) {
	                originalBill.isDeleted = true;
	                originalBill.deletedDate = getDateString();
	            }
	            
	            data.eventHistory.push({
	                id: nextEventId++,
	                date: getDateString(),
	                event: 'Bill Payment Deleted',
	                description: `Deleted payment record: ${payment.billName} - ${formatCurrency(payment.amount)} from ${payment.date}`
	            });
	            
	            saveDataToLocalStorage();
	            updateHistoryDisplay();
	            updateBillsList();
	            updateOverview();
	            updateOneOffOverview();
	            updateCalendarView();
	            hideModal();
	        }
	    });
	}
	
	window.addNewPerson = customAddNewPerson;
	window.deleteBill = customDeleteBill;
	window.deletePerson = customDeletePerson;
	window.fullReset = customFullReset;
	window.deleteEvent = customDeleteEvent;
	window.deletePaycheck = customDeletePaycheck;
	
	window.alert = function(message) {
	    if (message.includes('Please')) {
	        showCustomAlert({
	            title: 'Required Field',
	            message: message
	        });
	    } else if (message.includes('already exists') || message.includes('Duplicate')) {
	        showCustomAlert({
	            title: 'Duplicate Entry',
	            message: message
	        });
	    } else if (message.includes('Cannot') || message.includes('Error')) {
	        showCustomAlert({
	            title: 'Error',
	            message: message
	        });
	    } else if (message.includes('success') || message.includes('Success') || message.includes('saved') || message.includes('exported') || message.includes('imported')) {
	        showCustomAlert({
	            title: 'Success',
	            message: message
	        });
	    } else {
	        showCustomAlert({
	            title: 'Notice',
	            message: message
	        });
	    }
	};
            </script></body></html>
